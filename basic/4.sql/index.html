<!doctype html><html lang=zh class=no-js> <head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="MySQL WIKI"><meta name=author content=fengzhao><link href=https://mysql.fengzhao.me/basic/4.sql/ rel=canonical><link href=../3.mysql_execute_command/ rel=prev><link href=../5.relation/ rel=next><link rel=icon href=../../assets/images/favicon.png><meta name=generator content="mkdocs-1.5.3, mkdocs-material-9.5.17"><title>4. SQL语句和语法 - MySQL WIKI</title><link rel=stylesheet href=../../assets/stylesheets/main.bcfcd587.min.css><link rel=stylesheet href=../../assets/stylesheets/palette.06af60db.min.css><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback"><style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style><link rel=stylesheet href=../../stylesheets/extra.css><script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script></head> <body dir=ltr data-md-color-scheme=default data-md-color-primary=indigo data-md-color-accent=indigo> <input class=md-toggle data-md-toggle=drawer type=checkbox id=__drawer autocomplete=off> <input class=md-toggle data-md-toggle=search type=checkbox id=__search autocomplete=off> <label class=md-overlay for=__drawer></label> <div data-md-component=skip> <a href=#sql class=md-skip> 跳转至 </a> </div> <div data-md-component=announce> </div> <header class="md-header md-header--shadow md-header--lifted" data-md-component=header> <nav class="md-header__inner md-grid" aria-label=页眉> <a href=../.. title="MySQL WIKI" class="md-header__button md-logo" aria-label="MySQL WIKI" data-md-component=logo> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg> </a> <label class="md-header__button md-icon" for=__drawer> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg> </label> <div class=md-header__title data-md-component=header-title> <div class=md-header__ellipsis> <div class=md-header__topic> <span class=md-ellipsis> MySQL WIKI </span> </div> <div class=md-header__topic data-md-component=header-topic> <span class=md-ellipsis> 4. SQL语句和语法 </span> </div> </div> </div> <form class=md-header__option data-md-component=palette> <input class=md-option data-md-color-media data-md-color-scheme=default data-md-color-primary=indigo data-md-color-accent=indigo aria-label="Switch to dark mode" type=radio name=__palette id=__palette_0> <label class="md-header__button md-icon" title="Switch to dark mode" for=__palette_1 hidden> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M17 6H7c-3.31 0-6 2.69-6 6s2.69 6 6 6h10c3.31 0 6-2.69 6-6s-2.69-6-6-6zm0 10H7c-2.21 0-4-1.79-4-4s1.79-4 4-4h10c2.21 0 4 1.79 4 4s-1.79 4-4 4zM7 9c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/></svg> </label> <input class=md-option data-md-color-media data-md-color-scheme=slate data-md-color-primary=indigo data-md-color-accent=indigo aria-label="Switch to light mode" type=radio name=__palette id=__palette_1> <label class="md-header__button md-icon" title="Switch to light mode" for=__palette_0 hidden> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M17 7H7a5 5 0 0 0-5 5 5 5 0 0 0 5 5h10a5 5 0 0 0 5-5 5 5 0 0 0-5-5m0 8a3 3 0 0 1-3-3 3 3 0 0 1 3-3 3 3 0 0 1 3 3 3 3 0 0 1-3 3Z"/></svg> </label> </form> <script>var media,input,key,value,palette=__md_get("__palette");if(palette&&palette.color){"(prefers-color-scheme)"===palette.color.media&&(media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']"),palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent"));for([key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script> <label class="md-header__button md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg> </label> <div class=md-search data-md-component=search role=dialog> <label class=md-search__overlay for=__search></label> <div class=md-search__inner role=search> <form class=md-search__form name=search> <input type=text class=md-search__input name=query aria-label=搜索 placeholder=搜索 autocapitalize=off autocorrect=off autocomplete=off spellcheck=false data-md-component=search-query required> <label class="md-search__icon md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg> </label> <nav class=md-search__options aria-label=查找> <button type=reset class="md-search__icon md-icon" title=清空当前内容 aria-label=清空当前内容 tabindex=-1> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg> </button> </nav> </form> <div class=md-search__output> <div class=md-search__scrollwrap data-md-scrollfix> <div class=md-search-result data-md-component=search-result> <div class=md-search-result__meta> 正在初始化搜索引擎 </div> <ol class=md-search-result__list role=presentation></ol> </div> </div> </div> </div> </div> <div class=md-header__source> <a href=https://github.com/fengzhao/mysql-wiki title=前往仓库 class=md-source data-md-component=source> <div class="md-source__icon md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 448 512"><!-- Font Awesome Free 6.5.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg> </div> <div class=md-source__repository> fengzhao/mysql-wiki </div> </a> </div> </nav> <nav class=md-tabs aria-label=标签 data-md-component=tabs> <div class=md-grid> <ul class=md-tabs__list> <li class=md-tabs__item> <a href=../.. class=md-tabs__link> Home </a> </li> <li class=md-tabs__item> <a href=../../resources/ class=md-tabs__link> 学习资源 </a> </li> <li class="md-tabs__item md-tabs__item--active"> <a href=../0.mysql_source/ class=md-tabs__link> MySQL入门 </a> </li> <li class=md-tabs__item> <a href=../../sql/sql2023/ class=md-tabs__link> SQL特性 </a> </li> <li class=md-tabs__item> <a href=../../foundmental/2.MySQL%E7%B4%A2%E5%BC%95/ class=md-tabs__link> MySQL基础 </a> </li> <li class=md-tabs__item> <a href=../../advanced/1.MySQL%E6%9E%B6%E6%9E%84%E5%88%B0InnoDB%E6%9E%B6%E6%9E%84/ class=md-tabs__link> MySQL高级 </a> </li> <li class=md-tabs__item> <a href=../../optimize/1.overview/ class=md-tabs__link> MySQL调优 </a> </li> <li class=md-tabs__item> <a href=../../postgresql/01.postgresql%E7%AE%80%E4%BB%8B/ class=md-tabs__link> PostgreSQL </a> </li> <li class=md-tabs__item> <a href=../../mongodb/01.%E7%AE%80%E4%BB%8B/ class=md-tabs__link> MongoDB </a> </li> <li class=md-tabs__item> <a href=../../redis/01.redis%E7%AE%80%E4%BB%8B/ class=md-tabs__link> Redis </a> </li> <li class=md-tabs__item> <a href=../../%E7%AE%97%E6%B3%95/01.%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/ class=md-tabs__link> 算法 </a> </li> <li class=md-tabs__item> <a href=../../oracle/01.Oracle%E6%A6%82%E8%BF%B0/ class=md-tabs__link> Oracle </a> </li> <li class=md-tabs__item> <a href=../../network/1.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/ class=md-tabs__link> network </a> </li> </ul> </div> </nav> </header> <div class=md-container data-md-component=container> <main class=md-main data-md-component=main> <div class="md-main__inner md-grid"> <div class="md-sidebar md-sidebar--primary" data-md-component=sidebar data-md-type=navigation> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--primary md-nav--lifted" aria-label=导航栏 data-md-level=0> <label class=md-nav__title for=__drawer> <a href=../.. title="MySQL WIKI" class="md-nav__button md-logo" aria-label="MySQL WIKI" data-md-component=logo> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg> </a> MySQL WIKI </label> <div class=md-nav__source> <a href=https://github.com/fengzhao/mysql-wiki title=前往仓库 class=md-source data-md-component=source> <div class="md-source__icon md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 448 512"><!-- Font Awesome Free 6.5.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg> </div> <div class=md-source__repository> fengzhao/mysql-wiki </div> </a> </div> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../.. class=md-nav__link> <span class=md-ellipsis> Home </span> </a> </li> <li class=md-nav__item> <a href=../../resources/ class=md-nav__link> <span class=md-ellipsis> 学习资源 </span> </a> </li> <li class="md-nav__item md-nav__item--active md-nav__item--section md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_3 checked> <label class=md-nav__link for=__nav_3 id=__nav_3_label tabindex> <span class=md-ellipsis> MySQL入门 </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=1 aria-labelledby=__nav_3_label aria-expanded=true> <label class=md-nav__title for=__nav_3> <span class="md-nav__icon md-icon"></span> MySQL入门 </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../0.mysql_source/ class=md-nav__link> <span class=md-ellipsis> 0. MySQL的起源和分支 </span> </a> </li> <li class=md-nav__item> <a href=../1.introduce_database/ class=md-nav__link> <span class=md-ellipsis> 1. 数据库概述 </span> </a> </li> <li class=md-nav__item> <a href=../2.install_mysql/ class=md-nav__link> <span class=md-ellipsis> 2. 安装 MySQL </span> </a> </li> <li class=md-nav__item> <a href=../3.mysql_execute_command/ class=md-nav__link> <span class=md-ellipsis> 3. MySQL可执行程序 </span> </a> </li> <li class="md-nav__item md-nav__item--active"> <input class="md-nav__toggle md-toggle" type=checkbox id=__toc> <label class="md-nav__link md-nav__link--active" for=__toc> <span class=md-ellipsis> 4. SQL语句和语法 </span> <span class="md-nav__icon md-icon"></span> </label> <a href=./ class="md-nav__link md-nav__link--active"> <span class=md-ellipsis> 4. SQL语句和语法 </span> </a> <nav class="md-nav md-nav--secondary" aria-label=目录> <label class=md-nav__title for=__toc> <span class="md-nav__icon md-icon"></span> 目录 </label> <ul class=md-nav__list data-md-component=toc data-md-scrollfix> <li class=md-nav__item> <a href=#sql_1 class=md-nav__link> <span class=md-ellipsis> SQL 语言概述 </span> </a> </li> <li class=md-nav__item> <a href=#sql_2 class=md-nav__link> <span class=md-ellipsis> SQL 标准的符合性 </span> </a> </li> <li class=md-nav__item> <a href=#sql_3 class=md-nav__link> <span class=md-ellipsis> SQL 开发规范 </span> </a> <nav class=md-nav aria-label="SQL 开发规范"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#_1 class=md-nav__link> <span class=md-ellipsis> 团队对齐 </span> </a> </li> <li class=md-nav__item> <a href=#_2 class=md-nav__link> <span class=md-ellipsis> 集成到开发工作流程中 </span> </a> </li> <li class=md-nav__item> <a href=#cicd class=md-nav__link> <span class=md-ellipsis> 集成到 CI/CD 中 </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#sql_4 class=md-nav__link> <span class=md-ellipsis> SQL 语法和注释 </span> </a> </li> <li class=md-nav__item> <a href=#_3 class=md-nav__link> <span class=md-ellipsis> 字符串字面量 </span> </a> </li> <li class=md-nav__item> <a href=#_4 class=md-nav__link> <span class=md-ellipsis> 数据库的创建与删除 </span> </a> <nav class=md-nav aria-label=数据库的创建与删除> <ul class=md-nav__list> <li class=md-nav__item> <a href=#_5 class=md-nav__link> <span class=md-ellipsis> 表的创建 </span> </a> </li> <li class=md-nav__item> <a href=#_6 class=md-nav__link> <span class=md-ellipsis> 生成列 </span> </a> </li> <li class=md-nav__item> <a href=#_7 class=md-nav__link> <span class=md-ellipsis> 数据插入 </span> </a> </li> <li class=md-nav__item> <a href=#_8 class=md-nav__link> <span class=md-ellipsis> 数据更新 </span> </a> <nav class=md-nav aria-label=数据更新> <ul class=md-nav__list> <li class=md-nav__item> <a href=#_9 class=md-nav__link> <span class=md-ellipsis> 关联更新 </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#_10 class=md-nav__link> <span class=md-ellipsis> 数据删除 </span> </a> </li> <li class=md-nav__item> <a href=#_11 class=md-nav__link> <span class=md-ellipsis> 合并数据 </span> </a> </li> <li class=md-nav__item> <a href=#_12 class=md-nav__link> <span class=md-ellipsis> 返回数据 </span> </a> </li> <li class=md-nav__item> <a href=#_13 class=md-nav__link> <span class=md-ellipsis> 外键约束与级联操作 </span> </a> </li> <li class=md-nav__item> <a href=#_14 class=md-nav__link> <span class=md-ellipsis> 查询基础 </span> </a> </li> <li class=md-nav__item> <a href=#sql_5 class=md-nav__link> <span class=md-ellipsis> SQL 查询语句的执行过程 </span> </a> </li> <li class=md-nav__item> <a href=#exist-in class=md-nav__link> <span class=md-ellipsis> EXIST 和 IN 查询 </span> </a> </li> <li class=md-nav__item> <a href=#with-cte class=md-nav__link> <span class=md-ellipsis> WITH 查询（CTE） </span> </a> <nav class=md-nav aria-label="WITH 查询（CTE）"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#cte class=md-nav__link> <span class=md-ellipsis> 递归 CTE </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#_15 class=md-nav__link> <span class=md-ellipsis> 查询排序 </span> </a> <nav class=md-nav aria-label=查询排序> <ul class=md-nav__list> <li class=md-nav__item> <a href=#_16 class=md-nav__link> <span class=md-ellipsis> 空值排序 </span> </a> </li> <li class=md-nav__item> <a href=#_17 class=md-nav__link> <span class=md-ellipsis> 中文排序 </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#_18 class=md-nav__link> <span class=md-ellipsis> 派生表和子查询 </span> </a> </li> <li class=md-nav__item> <a href=#_19 class=md-nav__link> <span class=md-ellipsis> 联表查询 </span> </a> <nav class=md-nav aria-label=联表查询> <ul class=md-nav__list> <li class=md-nav__item> <a href=#_20 class=md-nav__link> <span class=md-ellipsis> 笛卡尔积/交叉连接 </span> </a> </li> <li class=md-nav__item> <a href=#_21 class=md-nav__link> <span class=md-ellipsis> 自然连接 </span> </a> </li> <li class=md-nav__item> <a href=#_22 class=md-nav__link> <span class=md-ellipsis> 等值连接 </span> </a> </li> <li class=md-nav__item> <a href=#_23 class=md-nav__link> <span class=md-ellipsis> 内连接 </span> </a> </li> <li class=md-nav__item> <a href=#_24 class=md-nav__link> <span class=md-ellipsis> 外连接 </span> </a> </li> <li class=md-nav__item> <a href=#_25 class=md-nav__link> <span class=md-ellipsis> 半连接 </span> </a> </li> <li class=md-nav__item> <a href=#_26 class=md-nav__link> <span class=md-ellipsis> 反连接 </span> </a> </li> <li class=md-nav__item> <a href=#_27 class=md-nav__link> <span class=md-ellipsis> 不等值连接 </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#_28 class=md-nav__link> <span class=md-ellipsis> 分组查询 </span> </a> <nav class=md-nav aria-label=分组查询> <ul class=md-nav__list> <li class=md-nav__item> <a href=#_29 class=md-nav__link> <span class=md-ellipsis> 分组合计小计 </span> </a> </li> <li class=md-nav__item> <a href=#mysql-group-by class=md-nav__link> <span class=md-ellipsis> MySQL group by 隐式排序 </span> </a> </li> <li class=md-nav__item> <a href=#_30 class=md-nav__link> <span class=md-ellipsis> 分组原理和优化 </span> </a> <nav class=md-nav aria-label=分组原理和优化> <ul class=md-nav__list> <li class=md-nav__item> <a href=#_31 class=md-nav__link> <span class=md-ellipsis> 分组操作如何利用索引？ </span> </a> <nav class=md-nav aria-label=分组操作如何利用索引？> <ul class=md-nav__list> <li class=md-nav__item> <a href=#loose-index-scan class=md-nav__link> <span class=md-ellipsis> 松散索引(Loose Index Scan) </span> </a> </li> <li class=md-nav__item> <a href=#tight-index-scan class=md-nav__link> <span class=md-ellipsis> 紧凑索引扫描(Tight Index Scan) </span> </a> </li> <li class=md-nav__item> <a href=#_32 class=md-nav__link> <span class=md-ellipsis> 尽量使用内存表 </span> </a> </li> <li class=md-nav__item> <a href=#sql_big_result class=md-nav__link> <span class=md-ellipsis> 使用 SQL_BIG_RESULT 优化 </span> </a> </li> </ul> </nav> </li> </ul> </nav> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#_33 class=md-nav__link> <span class=md-ellipsis> 对分组限定条件 </span> </a> </li> <li class=md-nav__item> <a href=#_34 class=md-nav__link> <span class=md-ellipsis> 去重查询 </span> </a> <nav class=md-nav aria-label=去重查询> <ul class=md-nav__list> <li class=md-nav__item> <a href=#_35 class=md-nav__link> <span class=md-ellipsis> 分组去重的关系和区别 </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#_36 class=md-nav__link> <span class=md-ellipsis> 集合查询 </span> </a> </li> <li class=md-nav__item> <a href=#_37 class=md-nav__link> <span class=md-ellipsis> 集合运算 </span> </a> </li> <li class=md-nav__item> <a href=#_38 class=md-nav__link> <span class=md-ellipsis> 行转列/列转行 </span> </a> </li> <li class=md-nav__item> <a href=#sql-null-default class=md-nav__link> <span class=md-ellipsis> SQL 中的 null 和 DEFAULT </span> </a> </li> <li class=md-nav__item> <a href=#_39 class=md-nav__link> <span class=md-ellipsis> 元数据查询 </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#_40 class=md-nav__link> <span class=md-ellipsis> 运算符 </span> </a> </li> <li class=md-nav__item> <a href=#_41 class=md-nav__link> <span class=md-ellipsis> 函数 </span> </a> <nav class=md-nav aria-label=函数> <ul class=md-nav__list> <li class=md-nav__item> <a href=#_42 class=md-nav__link> <span class=md-ellipsis> 数学函数 </span> </a> </li> <li class=md-nav__item> <a href=#_43 class=md-nav__link> <span class=md-ellipsis> 聚合函数 </span> </a> </li> <li class=md-nav__item> <a href=#_44 class=md-nav__link> <span class=md-ellipsis> 字符串函数 </span> </a> </li> <li class=md-nav__item> <a href=#_45 class=md-nav__link> <span class=md-ellipsis> 日期时间函数 </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#_46 class=md-nav__link> <span class=md-ellipsis> 触发器 </span> </a> </li> <li class=md-nav__item> <a href=#_47 class=md-nav__link> <span class=md-ellipsis> 存储过程 </span> </a> <nav class=md-nav aria-label=存储过程> <ul class=md-nav__list> <li class=md-nav__item> <a href=#_48 class=md-nav__link> <span class=md-ellipsis> 流程控制语句 </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#_49 class=md-nav__link> <span class=md-ellipsis> 窗口函数 </span> </a> <nav class=md-nav aria-label=窗口函数> <ul class=md-nav__list> <li class=md-nav__item> <a href=#_50 class=md-nav__link> <span class=md-ellipsis> 窗口函数和聚合函数的区别 </span> </a> </li> </ul> </nav> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=../5.relation/ class=md-nav__link> <span class=md-ellipsis> 5. 关系模型和关系代数 </span> </a> </li> <li class=md-nav__item> <a href=../6.sql_practice/ class=md-nav__link> <span class=md-ellipsis> 6. SQL题目练习 </span> </a> </li> <li class=md-nav__item> <a href=../7.MySQL%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/ class=md-nav__link> <span class=md-ellipsis> 7. MySQL数据类型 </span> </a> </li> <li class=md-nav__item> <a href=../8.MySQL%E5%AD%97%E7%AC%A6%E9%9B%86%E5%92%8C%E6%8E%92%E5%BA%8F%E8%A7%84%E5%88%99/ class=md-nav__link> <span class=md-ellipsis> 8. MySQL字符集和排序规则 </span> </a> </li> <li class=md-nav__item> <a href=../9.mysql_architecture/ class=md-nav__link> <span class=md-ellipsis> 9. MySQL逻辑架构 </span> </a> </li> <li class=md-nav__item> <a href=../10.MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/ class=md-nav__link> <span class=md-ellipsis> 10. MySQL存储引擎 </span> </a> </li> <li class=md-nav__item> <a href=../11.sql-Transaction/ class=md-nav__link> <span class=md-ellipsis> 11. MySQL事务和锁 </span> </a> </li> <li class=md-nav__item> <a href=../12.MySQL%E5%86%85%E5%AD%98%E6%A6%82%E8%BF%B0/ class=md-nav__link> <span class=md-ellipsis> 12. MySQL内存概述 </span> </a> </li> <li class=md-nav__item> <a href=../13.MySQL%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%93%E5%BC%80%E5%92%8C%E5%85%B3%E9%97%AD%E8%A1%A8/ class=md-nav__link> <span class=md-ellipsis> 13. MySQL是如何打开和关闭表 </span> </a> </li> <li class=md-nav__item> <a href=../14.MySQL%E6%95%B0%E6%8D%AE%E5%AD%97%E5%85%B8/ class=md-nav__link> <span class=md-ellipsis> 14. MySQL数据字典 </span> </a> </li> <li class=md-nav__item> <a href=../15.%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/ class=md-nav__link> <span class=md-ellipsis> 15. MySQL数据文件格式 </span> </a> </li> <li class=md-nav__item> <a href=../16.MySQL%E5%88%86%E5%8C%BA%E8%A1%A8/ class=md-nav__link> <span class=md-ellipsis> 16. MySQL分区表 </span> </a> </li> <li class=md-nav__item> <a href=../17.MySQL%E5%BF%AB%E9%80%9F%E5%AF%BC%E5%85%A5%E6%95%B0%E6%8D%AE/ class=md-nav__link> <span class=md-ellipsis> 17. MySQL快速导入数据 </span> </a> </li> <li class=md-nav__item> <a href=../18.MySQL%E4%B8%B4%E6%97%B6%E8%A1%A8/ class=md-nav__link> <span class=md-ellipsis> 18. MySQL临时表 </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_4> <label class=md-nav__link for=__nav_4 id=__nav_4_label tabindex=0> <span class=md-ellipsis> SQL特性 </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=1 aria-labelledby=__nav_4_label aria-expanded=false> <label class=md-nav__title for=__nav_4> <span class="md-nav__icon md-icon"></span> SQL特性 </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../sql/sql2023/ class=md-nav__link> <span class=md-ellipsis> 1.SQL2023新特性 </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_5> <label class=md-nav__link for=__nav_5 id=__nav_5_label tabindex=0> <span class=md-ellipsis> MySQL基础 </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=1 aria-labelledby=__nav_5_label aria-expanded=false> <label class=md-nav__title for=__nav_5> <span class="md-nav__icon md-icon"></span> MySQL基础 </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../foundmental/2.MySQL%E7%B4%A2%E5%BC%95/ class=md-nav__link> <span class=md-ellipsis> 1.索引相关 </span> </a> </li> <li class=md-nav__item> <a href=../../dev/02.%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/ class=md-nav__link> <span class=md-ellipsis> 2.数据库设计 </span> </a> </li> <li class=md-nav__item> <a href=../../dev/03.%E5%9C%A8%E7%BA%BFDDL/ class=md-nav__link> <span class=md-ellipsis> 3.在线DDL </span> </a> </li> <li class=md-nav__item> <a href=../../dev/04.MySQL%E8%BF%9E%E8%A1%A8%E6%9F%A5%E8%AF%A2%E7%AE%97%E6%B3%95/ class=md-nav__link> <span class=md-ellipsis> 4.联表算法 </span> </a> </li> <li class=md-nav__item> <a href=../../dev/05.MySQL-insert%E8%AF%AD%E6%B3%95/ class=md-nav__link> <span class=md-ellipsis> 5.insert语法 </span> </a> </li> <li class=md-nav__item> <a href=../../dev/06.MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/ class=md-nav__link> <span class=md-ellipsis> 6.MySQL主从复制 </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_6> <label class=md-nav__link for=__nav_6 id=__nav_6_label tabindex=0> <span class=md-ellipsis> MySQL高级 </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=1 aria-labelledby=__nav_6_label aria-expanded=false> <label class=md-nav__title for=__nav_6> <span class="md-nav__icon md-icon"></span> MySQL高级 </label> <ul class=md-nav__list data-md-scrollfix> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_6_1> <label class=md-nav__link for=__nav_6_1 id=__nav_6_1_label tabindex=0> <span class=md-ellipsis> 深入理解innoDB存储引擎 </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=2 aria-labelledby=__nav_6_1_label aria-expanded=false> <label class=md-nav__title for=__nav_6_1> <span class="md-nav__icon md-icon"></span> 深入理解innoDB存储引擎 </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../advanced/1.MySQL%E6%9E%B6%E6%9E%84%E5%88%B0InnoDB%E6%9E%B6%E6%9E%84/ class=md-nav__link> <span class=md-ellipsis> 1.MySQL架构到innoDB架构 </span> </a> </li> <li class=md-nav__item> <a href=../../advanced/2.InnoDB%E2%80%94%E2%80%94%E7%AE%80%E4%BB%8B/ class=md-nav__link> <span class=md-ellipsis> 2.InnoDB——简介 </span> </a> </li> <li class=md-nav__item> <a href=../../advanced/3.InnoDB%E2%80%94%E2%80%94%E5%85%B3%E9%94%AE%E7%89%B9%E6%80%A7/ class=md-nav__link> <span class=md-ellipsis> 3.InnoDB关键特性 </span> </a> </li> <li class=md-nav__item> <a href=../../advanced/4.InnoDB%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E7%BC%93%E5%86%B2%E6%B1%A0/ class=md-nav__link> <span class=md-ellipsis> 4.InnoDB内存结构——缓冲池 </span> </a> </li> <li class=md-nav__item> <a href=../../advanced/5.MySQL%E6%BA%90%E4%BB%A3%E7%A0%81%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83/ class=md-nav__link> <span class=md-ellipsis> 5.搭建MySQL源代码调试debug环境 </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_6_2> <label class=md-nav__link for=__nav_6_2 id=__nav_6_2_label tabindex=0> <span class=md-ellipsis> OLAP </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=2 aria-labelledby=__nav_6_2_label aria-expanded=false> <label class=md-nav__title for=__nav_6_2> <span class="md-nav__icon md-icon"></span> OLAP </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../olap/01.OLAP%E6%A6%82%E8%BF%B0/ class=md-nav__link> <span class=md-ellipsis> 1.0.OLAP概述 </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_6_3> <label class=md-nav__link for=__nav_6_3 id=__nav_6_3_label tabindex=0> <span class=md-ellipsis> MySQL协议分析 </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=2 aria-labelledby=__nav_6_3_label aria-expanded=false> <label class=md-nav__title for=__nav_6_3> <span class="md-nav__icon md-icon"></span> MySQL协议分析 </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../foundmental/1.MySQL%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8A%93%E5%8C%85%E6%A6%82%E8%BF%B0/ class=md-nav__link> <span class=md-ellipsis> 1.协议分析概述 </span> </a> </li> </ul> </nav> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_7> <label class=md-nav__link for=__nav_7 id=__nav_7_label tabindex=0> <span class=md-ellipsis> MySQL调优 </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=1 aria-labelledby=__nav_7_label aria-expanded=false> <label class=md-nav__title for=__nav_7> <span class="md-nav__icon md-icon"></span> MySQL调优 </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../optimize/1.overview/ class=md-nav__link> <span class=md-ellipsis> 调优概述 </span> </a> </li> <li class=md-nav__item> <a href=../../optimize/many_tables/ class=md-nav__link> <span class=md-ellipsis> 数据大小 </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_8> <label class=md-nav__link for=__nav_8 id=__nav_8_label tabindex=0> <span class=md-ellipsis> PostgreSQL </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=1 aria-labelledby=__nav_8_label aria-expanded=false> <label class=md-nav__title for=__nav_8> <span class="md-nav__icon md-icon"></span> PostgreSQL </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../postgresql/01.postgresql%E7%AE%80%E4%BB%8B/ class=md-nav__link> <span class=md-ellipsis> 1. PostgreSQL简介 </span> </a> </li> <li class=md-nav__item> <a href=../../postgresql/02.postgresql%E5%AE%89%E8%A3%85/ class=md-nav__link> <span class=md-ellipsis> 2. PogreSQL安装 </span> </a> </li> <li class=md-nav__item> <a href=../../postgresql/03.%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/ class=md-nav__link> <span class=md-ellipsis> 3. PogreSQL体系架构 </span> </a> </li> <li class=md-nav__item> <a href=../../postgresql/04.postgresql%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/ class=md-nav__link> <span class=md-ellipsis> 4. PogreSQL访问控制 </span> </a> </li> <li class=md-nav__item> <a href=../../postgresql/05.%E5%B8%B8%E7%94%A8SQL/ class=md-nav__link> <span class=md-ellipsis> 5. 常用SQL </span> </a> </li> <li class=md-nav__item> <a href=../../postgresql/06.%E7%BB%A7%E6%89%BF%E8%A1%A8/ class=md-nav__link> <span class=md-ellipsis> 6. 继承 </span> </a> </li> <li class=md-nav__item> <a href=../../postgresql/07.%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0/ class=md-nav__link> <span class=md-ellipsis> 7. 用户自定义函数UDF </span> </a> </li> <li class=md-nav__item> <a href=../../postgresql/08.%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/ class=md-nav__link> <span class=md-ellipsis> 8. 基本数据类型 </span> </a> </li> <li class=md-nav__item> <a href=../../postgresql/09.%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F/ class=md-nav__link> <span class=md-ellipsis> 9. 可执行程序 </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_9> <label class=md-nav__link for=__nav_9 id=__nav_9_label tabindex=0> <span class=md-ellipsis> MongoDB </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=1 aria-labelledby=__nav_9_label aria-expanded=false> <label class=md-nav__title for=__nav_9> <span class="md-nav__icon md-icon"></span> MongoDB </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../mongodb/01.%E7%AE%80%E4%BB%8B/ class=md-nav__link> <span class=md-ellipsis> 0. MongoDB概述 </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_10> <label class=md-nav__link for=__nav_10 id=__nav_10_label tabindex=0> <span class=md-ellipsis> Redis </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=1 aria-labelledby=__nav_10_label aria-expanded=false> <label class=md-nav__title for=__nav_10> <span class="md-nav__icon md-icon"></span> Redis </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../redis/01.redis%E7%AE%80%E4%BB%8B/ class=md-nav__link> <span class=md-ellipsis> 0. redis概述 </span> </a> </li> <li class=md-nav__item> <a href=../../redis/02.redis%E5%AE%A2%E6%88%B7%E7%AB%AF/ class=md-nav__link> <span class=md-ellipsis> 2. redis客户端 </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_11> <label class=md-nav__link for=__nav_11 id=__nav_11_label tabindex=0> <span class=md-ellipsis> 算法 </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=1 aria-labelledby=__nav_11_label aria-expanded=false> <label class=md-nav__title for=__nav_11> <span class="md-nav__icon md-icon"></span> 算法 </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../%E7%AE%97%E6%B3%95/01.%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/ class=md-nav__link> <span class=md-ellipsis> 0. 算法概述 </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_12> <label class=md-nav__link for=__nav_12 id=__nav_12_label tabindex=0> <span class=md-ellipsis> Oracle </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=1 aria-labelledby=__nav_12_label aria-expanded=false> <label class=md-nav__title for=__nav_12> <span class="md-nav__icon md-icon"></span> Oracle </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../oracle/01.Oracle%E6%A6%82%E8%BF%B0/ class=md-nav__link> <span class=md-ellipsis> 1.Oracle概述 </span> </a> </li> <li class=md-nav__item> <a href=../../oracle/02.oracle安装.md class=md-nav__link> <span class=md-ellipsis> 2.Oracle安装 </span> </a> </li> <li class=md-nav__item> <a href=../../oracle/03.Oracle体系架构.md class=md-nav__link> <span class=md-ellipsis> 3.Oracle体系架构 </span> </a> </li> <li class=md-nav__item> <a href=../../oracle/04.oracle访问控制.md class=md-nav__link> <span class=md-ellipsis> 4.Oracle访问控制 </span> </a> </li> <li class=md-nav__item> <a href=../../oracle/05.常用SQL.md class=md-nav__link> <span class=md-ellipsis> 5.常用SQL </span> </a> </li> <li class=md-nav__item> <a href=../../oracle/06.%E8%BE%BE%E6%A2%A6%E4%BC%98%E5%8C%96/ class=md-nav__link> <span class=md-ellipsis> 6.达梦优化 </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_13> <label class=md-nav__link for=__nav_13 id=__nav_13_label tabindex=0> <span class=md-ellipsis> network </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=1 aria-labelledby=__nav_13_label aria-expanded=false> <label class=md-nav__title for=__nav_13> <span class="md-nav__icon md-icon"></span> network </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../network/1.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/ class=md-nav__link> <span class=md-ellipsis> 1.计算机网络概述 </span> </a> </li> </ul> </nav> </li> </ul> </nav> </div> </div> </div> <div class="md-sidebar md-sidebar--secondary" data-md-component=sidebar data-md-type=toc> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--secondary" aria-label=目录> <label class=md-nav__title for=__toc> <span class="md-nav__icon md-icon"></span> 目录 </label> <ul class=md-nav__list data-md-component=toc data-md-scrollfix> <li class=md-nav__item> <a href=#sql_1 class=md-nav__link> <span class=md-ellipsis> SQL 语言概述 </span> </a> </li> <li class=md-nav__item> <a href=#sql_2 class=md-nav__link> <span class=md-ellipsis> SQL 标准的符合性 </span> </a> </li> <li class=md-nav__item> <a href=#sql_3 class=md-nav__link> <span class=md-ellipsis> SQL 开发规范 </span> </a> <nav class=md-nav aria-label="SQL 开发规范"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#_1 class=md-nav__link> <span class=md-ellipsis> 团队对齐 </span> </a> </li> <li class=md-nav__item> <a href=#_2 class=md-nav__link> <span class=md-ellipsis> 集成到开发工作流程中 </span> </a> </li> <li class=md-nav__item> <a href=#cicd class=md-nav__link> <span class=md-ellipsis> 集成到 CI/CD 中 </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#sql_4 class=md-nav__link> <span class=md-ellipsis> SQL 语法和注释 </span> </a> </li> <li class=md-nav__item> <a href=#_3 class=md-nav__link> <span class=md-ellipsis> 字符串字面量 </span> </a> </li> <li class=md-nav__item> <a href=#_4 class=md-nav__link> <span class=md-ellipsis> 数据库的创建与删除 </span> </a> <nav class=md-nav aria-label=数据库的创建与删除> <ul class=md-nav__list> <li class=md-nav__item> <a href=#_5 class=md-nav__link> <span class=md-ellipsis> 表的创建 </span> </a> </li> <li class=md-nav__item> <a href=#_6 class=md-nav__link> <span class=md-ellipsis> 生成列 </span> </a> </li> <li class=md-nav__item> <a href=#_7 class=md-nav__link> <span class=md-ellipsis> 数据插入 </span> </a> </li> <li class=md-nav__item> <a href=#_8 class=md-nav__link> <span class=md-ellipsis> 数据更新 </span> </a> <nav class=md-nav aria-label=数据更新> <ul class=md-nav__list> <li class=md-nav__item> <a href=#_9 class=md-nav__link> <span class=md-ellipsis> 关联更新 </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#_10 class=md-nav__link> <span class=md-ellipsis> 数据删除 </span> </a> </li> <li class=md-nav__item> <a href=#_11 class=md-nav__link> <span class=md-ellipsis> 合并数据 </span> </a> </li> <li class=md-nav__item> <a href=#_12 class=md-nav__link> <span class=md-ellipsis> 返回数据 </span> </a> </li> <li class=md-nav__item> <a href=#_13 class=md-nav__link> <span class=md-ellipsis> 外键约束与级联操作 </span> </a> </li> <li class=md-nav__item> <a href=#_14 class=md-nav__link> <span class=md-ellipsis> 查询基础 </span> </a> </li> <li class=md-nav__item> <a href=#sql_5 class=md-nav__link> <span class=md-ellipsis> SQL 查询语句的执行过程 </span> </a> </li> <li class=md-nav__item> <a href=#exist-in class=md-nav__link> <span class=md-ellipsis> EXIST 和 IN 查询 </span> </a> </li> <li class=md-nav__item> <a href=#with-cte class=md-nav__link> <span class=md-ellipsis> WITH 查询（CTE） </span> </a> <nav class=md-nav aria-label="WITH 查询（CTE）"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#cte class=md-nav__link> <span class=md-ellipsis> 递归 CTE </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#_15 class=md-nav__link> <span class=md-ellipsis> 查询排序 </span> </a> <nav class=md-nav aria-label=查询排序> <ul class=md-nav__list> <li class=md-nav__item> <a href=#_16 class=md-nav__link> <span class=md-ellipsis> 空值排序 </span> </a> </li> <li class=md-nav__item> <a href=#_17 class=md-nav__link> <span class=md-ellipsis> 中文排序 </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#_18 class=md-nav__link> <span class=md-ellipsis> 派生表和子查询 </span> </a> </li> <li class=md-nav__item> <a href=#_19 class=md-nav__link> <span class=md-ellipsis> 联表查询 </span> </a> <nav class=md-nav aria-label=联表查询> <ul class=md-nav__list> <li class=md-nav__item> <a href=#_20 class=md-nav__link> <span class=md-ellipsis> 笛卡尔积/交叉连接 </span> </a> </li> <li class=md-nav__item> <a href=#_21 class=md-nav__link> <span class=md-ellipsis> 自然连接 </span> </a> </li> <li class=md-nav__item> <a href=#_22 class=md-nav__link> <span class=md-ellipsis> 等值连接 </span> </a> </li> <li class=md-nav__item> <a href=#_23 class=md-nav__link> <span class=md-ellipsis> 内连接 </span> </a> </li> <li class=md-nav__item> <a href=#_24 class=md-nav__link> <span class=md-ellipsis> 外连接 </span> </a> </li> <li class=md-nav__item> <a href=#_25 class=md-nav__link> <span class=md-ellipsis> 半连接 </span> </a> </li> <li class=md-nav__item> <a href=#_26 class=md-nav__link> <span class=md-ellipsis> 反连接 </span> </a> </li> <li class=md-nav__item> <a href=#_27 class=md-nav__link> <span class=md-ellipsis> 不等值连接 </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#_28 class=md-nav__link> <span class=md-ellipsis> 分组查询 </span> </a> <nav class=md-nav aria-label=分组查询> <ul class=md-nav__list> <li class=md-nav__item> <a href=#_29 class=md-nav__link> <span class=md-ellipsis> 分组合计小计 </span> </a> </li> <li class=md-nav__item> <a href=#mysql-group-by class=md-nav__link> <span class=md-ellipsis> MySQL group by 隐式排序 </span> </a> </li> <li class=md-nav__item> <a href=#_30 class=md-nav__link> <span class=md-ellipsis> 分组原理和优化 </span> </a> <nav class=md-nav aria-label=分组原理和优化> <ul class=md-nav__list> <li class=md-nav__item> <a href=#_31 class=md-nav__link> <span class=md-ellipsis> 分组操作如何利用索引？ </span> </a> <nav class=md-nav aria-label=分组操作如何利用索引？> <ul class=md-nav__list> <li class=md-nav__item> <a href=#loose-index-scan class=md-nav__link> <span class=md-ellipsis> 松散索引(Loose Index Scan) </span> </a> </li> <li class=md-nav__item> <a href=#tight-index-scan class=md-nav__link> <span class=md-ellipsis> 紧凑索引扫描(Tight Index Scan) </span> </a> </li> <li class=md-nav__item> <a href=#_32 class=md-nav__link> <span class=md-ellipsis> 尽量使用内存表 </span> </a> </li> <li class=md-nav__item> <a href=#sql_big_result class=md-nav__link> <span class=md-ellipsis> 使用 SQL_BIG_RESULT 优化 </span> </a> </li> </ul> </nav> </li> </ul> </nav> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#_33 class=md-nav__link> <span class=md-ellipsis> 对分组限定条件 </span> </a> </li> <li class=md-nav__item> <a href=#_34 class=md-nav__link> <span class=md-ellipsis> 去重查询 </span> </a> <nav class=md-nav aria-label=去重查询> <ul class=md-nav__list> <li class=md-nav__item> <a href=#_35 class=md-nav__link> <span class=md-ellipsis> 分组去重的关系和区别 </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#_36 class=md-nav__link> <span class=md-ellipsis> 集合查询 </span> </a> </li> <li class=md-nav__item> <a href=#_37 class=md-nav__link> <span class=md-ellipsis> 集合运算 </span> </a> </li> <li class=md-nav__item> <a href=#_38 class=md-nav__link> <span class=md-ellipsis> 行转列/列转行 </span> </a> </li> <li class=md-nav__item> <a href=#sql-null-default class=md-nav__link> <span class=md-ellipsis> SQL 中的 null 和 DEFAULT </span> </a> </li> <li class=md-nav__item> <a href=#_39 class=md-nav__link> <span class=md-ellipsis> 元数据查询 </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#_40 class=md-nav__link> <span class=md-ellipsis> 运算符 </span> </a> </li> <li class=md-nav__item> <a href=#_41 class=md-nav__link> <span class=md-ellipsis> 函数 </span> </a> <nav class=md-nav aria-label=函数> <ul class=md-nav__list> <li class=md-nav__item> <a href=#_42 class=md-nav__link> <span class=md-ellipsis> 数学函数 </span> </a> </li> <li class=md-nav__item> <a href=#_43 class=md-nav__link> <span class=md-ellipsis> 聚合函数 </span> </a> </li> <li class=md-nav__item> <a href=#_44 class=md-nav__link> <span class=md-ellipsis> 字符串函数 </span> </a> </li> <li class=md-nav__item> <a href=#_45 class=md-nav__link> <span class=md-ellipsis> 日期时间函数 </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#_46 class=md-nav__link> <span class=md-ellipsis> 触发器 </span> </a> </li> <li class=md-nav__item> <a href=#_47 class=md-nav__link> <span class=md-ellipsis> 存储过程 </span> </a> <nav class=md-nav aria-label=存储过程> <ul class=md-nav__list> <li class=md-nav__item> <a href=#_48 class=md-nav__link> <span class=md-ellipsis> 流程控制语句 </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#_49 class=md-nav__link> <span class=md-ellipsis> 窗口函数 </span> </a> <nav class=md-nav aria-label=窗口函数> <ul class=md-nav__list> <li class=md-nav__item> <a href=#_50 class=md-nav__link> <span class=md-ellipsis> 窗口函数和聚合函数的区别 </span> </a> </li> </ul> </nav> </li> </ul> </nav> </div> </div> </div> <div class=md-content data-md-component=content> <article class="md-content__inner md-typeset"> <h1 id=sql>SQL 语法<a class=headerlink href=#sql title="Permanent link">&para;</a></h1> <p>在不同的关系型数据库管理系统中，==实例==和==模式==都有不同的概念。在 MySQL 中，分别有如下意义：</p> <ul> <li>实例（instance）：一个操作系统中启动中的一个 mysqld 守护进程被称为一个数据库实例。</li> <li>数据库（database）：存放多个相关业务数据表的逻辑对象。</li> <li>模式（schema）：MySQL 中 schema 等同于 database。</li> </ul> <p>在数据库管理系统中，Schema 是指数据库的结构和组织方式的描述，它定义了如何存储和组织数据，以及数据之间的关系和约束。简单来说，Schema 是数据库的蓝图，它决定了数据库中有哪些表、每个表有哪些字段以及它们之间的关系。</p> <blockquote> <p>根据 <code>SQL</code> 标准定义，SCHEMA（模式） 是一个描述符的持久命名集合（a persistent, named collection of descriptors） SCHEMA 中通常包含了表、列、数据类型、视图、存储过程、关系、主键和外键等 <strong>关系型数据库对象</strong> 。</p> </blockquote> <p><mark><strong>在 SQL 标准中，SCHEMA 是组织数据库对象的基本逻辑结构，它创建了一个独立的命名空间，确保了数据库内部对象的结构化、隔离和管理</strong></mark></p> <p><strong>SCHEMA 和 DATABASE 是否等同？</strong></p> <p>涉及到数据库的模式有很多疑惑，问题经常出现在模式和数据库之间是否有区别，如果有，区别在哪里。</p> <p><mark>取决于数据库厂商，对 schema（模式）产生疑惑的一部分原因是不同的数据库厂商系统倾向于以自己的方式处理模式。</mark></p> <p>造成疑惑的另一个原因可能是由于 schema 这一术语具有如此广泛的含义，因为它在不同的环境下有不同的含义，schema 一词源于希腊语 skhēma，意思是形态(form)，轮廓(figure)，形状(shape)或方案(plan)。Schema 在心理学中被用来描述组织信息类别及其之间关系的有组织的思维或行为模式。</p> <p>我们在设计一个数据库之前，还需要看看数据中的信息种类和它们之间的关系，在我们开始使用 DBMS 中的物理模式之前，我们需要创建一个概念模式。</p> <p>在软件开发中讨论模式时，可以讨论概念模式、物理模式、内部模式、外部模式、逻辑模式等，每一个都有其特定的含义。</p> <p>可以在<a href=https://dev.mysql.com/doc/refman/8.0/en/glossary.html>MySQL 术语表</a>中查到上面这些定义。</p> <p>在关系型数据库术语中，模式（schema）是一个逻辑概念，通常被看作是一个数据库对象的集合，用于组织数据库中的对象。</p> <p>模式中的对象通常包括表、索引（Tables）、数据类型、序列、视图（Views）、存储过程（Stored Procedures）、主键、外键等等。</p> <p>一个数据库下面可以包含多个<code>Schema</code>，而每个 <code>Schema</code> 又可以包含多个数据库对象。这种层级结构使得数据库的管理和维护变得更加有序和高效。</p> <p>然而，并非所有数据库都实现了 <code>Schema</code> 这一层。例如，MySQL 直接将 <code>Schema</code> 和 <code>Database</code> 等效，而在 <code>PostgreSQL</code>、<code>Oracle</code>、<code>SQL Server</code> 等数据库中，Schema 的含义并不完全相同。因此，在实际应用中，我们需要根据所使用的数据库系统来理解 <code>Schema</code> 的具体含义和用法。</p> <p>模式可以为数据库对象提供逻辑隔离功能，不用应用程序可以使用各自的模式，实现安全的访问权限控制。</p> <ul> <li> <p>对于 MySQL 而言，模式和数据库是同义词。语法中的 SCHEMA 都可以使用 DATABASE 替代，例如 <code>CREATE DATABASE</code> 和 <code>CREATE SCHEMA</code> 的作用完全相同。</p> </li> <li> <p>PostgreSQL 中的一个数据库包含一个或多个模式，一个模式包含多个对象（表、索引、函数等）。模式的管理使用 <code>CREATE SCHEMA</code>、<code>DROP SCHEMA</code> 等语句。</p> </li> <li> <p>Oracle 数据库中的模式概念和其他数据库产品不同，它和用户的概念关系紧密。Oracle 数据库中的一个用户对应一个模式，用户名就是模式名。模式中的对象都属于这个用户。对于模式的管理，实际上就是用户的管理，例如 <code>CREATE USER</code>、<code>DROP USER</code>。</p> </li> </ul> <p>数据库一词，在不同的上下文有不同的含义，因为它可以是数据库产品、数据库服务（系统）、数据库实例、数据库进程其中之一，而这些名词所表示的是不同的事物。</p> <p><mark>在 MySQL 中，用户和模式(或者说数据库)没有任何直接关系，可以单独的分别实现对用户和模式进行管理</mark>。它们之间是通过权限访问来关联使用，可以多对多来关联实现。（一个用户可以访问多个模式中的多个对象。一个模式也可以被多个用户访问）。也可以很简单的跨用户赋权。A 用户想访问(DDL/DML)db_test 模式中的某些对象(表，视图等)</p> <p>Oracle 中的 SCHEMA 与 DATABASE 之间的关系</p> <p>Oracle 中的 SCHEMA 与其他数据库系统大不相同，它与数据库用户密切相关。Oracle 官方文档指出，SCHEMA 是数据或模式对象的逻辑结构的集合，由数据库用户拥有，并且与该用户具有相同的名称，也就是说每个用户拥有一个独立的 SCHEMA。</p> <p>Oracle 数据库中 Schema 和 User 的关系是一一对应的，也就是说一个 Schema 只对应一个 User，一个 User 对应一个 Schema。当某个 User 下面有 table,view,Index......等 Schema Object 时，这个 User 就成了一个 Schema。Schema 是指一个用户所拥有的数据库对象的集合，用于权限管理和命名空间隔离，我个人把他理解成一个"用户空间"。"Schema 对象"是指在某个 Schema 中的数据库对象，例如 Schema 中的表、视图、索引等；非 Schema 对象是指不属于某个 Schema 的数据库对象，例如用户、角色、表空间等。</p> <p><mark>Oracle 其实并不支持单独 CREATE SCHEMA 这种语句的</mark></p> <p>同时，这种赋权还是很麻烦的。要允许用户 A 对用户 B 的对象（如表）进行操作，用户 A 必须具有相应的权限。用户 B 需要授予用户 A 这些权限。</p> <div class=highlight><pre><span></span><code><span class=c1>-- 用户 B 授予用户 A 对表 table_name 的 SELECT 权限</span>
<span class=k>GRANT</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=k>ON</span><span class=w> </span><span class=n>userB</span><span class=p>.</span><span class=k>table_name</span><span class=w> </span><span class=k>TO</span><span class=w> </span><span class=n>userA</span><span class=p>;</span>

<span class=c1>-- 用户 B 授予用户 A 对表 table_name 的 INSERT 和 UPDATE 权限</span>
<span class=k>GRANT</span><span class=w> </span><span class=k>INSERT</span><span class=p>,</span><span class=w> </span><span class=k>UPDATE</span><span class=w> </span><span class=k>ON</span><span class=w> </span><span class=n>userB</span><span class=p>.</span><span class=k>table_name</span><span class=w> </span><span class=k>TO</span><span class=w> </span><span class=n>userA</span><span class=p>;</span>



<span class=c1>-- 用户 B 授予用户 A 对其所有表的 SELECT 权限</span>
<span class=k>BEGIN</span>
<span class=w>   </span><span class=k>FOR</span><span class=w> </span><span class=n>rec</span><span class=w> </span><span class=k>IN</span><span class=w> </span><span class=p>(</span><span class=k>SELECT</span><span class=w> </span><span class=k>table_name</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>all_tables</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=k>owner</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s1>&#39;USERB&#39;</span><span class=p>)</span><span class=w> </span><span class=n>LOOP</span>
<span class=w>      </span><span class=k>EXECUTE</span><span class=w> </span><span class=k>IMMEDIATE</span><span class=w> </span><span class=s1>&#39;GRANT SELECT ON userB.&#39;</span><span class=w> </span><span class=o>||</span><span class=w> </span><span class=n>rec</span><span class=p>.</span><span class=k>table_name</span><span class=w> </span><span class=o>||</span><span class=w> </span><span class=s1>&#39; TO userA&#39;</span><span class=p>;</span>
<span class=w>   </span><span class=k>END</span><span class=w> </span><span class=n>LOOP</span><span class=p>;</span>
<span class=k>END</span><span class=p>;</span>
</code></pre></div> <p><strong>数据库产品</strong></p> <p>是指由各数据库厂商提供的产品或服务，如 Oracle、MySQL、PostgreSQL，以及各云厂商提供的各种云数据库服务，需要付费或者下载才能得到的物件，此为软件，类似于商品。当拿到数据库产品时，拿到的是一份数据库产品的软件拷贝；而购买在线云数据库服务时，得到的是云数据库的使用权限。</p> <p><strong>数据库实例</strong></p> <p>是指将数据库产品的软件安装到硬件环境上后，由操作系统调度所运行起来的一系列程序，它由一个或多个操作系统进程、内存、数据存储单元所构成，即软件程序的运行态。学习过面向对象的同学，就非常清楚"实例"的含义。当数据库系统退出时，数据库实例也就消亡。SQLite 是一个**嵌入式（Embedded）**数据库，它的实现是一个小巧的 C 语言库。当您使用 SQLite 时，这个库会被直接链接到您的应用程序中。而 Oracle 、MySQL、PostgreSQL 这些数据库产品，运行后的实例都由多个数据库进程协调工作。</p> <p>数据库服务（系统），是指部署了数据库产品后所运行起来后，对外提供了数据操作相关的一系列功能的服务系统，通过程序或者接口来获取这些功能。数据库服务（系统）可由多个数据库实例组成（比如集群）。某些情况，数据库服务与数据库实例很难区分。</p> <h2 id=sql_1>SQL 语言概述<a class=headerlink href=#sql_1 title="Permanent link">&para;</a></h2> <p>SQL 语言概览</p> <p>SQL 最早是 IBM 公司开发，最初称作 Sequel，后来变为 SQL（结构化查询语言），SQL 的标准是由美国国家标准化组织和国际标准化组织制定。</p> <p>IBM 对关系数据库以及<code>SQL</code>语言的形成和规范化产生了重大的影响，第一个版本的<code>SQL</code>标准<code>SQL86</code>就是基于<code>System R</code>的手册而来的。Oracle 在 1979 年率先推出了支持<code>SQL</code>的商用产品。随着数据库技术和应用的发展，为不同<code>RDBMS</code>提供一致的语言成了一种现实需要。</p> <p>对<code>SQL</code>标准影响最大的机构自然是那些著名的数据库产商，而具体的制订者则是一些非营利机构，例如**国际标准化组织 ISO**和**美国国家标准委员会 ANSI**。各国通常会按照<code>ISO</code>标准和<code>ANSI</code>标准制定自己的国家标准。</p> <p>**美国国家标准化组织 ANSI**一个核准多种行业标准的组织。SQL 作为关系型数据库所使用的标准语言，最初是基于 IBM 的实现在 1986 年被批准的。1987 年，**国际标准化组织 ISO**把<code>ANSI SQL</code>作为国际标准。</p> <p>SQL 有两个主要的标准，分别是<code>SQL92</code>和<code>SQL99</code>。92 和 99 代表了标准提出的时间，<code>SQL92</code>就是 92 年提出的标准规范。除了<code>SQL92</code>和<code>SQL99</code>以外，还有其他的标准。</p> <p>下面是 SQL 标准简要的发展与演化历史：</p> <ul> <li>1986 年，ANSI X3.135-1986，ISO/IEC 9075:1986，SQL-86。这是 ANSI 首次将 SQL 语言标准化的版本。</li> <li>1989 年，ANSI X3.135-1989，ISO/IEC 9075:1989，SQL-89。增加了完整性约束。</li> <li>1992 年，ANSI X3.135-1992，ISO/IEC 9075:1992，SQL-92（SQL2）。最重要的一个版本。 引入了标准的分级概念。<a href=../../assets/sql1992.txt>sql92</a></li> <li>1999 年，ISO/IEC 9075:1999，SQL:1999（SQL3）。变动最大的一个版本。改变了标准符合程度的定义；增加了面向对象特性、正则表达式、存储过程、Java 等支持。</li> <li>2003 年，ISO/IEC 9075:2003，SQL:2003。引入了 XML、Window 函数等。</li> <li>2008 年，ISO/IEC 9075:2008，SQL:2008。引入了 TRUNCATE 等。</li> <li>2011 年，ISO/IEC 9075:2011，SQL:2011。引入了时序数据等。</li> <li>2016 年，ISO/IEC 9075:2016，SQL:2016。引入了 JSON 等。</li> <li>2023 年，ISO/IEC 9075:2023，SQL:2023</li> </ul> <p>细心的读者能发现，从 <code>SQL:1999</code> 开始，标准简称中的短横线（-）被换成了冒号（:），而且标准制定的年份也改用四位数字了。</p> <p>前一个修改的原因是 ISO 标准习惯上采用冒号，ANSI 标准则一直采用短横线。后一个修改的原因是标准的命名也遇到了 2000 年问题。</p> <p><code>SQL86</code>大概只有几十页，<code>SQL92</code>正文大约有 500 页，而 <code>SQL99</code> 则超过了 1000 页。可以看出，从 <code>SQL99</code> 开始，<code>SQL</code> 标准的个头就非常庞大了，内容包罗万象，可以说已经没有人能够掌握标准的所有内容了。</p> <p>以 <code>SQL:2003</code> 为例，它包括以下 9 个部分（中间编号空缺是曾经被占用，之后被废弃的标准造成的）</p> <p>最新的标准是 SQL:2023 ，网上有一份的<a href=https://sql-99.readthedocs.io/en/latest/ >SQL-99</a>规范</p> <p>SQL 语言有以下几个部分：</p> <ul> <li>数据定义语言 DDL：主要是表定义，表删除，表结构修改等语句。常用的语句关键字有 CREATE、DROP、ALTER 等。</li> <li>数据操纵语言 DML：主要是数据库表的增删改语句。常用的语句关键字有 INSERT、UPDATE、DELETE 等。</li> <li>数据查询语言 DQL：主要是对数据进行查询操作。常用关键字有 SELECT、FROM、WHERE 等。</li> <li> <p>数据控制语言 DCL：主要是用来设置/更改数据库用户权限。常用关键字有 GRANT、REVOKE 等。</p> </li> <li> <p>完整性：SQL DDL 中包括数据定义的完整性的约束。是指数据的一致性和有效性.</p> </li> <li>视图定义：SQL DDL 包含视图定义的命令</li> <li>事务控制：SQL</li> <li>嵌入式和动态 SQL</li> <li>授权</li> </ul> <p><code>SQL:2023</code>最新标准包含 11 个部分的内容，具体如下：</p> <ul> <li>ISO/IEC 9075-1 信息技术 – 数据库语言 – SQL – 第 1 部分：框架（SQL/框架）</li> <li>ISO/IEC 9075-2 信息技术 – 数据库语言 – SQL – 第 2 部分：基本原则（SQL/基本原则）</li> <li>ISO/IEC 9075-3 信息技术 – 数据库语言 – SQL – 第 3 部分：调用级接口（SQL/CLI）</li> <li>ISO/IEC 9075-4 信息技术 – 数据库语言 – SQL – 第 4 部分：持久存储模块（SQL/PSM）</li> <li>ISO/IEC 9075-9 信息技术 – 数据库语言 – SQL – 第 9 部分：外部数据管理（SQL/MED）</li> <li>ISO/IEC 9075-10 信息技术 – 数据库语言 – SQL – 第 10 部分：对象语言绑定（SQL/OLB）</li> <li>ISO/IEC 9075-11 信息技术 – 数据库语言 – SQL – 第 11 部分：信息与定义概要（SQL/Schemata）</li> <li>ISO/IEC 9075-13 信息技术 – 数据库语言 – SQL – 第 13 部分：使用 Java 编程语言的 SQL 程序与类型（SQL/JRT）</li> <li>ISO/IEC 9075-14 信息技术 – 数据库语言 – SQL – 第 14 部分：XML 相关规范（SQL/XML）</li> <li>ISO/IEC 9075-15 信息技术 – 数据库语言 – SQL – 第 15 部分：多维数组（SQL/MDA）</li> <li>ISO/IEC 9075-16 信息技术 – 数据库语言 – SQL – 第 16 部分：属性图查询（SQL/PGQ）</li> </ul> <p>相比于其他语言，SQL 的"半衰期"可以说是非常长了。<code>SQL</code>有两个重要的标准，分别是<code>SQL92</code>和<code>SQL99</code>，它们分别代表了 92 年和 99 年颁布的 SQL 标准，我们今天使用的 SQL 语言依然遵循这些标准。 要知道 92 年是 Windows3.1 发布的时间，如今还有多少人记得它，但如果你从事数据分析，或者和数据相关的工作，依然会用到 SQL 语言。 作为技术和互联网行业的从业人员（一个学习 IT 的人来说），我们总是希望能找到一个通用性强，变化相对少，上手相对容易的语言，SQL 正是为数不多的，可以满足这三个条件的语言。 入门 SQL 并不难。SQL 更像是一门英语，有一些简单的英语单词，当你使用它的时候，就好像在用英语与数据库进行对话。</p> <h2 id=sql_2>SQL 标准的符合性<a class=headerlink href=#sql_2 title="Permanent link">&para;</a></h2> <p>提及标准，大家容易想到的一个问题就是产品对标准的遵循程度，也就是标准的符合性到底如何，因为它会影响代码在不同系统之间迁移的难度。很遗憾的是，SQL 标准因为定义过于宽泛等技术和非技术原因，不同产品对标准的符合程度存在很大的差异。大到功能特性，小到语法语义的细节，在不同产品之间都存在很多差异，造成实际的应用迁移远比 C/C++ 程序的迁移要复杂很多。因此，尽管很多产品都号称自己符合 SQL 标准，并不意味着应用可以容易的在它们之间切换。除了 Oracle、DB2 等经典的商业产品，以及 PostgreSQL、MySQL 等开源产品总体上对 SQL 标准的符合程度较高以外，很多产品提到的 SQL 标准，涉及的内容其实是 SQL92 里头最基本或最核心的一部分（属于入门级的范畴。SQL92 本身是分级的，包括入门级、过渡级、中间级和完全级）。</p> <p>各国通常会按照 ISO 标准和 ANSI 标准（这两个机构的很多标准是差不多等同的）制定自己的国家标准。中国是 ISO 标准委员会的成员国，也经常翻译一些国际标准对应的中文版。标准为了避免采用具体产品的术语，往往会抽象出很多名词，从而增加了阅读和理解的难度，翻译成中文之后更容易词不达意。对于数据库系统实现者和用户而言，很多时候还不如直接读英文版本为好。</p> <p><a href=../../assets/GB%20T%2012991.1-2008%20%E4%BF%A1%E6%81%AF%E6%8A%80%E6%9C%AF%20%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%AD%E8%A8%80%20SQL%20%E7%AC%AC1%E9%83%A8%E5%88%86_%20%E6%A1%86%E6%9E%B6.pdf>《信息技术 数据库语言 SQL 第 1 部分：框架》</a></p> <p>《信息技术 数据库语言 SQL 第 2 部分：基础》</p> <p><a href=../../assets/GB-T20273-2019%E3%80%8A%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF%E8%A6%81%E6%B1%82%E3%80%8B.pdf>《信息安全技术 数据库管理系统安全技术要求》</a></p> <p>为了验证具体的产品对标准的遵从程度，NIST 还曾经专门发起了一个项目，来做标准符合程度的测试集合。不过，SQL 标准包含的内容实在太多了，而且有很多特性对新的 SQL 产品而言也越来越不重要了。从 SQL99 之后，标准中定义就不符合程度的再分级，而是改成了核心兼容性和特性兼容性；也没有机构来推出权威的 SQL 标准符合程度的测试认证了。开源的 MySQL 曾经在 6.0 的开发过程中试图大幅度改善对 SQL 标准的符合程度，不过后来似乎不了了之了。国产数据库作为数据库领域的后来者，曾经对标准的符合程度非常重视，还组织了专门的机构来做产品的标准符合性测试。在数据库百科全书中也有很多有关标准的章节。</p> <p><code>SQL</code>，或结构化查询语言，是一种用于管理和操作数据库中数据的强大工具。世界各地的企业、组织和个人都使用它来组织、分析和理解大量信息。</p> <p><code>SQL</code>最强大的方面之一是它能够以多种方式过滤、排序和聚合数据。这使它成为一个非常通用的工具，可用于从生成报告到分析客户行为的广泛任务。</p> <p>要理解为什么以及如何使用<code>SQL</code>，考虑一个真实的示例会很有帮助。假设您经营一家小型在线商店，并拥有一个包含有关您的客户、产品和订单的信息的数据库。您想要分析您的销售数据以更好地了解哪些产品卖得好，哪些产品卖得不好。</p> <p>一种方法是手动筛选数据库中的数据，寻找模式和趋势。但随着您的业务增长和您必须管理的数据量增加，这变得越来越耗时且容易出错。</p> <p>这就是<code>SQL</code>的用武之地。通过使用<code>SQL</code>，您可以通过多种方式快速轻松地过滤、排序和聚合数据。例如，您可以使用<code>SQL</code>找出上个月收到的订单数量，或者生成一份报告，显示哪些产品的销售额最高。</p> <p>SQL 与其他类型的编程语言之间存在一些关键差异。其中最重要的一点是 SQL 是一种声明性语言，这意味着您告诉它您希望它做什么（例如“查找过去一个月的所有订单”），而不是告诉它怎么做（例如“遍历”每个订单并检查日期”）。这使得 SQL 比其他编程语言更易于使用和理解。</p> <p>另一个关键区别是 SQL 是专门为与关系数据库一起工作而设计的。这意味着它针对连接表、过滤数据和聚合数据等任务进行了优化。</p> <p>每个关系型数据库都在不同程度上实现 SQL 标准，但是也有自己实现的标准，但是大部分都是基本一致，但是每个数据库都有自己的高级特性和实现标准。</p> <p>当引入关系模型时，关系模型包含了一种查询数据的新方法：SQL，它是一种 <code>声明式</code> 的数据查询语言。</p> <p>在声明式查询语言（如 SQL 或关系代数）中，你只需指定所需数据的模式 - 结果必须符合哪些条件，以及如何将数据转换（例如，排序，分组和集合） - 但不关注如何实现这一目标。数据库系统的查询优化器决定使用哪些索引和哪些连接方法，以及以何种顺序执行查询的各个部分。</p> <p>声明式查询语言是迷人的，因为它通常比命令式 API 更加简洁和容易。但更重要的是，它还隐藏了数据库引擎的实现细节，这使得数据库系统可以在无需对查询做任何更改的情况下进行性能提升。</p> <p>Oracle，MySQL，MicroSoft SQL server, PostgreSQL 是不同组织对关系型数据库的具体实现产品，他们都部分实现了 SQL 标准。</p> <h2 id=sql_3>SQL 开发规范<a class=headerlink href=#sql_3 title="Permanent link">&para;</a></h2> <p>对于很多的编程语言来说，大家总有个人的或者通用的代码风格，其实这对于 SQL 同样也不例外。好的代码风格可以提高代码的可读性，降低维护成本。有些编程语言(如 Golang)内置了格式化代码命令 gofmt，可以非常方便的格式化代码。对于代码的风格，大家的看法总是不尽相同，每个人可能都有自己的风格，如何缩进，怎么变量命名等等。当一种代码规范形成一种共识后，我想这才能最大程度上提高代码的可读性、可维护性。</p> <p>在广泛的数据分析师和工程师团队中工作时，您是否曾为不同的 SQL 风格而苦苦挣扎。上/下关键字、前导/尾随逗号、缩进、别名规则等。</p> <p>随着模型数量的增长，拥有一致的风格变得有益，以简化代码审查、新成员的入职等。SQLfluff 来拯救，它是 SQL 文件的 CLI linter。它可以突出显示并经常修复样式违规。</p> <p>dbt 是另一个令人惊叹的工具，可以简化数据建模、跟踪模型之间的依赖关系并减少样板代码的数量。</p> <p><a href=https://about.gitlab.com/handbook/business-technology/data-team/platform/sql-style-guide/ >gitlab-sql-style-guide</a></p> <ul> <li> <p>优点： 1）引入混合大小写来将关键字与列名和表名分开，例如，将 SELECT 写成大写，将 Employee 写成大写，但如果不一致，例如 SELECT 是大写字母，而 from 是小写字母，使用这种风格没有任何好处。</p> </li> <li> <p>缺点：</p> </li> <li> <p>混合大小写</p> </li> <li>整个查询写在一行上，一旦表和列的数量增加，就会变得不可读</li> <li>添加新条件或在没有现有条件的情况下运行没有灵活性</li> </ul> <p>Read more: <a href=https://javarevisited.blogspot.com/2017/01/a-better-way-to-write-sql-queries.html#ixzz8R4AscrEA>https://javarevisited.blogspot.com/2017/01/a-better-way-to-write-sql-queries.html#ixzz8R4AscrEA</a></p> <p>改进： 1）查询分为多行，使其更具可读性</p> <ul> <li>问题</li> </ul> <p>1）混合大小写</p> <p>2）where 子句上的所有条件都在同一行，这意味着通过注释排除它们并不那么容易。</p> <p><a href=https://javarevisited.blogspot.com/2017/01/a-better-way-to-write-sql-queries.html#ixzz8R4AxGGpB>Read more</a></p> <ol> <li> <p>将 SQL 查询分成多行使它们更具可读性</p> </li> <li> <p>使用适当的缩进可以轻松发现数据源，即表和联接</p> </li> <li> <p>将条件放在单独的行上允许您通过注释其中一个条件来运行查询例如</p> </li> </ol> <div class=highlight><pre><span></span><code><span class=k>select</span><span class=w> </span><span class=n>e</span><span class=p>.</span><span class=n>emp_id</span><span class=p>,</span><span class=w> </span><span class=n>e</span><span class=p>.</span><span class=n>emp_name</span><span class=p>,</span><span class=w> </span><span class=n>d</span><span class=p>.</span><span class=n>dept_name</span>
<span class=w> </span><span class=k>from</span><span class=w> </span><span class=n>Employee</span><span class=w> </span><span class=n>e</span>
<span class=w> </span><span class=k>inner</span><span class=w> </span><span class=k>join</span><span class=w> </span><span class=n>Department</span><span class=w> </span><span class=n>d</span><span class=w> </span><span class=k>on</span><span class=w> </span><span class=n>e</span><span class=p>.</span><span class=n>dept_id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>d</span><span class=p>.</span><span class=n>dept_id</span>
<span class=w> </span><span class=k>where</span><span class=w> </span><span class=n>d</span><span class=p>.</span><span class=n>dept_name</span><span class=w> </span><span class=o>=</span><span class=w>  </span><span class=s1>&#39;finance&#39;</span>
<span class=c1>-- and e.emp_name like &#39;%A%&#39;;</span>
</code></pre></div> <p>顺便说一句，如果您喜欢关键字大写，您也可以编写相同的 SQL 查询，如下所示，规则相同，但只是关键字大写。</p> <p><a href=https://javarevisited.blogspot.com/2017/01/a-better-way-to-write-sql-queries.html#ixzz8R4B1j03j>Read more</a></p> <h3 id=_1>团队对齐<a class=headerlink href=#_1 title="Permanent link">&para;</a></h3> <p>首先，您需要与团队交谈并解释为什么拥有某些风格规则很重要。</p> <p>这一步非常重要，因为如果没有清楚地了解为什么需要 PR，没有人会乐于看到 PR 停留在审查中。</p> <p>这次谈话的一个好的结果是有一套你同意遵守的初始规则。此外，如果它很大和/或由多个 dbt 项目组成，您可能只想为项目的某个区域推出它。</p> <h3 id=_2>集成到开发工作流程中<a class=headerlink href=#_2 title="Permanent link">&para;</a></h3> <p>下一步是将 SQLfluff 集成到开发工作流中。实现它的最简单方法是使用预提交挂钩。</p> <p>如果您已经在使用它们，只需添加几个新的钩子会容易得多 sqlfliff fix，sqlfluff lint.</p> <p>否则，您可能需要更多时间来采用预提交挂钩。值得一提的是，尽管强烈推荐此步骤，但为了使开发工作流程更加顺畅，此步骤可能是可选的。</p> <h3 id=cicd>集成到 CI/CD 中<a class=headerlink href=#cicd title="Permanent link">&para;</a></h3> <p>下一步是通过将 SQLfluff 集成到 CI/CD 中来强制执行规则。</p> <p>它可以以软或硬的方式完成。</p> <p>在第一种情况下，它应该只发出警告，而不是阻止 PR 被合并。</p> <p>在第二种情况下，PR 应该</p> <h2 id=sql_4>SQL 语法和注释<a class=headerlink href=#sql_4 title="Permanent link">&para;</a></h2> <div class=highlight><pre><span></span><code><span class=c1>-- MySQL有几种注释语法</span>

<span class=c1>-- 1、单行注释符&quot;--&quot;，--注释符后需要加一个空格，注释才能生效</span>
<span class=cm>/* 2、用C语言风格的注释注释语句块 */</span>
<span class=c1>-- 3、单行注释符&quot;#&quot;，# 注释符后直接加注释内容</span>
<span class=k>SELECT</span><span class=w> </span><span class=mi>1</span><span class=o>+</span><span class=mi>1</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=n>dual</span><span class=p>;</span><span class=w>     </span><span class=c1>-- 注释文字</span>

<span class=k>SELECT</span><span class=w> </span><span class=mi>1</span><span class=o>+</span><span class=mi>1</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=n>dual</span><span class=p>;</span><span class=w>    </span><span class=o>#</span><span class=w> </span><span class=err>注释文字，这个</span><span class=o>#</span><span class=err>号在</span><span class=n>MySQL中也是注释</span>
<span class=cm>/* 标准SQL注释采用了C语言中的注释语法, MySQL同样支持这种语法  */</span>
<span class=c1>-- 下面这段注释表示：当接收SQL的Server版本大于4.0.001时，后面的注释文字就可以被识别。</span>
<span class=k>SELECT</span><span class=w> </span><span class=cm>/*!40001 SQL_NO_CACHE */</span><span class=w>  </span><span class=k>count</span><span class=p>(</span><span class=o>*</span><span class=p>)</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>db_test</span><span class=p>.</span><span class=n>test_table</span>
<span class=k>SELECT</span><span class=w> </span><span class=n>SQL_NO_CACHE</span><span class=w>  </span><span class=k>count</span><span class=p>(</span><span class=o>*</span><span class=p>)</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>db_test</span><span class=p>.</span><span class=n>test_table</span>
</code></pre></div> <h2 id=_3>字符串字面量<a class=headerlink href=#_3 title="Permanent link">&para;</a></h2> <p>在标准<code>SQL</code>中，字符串使用的是单引号括起来的。如果字符串本身也包括单引号，则使用两个单引号（注意。不是双引号，字符串中的双引号不需要另外转义）。</p> <p>但在其它的数据库中可能存在对 <code>SQL</code> 的扩展，比如在 <code>MySQL</code> 中允许使用单引号和双引号两种。</p> <p>MySQL 可以使用单引号（'）或者双引号（"）表示值，但是 PG 只能用单引号（'）表示值，PG 的双引号（"）是表示系统标识符的，比如表名或者字段名。</p> <p>MySQL 可以使用反单引号（`）表示系统标识符，比如表名、字段名，PG 也是不支持的。</p> <h2 id=_4>数据库的创建与删除<a class=headerlink href=#_4 title="Permanent link">&para;</a></h2> <div class=highlight><pre><span></span><code><span class=c1>-- 建库，在Unix中，库名是严格区分大小的，强烈建议库名由小写字母和下划线组成</span>
<span class=k>CREATE</span><span class=w> </span><span class=k>DATABASE</span><span class=w> </span><span class=o>`</span><span class=n>database_test</span><span class=o>`</span><span class=w>  </span><span class=k>IF</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>EXISTS</span><span class=w> </span><span class=nb>CHARACTER</span><span class=w> </span><span class=k>SET</span><span class=w> </span><span class=s1>&#39;utf8mb4&#39;</span><span class=w> </span><span class=k>COLLATE</span><span class=w> </span><span class=s1>&#39;utf8mb4_0900_ai_ci&#39;</span><span class=p>;</span>

<span class=c1>-- 设置某个库只读</span>
<span class=c1>-- MySQL 8.0.22中引入的READ ONLY选项控制是否允许修改数据库和其中的对象。允许的值为DEFAULT或0（非只读）和1（只读）。</span>
<span class=c1>-- 此选项对于数据库迁移非常有用，因为启用了只读功能的数据库可以迁移到另一个MySQL实例，而不必担心在操作过程中数据库可能会发生更改。</span>

<span class=k>ALTER</span><span class=w> </span><span class=k>DATABASE</span><span class=w>  </span><span class=o>`</span><span class=n>database_test</span><span class=o>`</span><span class=w>   </span><span class=k>READ</span><span class=w> </span><span class=k>ONLY</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=p>;</span>


<span class=c1>-- 删库</span>
<span class=k>DROP</span><span class=w> </span><span class=k>DATABASE</span><span class=w> </span><span class=n>database_test</span><span class=p>;</span>


<span class=c1>-- 修改数据库</span>
<span class=c1>-- 注意：在 MySQL 中，数据库创建之后库名是无法直接修改的。能改的只有字符集等属性。</span>
</code></pre></div> <h3 id=_5>表的创建<a class=headerlink href=#_5 title="Permanent link">&para;</a></h3> <div class=highlight><pre><span></span><code><span class=c1>-- 文件大小写，在不同的操作系统中的文件系统，是不一样的。</span>
<span class=c1>-- Linux操作系统，严格区分大小写，Test 和 TEST 是两个不同的文件或文件夹。</span>
<span class=c1>-- Windows操作系统，不区分大小写，无法同时创建 Test 和 TEST 两个同名的文件或文件夹。</span>

<span class=c1>-- 对于MySQL数据库和表，要在操作系统创建与库名和表名相同的文件夹或文件。</span>

<span class=c1>-- lower_case_file_system 是一个只读参数，无法被修改，这个参数是用来告诉你在当前的系统平台下，是否对文件名大小写敏感。</span>

<span class=c1>-- lower_case_table_names是一个MySQL可配置的参数，它的取值如下：</span>

<span class=c1>-- 0 大小写敏感。（Unix，Linux默认） 创建的库表将原样保存在磁盘上。</span>
<span class=c1>-- 如 create database TeSt ; 将会创建一个TeSt的目录，create table AbCCC …将会原样生成AbCCC.frm。 SQL语句也会原样解析。</span>

<span class=c1>-- 1 大小写不敏感。（Windows默认） 创建库表时，MySQL将所有的库表文件转换成小写存储在磁盘上。SQL语句同样会将库表名转换成小写。</span>
<span class=c1>-- 如需要查询以前创建的Testtable（生成Testtable.frm文件），即便执行select * from Testtable，也会被转换成select * from testtable，致使报错表不存在。</span>

<span class=c1>-- 在MySQL中。列名，索引名，存储过程、函数及事件名称在任何操作系统下都不区分大小写，列别名也不区分大小写。</span>
<span class=c1>-- 如果你定义字段为 UserName，查询时写 username、USERNAME 或 uSeRnAmE 都能正常返回结果。</span>
<span class=c1>-- 也就意味着，在一张表内。不能同时定义 UserName 和 username 这样的两个字段。</span>

<span class=c1>-- 最佳实践：建议将lower_case_table_names值统一设置为0，在代码中对大小写进行严格区分</span>
<span class=c1>-- 库名，表名，字段名，统一由小写英文字符和数字组成。</span>

<span class=c1>-- 在各家公司，都存在各种设计规范：</span>
<span class=c1>-- https://support.huaweicloud.com/bestpractice-rds/rds_02_0013.html</span>


<span class=c1>-- lower_case_table_names 参数是全局系统变量，不可以动态修改，想要变动时，必须写入配置文件然后重启数据库生效。</span>
<span class=c1>-- 如果你的数据库该参数一开始为 0 ，现在想要改为 1 ，这种情况要格外注意，因为若原实例中存在大写的库表，则改为 1 重启后，这些库表将会不能访问。</span>
<span class=c1>-- 如果需要将 lower_case_table_names 参数从 0 改成 1 ，可以按照下面步骤修改：</span>

<span class=c1>-- 1、首先核实下实例中是否存在大写的库及表，若不存在大写的库表，则可以直接修改配置文件然后重启。若存在大写的库表，则需要先将大写的库表转化为小写，然后才可以修改配置文件重启。</span>

<span class=c1>-- 2、通过 mysqldump 备份相关库，备份完成后删除对应库，之后修改配置文件重启，最后将备份文件重新导入。此方法用时较长，一般很少用到。</span>

<span class=c1>-- 3、 通过 rename 语句修改</span>

<span class=c1>-- 将大写表重命名为小写表</span>
<span class=k>rename</span><span class=w> </span><span class=k>table</span><span class=w> </span><span class=n>TEST</span><span class=w> </span><span class=k>to</span><span class=w> </span><span class=n>test</span><span class=p>;</span>

<span class=c1>-- 若存在大写库 则需要先创建小写库 然后将大写库里面的表转移到小写库</span>
<span class=k>rename</span><span class=w> </span><span class=k>table</span><span class=w> </span><span class=n>TESTDB</span><span class=p>.</span><span class=n>test_tb</span><span class=w> </span><span class=k>to</span><span class=w> </span><span class=n>testdb</span><span class=p>.</span><span class=n>test_tb</span><span class=p>;</span>

<span class=c1>-- 分享两条可能用到的SQL</span>
<span class=c1>-- 查询实例中有大写字母的表</span>
<span class=k>SELECT</span>
<span class=w> </span><span class=n>TABLE_SCHEMA</span><span class=p>,</span>
<span class=w> </span><span class=k>TABLE_NAME</span>
<span class=k>FROM</span>
<span class=w> </span><span class=n>information_schema</span><span class=p>.</span><span class=o>`</span><span class=n>TABLES</span><span class=o>`</span>
<span class=k>WHERE</span>
<span class=w> </span><span class=n>TABLE_SCHEMA</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>IN</span><span class=w> </span><span class=p>(</span><span class=w> </span><span class=s1>&#39;information_schema&#39;</span><span class=p>,</span><span class=w> </span><span class=s1>&#39;sys&#39;</span><span class=p>,</span><span class=w> </span><span class=s1>&#39;mysql&#39;</span><span class=p>,</span><span class=w> </span><span class=s1>&#39;performance_schema&#39;</span><span class=w> </span><span class=p>)</span>
<span class=w> </span><span class=k>AND</span><span class=w> </span><span class=n>table_type</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s1>&#39;BASE TABLE&#39;</span>
<span class=w> </span><span class=k>AND</span><span class=w> </span><span class=k>TABLE_NAME</span><span class=w> </span><span class=n>REGEXP</span><span class=w> </span><span class=nb>BINARY</span><span class=w> </span><span class=s1>&#39;[A-Z]&#39;</span>


<span class=c1>-- 拼接SQL 将大写库中的表转移到小写库</span>
<span class=k>SELECT</span>
<span class=w> </span><span class=n>CONCAT</span><span class=p>(</span><span class=w> </span><span class=s1>&#39;rename table TESTDB.&#39;</span><span class=p>,</span><span class=w> </span><span class=k>TABLE_NAME</span><span class=p>,</span><span class=w> </span><span class=s1>&#39; to testdb.&#39;</span><span class=p>,</span><span class=w> </span><span class=k>TABLE_NAME</span><span class=p>,</span><span class=w> </span><span class=s1>&#39;;&#39;</span><span class=w> </span><span class=p>)</span>
<span class=k>FROM</span>
<span class=w> </span><span class=n>information_schema</span><span class=p>.</span><span class=n>TABLES</span>
<span class=k>WHERE</span>
<span class=w> </span><span class=n>TABLE_SCHEMA</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s1>&#39;TESTDB&#39;</span><span class=p>;</span>


<span class=c1>-- 建表</span>
<span class=c1>-- 表名，字段名，字段类型，字段的约束，字段的字符集，存储引擎等</span>
<span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=o>`</span><span class=n>cwd_group</span><span class=o>`</span><span class=w> </span><span class=p>(</span>
<span class=w>  </span><span class=o>`</span><span class=n>id</span><span class=o>`</span><span class=w> </span><span class=nb>bigint</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=p>,</span>
<span class=w>  </span><span class=o>`</span><span class=n>group_name</span><span class=o>`</span><span class=w> </span><span class=nb>varchar</span><span class=p>(</span><span class=mi>255</span><span class=p>)</span><span class=w> </span><span class=k>COLLATE</span><span class=w> </span><span class=n>utf8_bin</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=p>,</span>
<span class=w>  </span><span class=o>`</span><span class=n>lower_group_name</span><span class=o>`</span><span class=w> </span><span class=nb>varchar</span><span class=p>(</span><span class=mi>255</span><span class=p>)</span><span class=w> </span><span class=k>COLLATE</span><span class=w> </span><span class=n>utf8_bin</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=p>,</span>
<span class=w>  </span><span class=o>`</span><span class=n>active</span><span class=o>`</span><span class=w> </span><span class=nb>char</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span><span class=w> </span><span class=k>COLLATE</span><span class=w> </span><span class=n>utf8_bin</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=p>,</span>
<span class=w>  </span><span class=o>`</span><span class=k>local</span><span class=o>`</span><span class=w> </span><span class=nb>char</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span><span class=w> </span><span class=k>COLLATE</span><span class=w> </span><span class=n>utf8_bin</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=p>,</span>
<span class=w>  </span><span class=o>`</span><span class=n>created_date</span><span class=o>`</span><span class=w> </span><span class=n>datetime</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=p>,</span>
<span class=w>  </span><span class=o>`</span><span class=n>updated_date</span><span class=o>`</span><span class=w> </span><span class=n>datetime</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=p>,</span>
<span class=w>  </span><span class=o>`</span><span class=n>description</span><span class=o>`</span><span class=w> </span><span class=nb>varchar</span><span class=p>(</span><span class=mi>255</span><span class=p>)</span><span class=w> </span><span class=k>COLLATE</span><span class=w> </span><span class=n>utf8_bin</span><span class=w> </span><span class=k>DEFAULT</span><span class=w> </span><span class=k>NULL</span><span class=p>,</span>
<span class=w>  </span><span class=o>`</span><span class=n>group_type</span><span class=o>`</span><span class=w> </span><span class=nb>varchar</span><span class=p>(</span><span class=mi>32</span><span class=p>)</span><span class=w> </span><span class=k>COLLATE</span><span class=w> </span><span class=n>utf8_bin</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=p>,</span>
<span class=w>  </span><span class=o>`</span><span class=n>directory_id</span><span class=o>`</span><span class=w> </span><span class=nb>bigint</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=p>,</span>
<span class=w>  </span><span class=k>PRIMARY</span><span class=w> </span><span class=k>KEY</span><span class=w> </span><span class=p>(</span><span class=o>`</span><span class=n>id</span><span class=o>`</span><span class=p>),</span>
<span class=w>  </span><span class=k>UNIQUE</span><span class=w> </span><span class=k>KEY</span><span class=w> </span><span class=o>`</span><span class=n>cwd_group_name_dir_id</span><span class=o>`</span><span class=w> </span><span class=p>(</span><span class=o>`</span><span class=n>lower_group_name</span><span class=o>`</span><span class=p>,</span><span class=o>`</span><span class=n>directory_id</span><span class=o>`</span><span class=p>),</span>
<span class=w>  </span><span class=k>KEY</span><span class=w> </span><span class=o>`</span><span class=n>idx_group_active</span><span class=o>`</span><span class=w> </span><span class=p>(</span><span class=o>`</span><span class=n>active</span><span class=o>`</span><span class=p>,</span><span class=o>`</span><span class=n>directory_id</span><span class=o>`</span><span class=p>),</span>
<span class=w>  </span><span class=k>KEY</span><span class=w> </span><span class=o>`</span><span class=n>idx_group_dir_id</span><span class=o>`</span><span class=w> </span><span class=p>(</span><span class=o>`</span><span class=n>directory_id</span><span class=o>`</span><span class=p>)</span>
<span class=p>)</span><span class=w> </span><span class=n>ENGINE</span><span class=o>=</span><span class=n>InnoDB</span><span class=w> </span><span class=k>DEFAULT</span><span class=w> </span><span class=n>CHARSET</span><span class=o>=</span><span class=n>utf8mb4</span><span class=w> </span><span class=k>COLLATE</span><span class=o>=</span><span class=n>utf8mb4_0900_ai_ci</span><span class=p>;</span>


<span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>Product</span><span class=w> </span><span class=p>(</span>
<span class=w>    </span><span class=n>product_id</span><span class=w>        </span><span class=nb>char</span><span class=p>(</span><span class=mi>4</span><span class=p>)</span><span class=w>         </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=p>,</span>
<span class=w>    </span><span class=n>product_name</span><span class=w>      </span><span class=nb>varchar</span><span class=p>(</span><span class=mi>100</span><span class=p>)</span><span class=w>    </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=p>,</span>
<span class=w>    </span><span class=n>product_type</span><span class=w>      </span><span class=nb>varchar</span><span class=p>(</span><span class=mi>32</span><span class=p>)</span><span class=w>     </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=p>,</span>
<span class=w>    </span><span class=n>sale_price</span><span class=w>        </span><span class=nb>integer</span><span class=w>                 </span><span class=p>,</span>
<span class=w>    </span><span class=n>purchase_price</span><span class=w>    </span><span class=nb>integer</span><span class=w>                 </span><span class=p>,</span>
<span class=w>    </span><span class=n>regist_date</span><span class=w>       </span><span class=nb>date</span><span class=w>                    </span><span class=p>,</span>
<span class=w>    </span><span class=k>PRIMARY</span><span class=w> </span><span class=k>KEY</span><span class=w> </span><span class=p>(</span><span class=o>`</span><span class=n>product_id</span><span class=o>`</span><span class=p>)</span>

<span class=p>)</span><span class=w> </span><span class=n>ENGINE</span><span class=o>=</span><span class=n>InnoDB</span><span class=w> </span><span class=k>DEFAULT</span><span class=w> </span><span class=n>CHARSET</span><span class=o>=</span><span class=n>utf8mb4</span><span class=w> </span><span class=k>COLLATE</span><span class=o>=</span><span class=n>utf8mb4_0900_ai_ci</span><span class=p>;</span>


<span class=c1>-- 在demo库下建表ChineseCharInfo，有两列，其中ID为自增主键</span>
<span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>demo</span><span class=p>.</span><span class=n>ChineseCharInfo</span>
<span class=p>(</span>
<span class=w>    </span><span class=n>ID</span><span class=w>        </span><span class=nb>int</span><span class=w>              </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=w>     </span><span class=n>auto_increment</span><span class=p>,</span>
<span class=w>    </span><span class=n>Hanzi</span><span class=w>     </span><span class=nb>varchar</span><span class=p>(</span><span class=mi>10</span><span class=p>)</span><span class=w>      </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=p>,</span>
<span class=w>    </span><span class=k>primary</span><span class=w>   </span><span class=k>key</span><span class=w> </span><span class=p>(</span><span class=n>ID</span><span class=p>)</span>
<span class=p>)</span>
<span class=n>ENGINE</span><span class=o>=</span><span class=n>InnoDB</span><span class=w> </span><span class=n>auto_increment</span><span class=o>=</span><span class=mi>1</span><span class=w> </span><span class=k>DEFAULT</span><span class=w> </span><span class=n>CHARSET</span><span class=o>=</span><span class=n>utf8</span><span class=w> </span><span class=k>COLLATE</span><span class=o>=</span><span class=n>utf8_general_ci</span><span class=p>;</span>


<span class=c1>-- 在demo库下建表ChinesePinyinInfo</span>
<span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>demo</span><span class=p>.</span><span class=n>ChinesePinyinInfo</span>
<span class=p>(</span>
<span class=w>    </span><span class=n>ID</span><span class=w>         </span><span class=nb>INT</span><span class=w>                  </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=w>     </span><span class=n>AUTO_INCREMENT</span><span class=p>,</span>
<span class=w>    </span><span class=n>CharID</span><span class=w>     </span><span class=nb>INT</span><span class=w>                  </span><span class=k>NULL</span><span class=p>,</span>
<span class=w>    </span><span class=n>Pinyin</span><span class=w>     </span><span class=nb>VARCHAR</span><span class=p>(</span><span class=mi>10</span><span class=p>)</span><span class=w>          </span><span class=k>NULL</span><span class=p>,</span>
<span class=w>    </span><span class=n>Tone</span><span class=w>       </span><span class=n>TINYINT</span><span class=w> </span><span class=n>UNSIGNED</span><span class=w>     </span><span class=k>NULL</span><span class=p>,</span>

<span class=w>    </span><span class=k>primary</span><span class=w> </span><span class=k>key</span><span class=w> </span><span class=p>(</span><span class=n>ID</span><span class=p>),</span>
<span class=w>    </span><span class=c1>-- 方式一：不指定外键名称，数据库自动生成</span>
<span class=w>    </span><span class=k>FOREIGN</span><span class=w> </span><span class=k>KEY</span><span class=w> </span><span class=p>(</span><span class=n>CharID</span><span class=p>)</span><span class=w> </span><span class=k>REFERENCES</span><span class=w> </span><span class=n>ChineseCharInfo</span><span class=p>(</span><span class=n>ID</span><span class=p>)</span><span class=w> </span><span class=k>ON</span><span class=w> </span><span class=k>DELETE</span><span class=w> </span><span class=k>CASCADE</span><span class=w> </span><span class=k>ON</span><span class=w> </span><span class=k>UPDATE</span><span class=w> </span><span class=k>CASCADE</span>

<span class=w>    </span><span class=c1>-- 方式二：指定外键名称为(FK_Name)</span>
<span class=w>    </span><span class=c1>-- constraint FK_Name foreign key (CharID) references ChineseCharInfo(ID) on delete cascade on update cascade</span>
<span class=p>)</span>
<span class=n>ENGINE</span><span class=o>=</span><span class=n>innodb</span><span class=w> </span><span class=n>AUTO_INCREMENT</span><span class=o>=</span><span class=mi>1</span><span class=w> </span><span class=k>DEFAULT</span><span class=w> </span><span class=n>CHARSET</span><span class=o>=</span><span class=n>utf8</span><span class=w> </span><span class=k>COLLATE</span><span class=o>=</span><span class=n>utf8_general_ci</span><span class=p>;</span>

<span class=c1>-- 创建一个与原表结构一样的表</span>
<span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>demo</span><span class=p>.</span><span class=n>ChineseCharInfobak</span><span class=w> </span><span class=k>LIKE</span><span class=w> </span><span class=n>demo</span><span class=p>.</span><span class=n>ChineseCharInfo</span>
</code></pre></div> <h3 id=_6>生成列<a class=headerlink href=#_6 title="Permanent link">&para;</a></h3> <p><strong>在 SQL 中，生成列（Generated Column）是指由表中其他字段计算得到的列，因此也称为计算列（Computed Column）</strong>。</p> <p>在 SQL 建表语句支持指定的生成列，列的取值由其定义计算出来的。有如下特点：</p> <ol> <li><strong>虚拟列字段只读，不支持 INSRET 和 UPDATE。</strong></li> <li><code>virtual</code>和<code>stored</code>之间不能相互转换，必要时需要删除重建。</li> <li>只能引用本表的非<code>generated column</code>字段，不可以引用其它表的字段。</li> <li>支持创建索引。</li> <li>针对<code>virtual</code>类型的衍生列索引，在<code>insert</code>和<code>update</code>操作时会消耗额外的写负载，因为更新衍生列索引时需要将衍生列值计算出来，并物化到索引里。但即使这样，<code>virtual</code>类型也比<code>stored</code>类型的衍生列好，有索引就避免了每次读取数据行时都需要进行一次衍生计算，同时<code>stored</code>类型衍生列实际存储数据，使得聚簇索引更大更占空间。</li> </ol> <p>MySQL 5.7 引入了生成列，支持<code>虚拟</code>和<code>存储</code>两种类型的生成列。</p> <ul> <li>Virtual（虚拟）：这个类型的列会在读取表记录时自动计算此列的结果并返回。默认创建的是<code>VIRTUAL</code>生成列。</li> <li>Stored（存储）：这个类型的列会在表中插入一条数据时自动计算对应的值，并插入到这个列中，那么这个列会作为一个常规列存在表中。</li> </ul> <p>针对<code>Virtual</code>类型的衍生列索引，在<code>insert</code>和<code>update</code>操作时会消耗额外的写负载，因为更新衍生列索引时需要将衍生列值计算出来，并物化到索引里。但即使这样，<code>virtual</code>类型也比<code>stored</code>了每次读取数据行时都类型的衍生列好，有索引就避免需要进行一次衍生计算，同时<code>stored</code>类型衍生列实际存储数据，使得聚簇索引更大更占空间。<strong>注意，出于性能的考虑，选择 Virtual 而不是 Stored</strong></p> <div class=highlight><pre><span></span><code><span class=c1>-- 通过sidea和sideb列中直角三角形的边的长度 ，并计算下斜边的长度 sidec（其他边的平方和的平方根）</span>

<span class=c1>-- 建表定义直角三角形（长边，短边，斜边（斜边是计算出来的））</span>
<span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>triangle</span><span class=w> </span><span class=p>(</span>
<span class=w>  </span><span class=n>sidea</span><span class=w> </span><span class=n>DOUBLE</span><span class=p>,</span>
<span class=w>  </span><span class=n>sideb</span><span class=w> </span><span class=n>DOUBLE</span><span class=p>,</span>
<span class=w>  </span><span class=n>sidec</span><span class=w> </span><span class=n>DOUBLE</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=p>(</span><span class=n>SQRT</span><span class=p>(</span><span class=n>sidea</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=n>sidea</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>sideb</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=n>sideb</span><span class=p>))</span>
<span class=p>);</span>

<span class=c1>-- 测试数据</span>
<span class=k>INSERT</span><span class=w> </span><span class=k>INTO</span><span class=w> </span><span class=n>triangle</span><span class=w> </span><span class=p>(</span><span class=n>sidea</span><span class=p>,</span><span class=w> </span><span class=n>sideb</span><span class=p>)</span><span class=w> </span><span class=k>VALUES</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span><span class=mi>1</span><span class=p>),(</span><span class=mi>3</span><span class=p>,</span><span class=mi>4</span><span class=p>),(</span><span class=mi>6</span><span class=p>,</span><span class=mi>8</span><span class=p>);</span>


<span class=n>mysql</span><span class=o>&gt;</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>triangle</span><span class=p>;</span>
<span class=o>+</span><span class=c1>-------+-------+--------------------+</span>
<span class=o>|</span><span class=w> </span><span class=n>sidea</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=n>sideb</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=n>sidec</span><span class=w>              </span><span class=o>|</span>
<span class=o>+</span><span class=c1>-------+-------+--------------------+</span>
<span class=o>|</span><span class=w>     </span><span class=mi>1</span><span class=w> </span><span class=o>|</span><span class=w>     </span><span class=mi>1</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=mi>1</span><span class=p>.</span><span class=mi>4142135623730951</span><span class=w> </span><span class=o>|</span>
<span class=o>|</span><span class=w>     </span><span class=mi>3</span><span class=w> </span><span class=o>|</span><span class=w>     </span><span class=mi>4</span><span class=w> </span><span class=o>|</span><span class=w>                  </span><span class=mi>5</span><span class=w> </span><span class=o>|</span>
<span class=o>|</span><span class=w>     </span><span class=mi>6</span><span class=w> </span><span class=o>|</span><span class=w>     </span><span class=mi>8</span><span class=w> </span><span class=o>|</span><span class=w>                 </span><span class=mi>10</span><span class=w> </span><span class=o>|</span>
<span class=o>+</span><span class=c1>-------+-------+--------------------+</span>


<span class=c1>-- 表生成列语法</span>
<span class=n>col_name</span><span class=w> </span><span class=n>data_type</span><span class=w> </span><span class=p>[</span><span class=k>GENERATED</span><span class=w> </span><span class=n>ALWAYS</span><span class=p>]</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=p>(</span><span class=n>expr</span><span class=p>)</span>
<span class=w>  </span><span class=p>[</span><span class=n>VIRTUAL</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=n>STORED</span><span class=p>]</span><span class=w> </span><span class=p>[</span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=k>NULL</span><span class=p>]</span>
<span class=w>  </span><span class=p>[</span><span class=k>UNIQUE</span><span class=w> </span><span class=p>[</span><span class=k>KEY</span><span class=p>]]</span><span class=w> </span><span class=p>[[</span><span class=k>PRIMARY</span><span class=p>]</span><span class=w> </span><span class=k>KEY</span><span class=p>]</span>
<span class=w>  </span><span class=p>[</span><span class=k>COMMENT</span><span class=w> </span><span class=s1>&#39;string&#39;</span><span class=p>]</span>

<span class=c1>-- 其中，GENERATED ALWAYS可以省略；</span>
<span class=c1>-- AS定义了生成列的表达式；</span>
<span class=c1>-- VIRTUAL表示创建虚拟生成列，虚拟列的值不会存储，而是在读取时BEFORE触发器之后立即计算；</span>
<span class=c1>-- STORED表示存储生成列；默认创建的是VIRTUAL生成列。</span>



<span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=o>`</span><span class=n>iam</span><span class=o>`</span><span class=p>.</span><span class=o>`</span><span class=n>biz_cloudsign_login</span><span class=o>`</span><span class=w>  </span><span class=p>(</span>
<span class=w>  </span><span class=o>`</span><span class=n>id</span><span class=o>`</span><span class=w> </span><span class=nb>bigint</span><span class=p>(</span><span class=mi>20</span><span class=p>)</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=w> </span><span class=n>AUTO_INCREMENT</span><span class=p>,</span>
<span class=w>  </span><span class=o>`</span><span class=n>business_system_code</span><span class=o>`</span><span class=w> </span><span class=nb>int</span><span class=p>(</span><span class=mi>11</span><span class=p>)</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=p>,</span>
<span class=w>  </span><span class=o>`</span><span class=n>user_department</span><span class=o>`</span><span class=w> </span><span class=nb>varchar</span><span class=p>(</span><span class=mi>50</span><span class=p>)</span><span class=w> </span><span class=nb>CHARACTER</span><span class=w> </span><span class=k>SET</span><span class=w> </span><span class=n>utf8mb4</span><span class=w> </span><span class=k>COLLATE</span><span class=w> </span><span class=n>utf8mb4_general_ci</span><span class=w> </span><span class=k>NULL</span><span class=w> </span><span class=k>DEFAULT</span><span class=w> </span><span class=k>NULL</span><span class=p>,</span>
<span class=w>  </span><span class=o>`</span><span class=n>employee_num</span><span class=o>`</span><span class=w> </span><span class=nb>varchar</span><span class=p>(</span><span class=mi>36</span><span class=p>)</span><span class=w> </span><span class=nb>CHARACTER</span><span class=w> </span><span class=k>SET</span><span class=w> </span><span class=n>utf8mb4</span><span class=w> </span><span class=k>COLLATE</span><span class=w> </span><span class=n>utf8mb4_general_ci</span><span class=w> </span><span class=k>NULL</span><span class=w> </span><span class=k>DEFAULT</span><span class=w> </span><span class=k>NULL</span><span class=p>,</span>
<span class=w>  </span><span class=o>`</span><span class=n>user_name</span><span class=o>`</span><span class=w> </span><span class=nb>varchar</span><span class=p>(</span><span class=mi>50</span><span class=p>)</span><span class=w> </span><span class=nb>CHARACTER</span><span class=w> </span><span class=k>SET</span><span class=w> </span><span class=n>utf8mb4</span><span class=w> </span><span class=k>COLLATE</span><span class=w> </span><span class=n>utf8mb4_general_ci</span><span class=w> </span><span class=k>NULL</span><span class=w> </span><span class=k>DEFAULT</span><span class=w> </span><span class=k>NULL</span><span class=p>,</span>
<span class=w>  </span><span class=o>`</span><span class=n>identity_number</span><span class=o>`</span><span class=w> </span><span class=nb>varchar</span><span class=p>(</span><span class=mi>20</span><span class=p>)</span><span class=w> </span><span class=nb>CHARACTER</span><span class=w> </span><span class=k>SET</span><span class=w> </span><span class=n>utf8mb4</span><span class=w> </span><span class=k>COLLATE</span><span class=w> </span><span class=n>utf8mb4_general_ci</span><span class=w> </span><span class=k>NULL</span><span class=w> </span><span class=k>DEFAULT</span><span class=w> </span><span class=k>NULL</span><span class=p>,</span>
<span class=w>  </span><span class=o>`</span><span class=n>client_id</span><span class=o>`</span><span class=w> </span><span class=nb>varchar</span><span class=p>(</span><span class=mi>40</span><span class=p>)</span><span class=w> </span><span class=nb>CHARACTER</span><span class=w> </span><span class=k>SET</span><span class=w> </span><span class=n>utf8mb4</span><span class=w> </span><span class=k>COLLATE</span><span class=w> </span><span class=n>utf8mb4_general_ci</span><span class=w> </span><span class=k>NULL</span><span class=w> </span><span class=k>DEFAULT</span><span class=w> </span><span class=k>NULL</span><span class=p>,</span>
<span class=w>  </span><span class=o>`</span><span class=n>client_ip</span><span class=o>`</span><span class=w> </span><span class=nb>varchar</span><span class=p>(</span><span class=mi>40</span><span class=p>)</span><span class=w> </span><span class=nb>CHARACTER</span><span class=w> </span><span class=k>SET</span><span class=w> </span><span class=n>utf8mb4</span><span class=w> </span><span class=k>COLLATE</span><span class=w> </span><span class=n>utf8mb4_general_ci</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=p>,</span>
<span class=w>  </span><span class=o>`</span><span class=n>random_num</span><span class=o>`</span><span class=w> </span><span class=nb>varchar</span><span class=p>(</span><span class=mi>50</span><span class=p>)</span><span class=w> </span><span class=nb>CHARACTER</span><span class=w> </span><span class=k>SET</span><span class=w> </span><span class=n>utf8mb4</span><span class=w> </span><span class=k>COLLATE</span><span class=w> </span><span class=n>utf8mb4_general_ci</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=p>,</span>
<span class=w>  </span><span class=o>`</span><span class=n>cert_id</span><span class=o>`</span><span class=w> </span><span class=nb>varchar</span><span class=p>(</span><span class=mi>36</span><span class=p>)</span><span class=w> </span><span class=nb>CHARACTER</span><span class=w> </span><span class=k>SET</span><span class=w> </span><span class=n>utf8mb4</span><span class=w> </span><span class=k>COLLATE</span><span class=w> </span><span class=n>utf8mb4_general_ci</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=p>,</span>
<span class=w>  </span><span class=o>`</span><span class=n>encrypted_token</span><span class=o>`</span><span class=w> </span><span class=n>longtext</span><span class=w> </span><span class=nb>CHARACTER</span><span class=w> </span><span class=k>SET</span><span class=w> </span><span class=n>utf8mb4</span><span class=w> </span><span class=k>COLLATE</span><span class=w> </span><span class=n>utf8mb4_general_ci</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=p>,</span>
<span class=w>  </span><span class=o>`</span><span class=n>updated_at</span><span class=o>`</span><span class=w> </span><span class=n>datetime</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=p>,</span>
<span class=w>  </span><span class=k>PRIMARY</span><span class=w> </span><span class=k>KEY</span><span class=w> </span><span class=p>(</span><span class=o>`</span><span class=n>id</span><span class=o>`</span><span class=p>)</span><span class=w> </span><span class=k>USING</span><span class=w> </span><span class=n>BTREE</span><span class=p>,</span>

<span class=p>)</span><span class=w> </span><span class=n>ENGINE</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>InnoDB</span><span class=w> </span><span class=n>AUTO_INCREMENT</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>302</span><span class=w> </span><span class=nb>CHARACTER</span><span class=w> </span><span class=k>SET</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>utf8mb4</span><span class=w> </span><span class=k>COLLATE</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>utf8mb4_general_ci</span><span class=w> </span><span class=n>ROW_FORMAT</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>Dynamic</span><span class=p>;</span>



<span class=k>SELECT</span>
<span class=w>    </span><span class=n>DATE_FORMAT</span><span class=p>(</span><span class=n>v</span><span class=p>.</span><span class=n>updated_at</span><span class=p>,</span><span class=w>   </span><span class=s1>&#39;%Y-%m-%d&#39;</span><span class=p>),</span>
<span class=w>    </span><span class=k>count</span><span class=p>(</span><span class=n>DATE_FORMAT</span><span class=p>(</span><span class=n>v</span><span class=p>.</span><span class=n>updated_at</span><span class=p>,</span><span class=w>   </span><span class=s1>&#39;%Y-%m-%d&#39;</span><span class=p>))</span>
<span class=k>FROM</span>
<span class=w>    </span><span class=n>biz_cloudsign_login</span><span class=w> </span><span class=n>v</span>
<span class=w>    </span><span class=k>INNER</span><span class=w> </span><span class=k>JOIN</span><span class=w> </span><span class=p>(</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=k>MAX</span><span class=p>(</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=p>)</span><span class=w> </span><span class=s1>&#39;id&#39;</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>biz_cloudsign_login</span><span class=w> </span><span class=k>GROUP</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>employee_num</span><span class=p>,</span><span class=n>DATE_FORMAT</span><span class=p>(</span><span class=n>updated_at</span><span class=p>,</span><span class=w> </span><span class=s1>&#39;%Y-%m-%d&#39;</span><span class=p>)</span><span class=w> </span><span class=p>)</span><span class=w> </span><span class=k>c</span><span class=w> </span><span class=k>ON</span><span class=w> </span><span class=n>v</span><span class=p>.</span><span class=n>id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>c</span><span class=p>.</span><span class=n>id</span>
<span class=w>    </span><span class=k>GROUP</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>DATE_FORMAT</span><span class=p>(</span><span class=n>v</span><span class=p>.</span><span class=n>updated_at</span><span class=p>,</span><span class=w>   </span><span class=s1>&#39;%Y-%m-%d&#39;</span><span class=p>)</span>


<span class=c1>-- 在查询字段和分组字段加上索引</span>
<span class=k>ALTER</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=o>`</span><span class=n>iam</span><span class=o>`</span><span class=p>.</span><span class=o>`</span><span class=n>biz_cloudsign_login</span><span class=o>`</span>
<span class=k>ADD</span><span class=w> </span><span class=k>INDEX</span><span class=w> </span><span class=o>`</span><span class=n>idx_updated_at</span><span class=o>`</span><span class=p>(</span><span class=o>`</span><span class=n>updated_at</span><span class=o>`</span><span class=p>),</span>
<span class=k>ADD</span><span class=w> </span><span class=k>INDEX</span><span class=w> </span><span class=o>`</span><span class=n>idx_employee_num_updated_at</span><span class=o>`</span><span class=p>(</span><span class=o>`</span><span class=n>employee_num</span><span class=o>`</span><span class=p>,</span><span class=w> </span><span class=o>`</span><span class=n>updated_at</span><span class=o>`</span><span class=p>);</span>


<span class=c1>-- 有时候需要对字段上加函数然后进行GROUP BY。查看执行计划，发现出现 Using temporary， 分组条件并没有走索引。</span>
<span class=c1>-- 因为mysql 5.7 的函数会导致索引失效。我们可以通过添加一个冗余字段来保存函数的计算结果，然后添加索引，这时候的GROUP BY就会走索引了。</span>

<span class=c1>-- 加个新字段，虚拟列。</span>
<span class=k>ALTER</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=o>`</span><span class=n>iam</span><span class=o>`</span><span class=p>.</span><span class=o>`</span><span class=n>biz_cloudsign_login</span><span class=o>`</span>
<span class=k>ADD</span><span class=w> </span><span class=k>COLUMN</span><span class=w> </span><span class=o>`</span><span class=n>update_at_date</span><span class=o>`</span><span class=w> </span><span class=nb>date</span><span class=w> </span><span class=k>GENERATED</span><span class=w> </span><span class=n>ALWAYS</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=p>(</span><span class=n>date_format</span><span class=p>(</span><span class=o>`</span><span class=n>updated_at</span><span class=o>`</span><span class=p>,</span><span class=s1>&#39;%Y-%m-%d&#39;</span><span class=p>))</span><span class=w> </span><span class=n>Virtual</span><span class=w> </span><span class=k>NULL</span><span class=w> </span><span class=k>AFTER</span><span class=w> </span><span class=o>`</span><span class=n>updated_at</span><span class=o>`</span><span class=p>;</span>

<span class=c1>-- 对虚拟字段加上索引</span>
<span class=k>ALTER</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=o>`</span><span class=n>iam</span><span class=o>`</span><span class=p>.</span><span class=o>`</span><span class=n>biz_cloudsign_login</span><span class=o>`</span>
<span class=k>ADD</span><span class=w> </span><span class=k>INDEX</span><span class=w> </span><span class=o>`</span><span class=n>idx_updated_at</span><span class=o>`</span><span class=p>(</span><span class=o>`</span><span class=n>update_at_date</span><span class=o>`</span><span class=p>),</span>
<span class=k>ADD</span><span class=w> </span><span class=k>INDEX</span><span class=w> </span><span class=o>`</span><span class=n>idx_employee_num_updated_at</span><span class=o>`</span><span class=p>(</span><span class=o>`</span><span class=n>employee_num</span><span class=o>`</span><span class=p>,</span><span class=w> </span><span class=o>`</span><span class=n>update_at_date</span><span class=o>`</span><span class=p>);</span>
</code></pre></div> <h3 id=_7>数据插入<a class=headerlink href=#_7 title="Permanent link">&para;</a></h3> <p>SQL 标准主要提供了两种插入数据的语法：</p> <div class=highlight><pre><span></span><code><span class=c1>-- 第一种语法用于将指定的数据插入目标表</span>
<span class=k>INSERT</span><span class=w> </span><span class=k>INTO</span><span class=w> </span><span class=err>…</span><span class=w> </span><span class=k>VALUES</span><span class=w> </span><span class=err>…</span>
<span class=c1>-- 第二种语法可以将一个查询结果插入目标表</span>
<span class=k>INSERT</span><span class=w> </span><span class=k>INTO</span><span class=w> </span><span class=err>…</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=err>…</span>
</code></pre></div> <p>在 MySQL 中可以使用 INSERT 语句向数据库已有的表中插入一行或者多行元组数据。</p> <div class=highlight><pre><span></span><code><span class=c1>--单条插入</span>
<span class=k>INSERT</span><span class=w> </span><span class=k>INTO</span><span class=w> </span><span class=n>items</span><span class=p>(</span><span class=n>name</span><span class=p>,</span><span class=n>city</span><span class=p>,</span><span class=n>price</span><span class=p>,</span><span class=nb>number</span><span class=p>,</span><span class=n>picture</span><span class=p>)</span><span class=w>  </span><span class=k>VALUES</span><span class=w> </span><span class=p>(</span><span class=s1>&#39;耐克运动鞋&#39;</span><span class=p>,</span><span class=s1>&#39;广州&#39;</span><span class=p>,</span><span class=mi>500</span><span class=p>,</span><span class=mi>1000</span><span class=p>,</span><span class=s1>&#39;003.jpg&#39;</span><span class=p>);</span>



<span class=c1>--批量插入</span>
<span class=k>INSERT</span><span class=w> </span><span class=k>INTO</span><span class=w>  </span><span class=n>items</span><span class=p>(</span><span class=n>name</span><span class=p>,</span><span class=n>city</span><span class=p>,</span><span class=n>price</span><span class=p>,</span><span class=nb>number</span><span class=p>,</span><span class=n>picture</span><span class=p>)</span>
<span class=w> </span><span class=k>VALUES</span>
<span class=p>(</span><span class=s1>&#39;耐克运动鞋&#39;</span><span class=p>,</span><span class=s1>&#39;广州&#39;</span><span class=p>,</span><span class=mi>500</span><span class=p>,</span><span class=mi>1000</span><span class=p>,</span><span class=s1>&#39;003.jpg&#39;</span><span class=p>),</span>
<span class=p>(</span><span class=s1>&#39;耐克运动鞋2&#39;</span><span class=p>,</span><span class=s1>&#39;广州2&#39;</span><span class=p>,</span><span class=mi>500</span><span class=p>,</span><span class=mi>1000</span><span class=p>,</span><span class=s1>&#39;002.jpg&#39;</span><span class=p>);</span>

<span class=c1>-- 1、要根据情况设置一次批量插入的数据量，数据量大，在网络中传输的事件也越久，出现问题的可能也越大；</span>

<span class=c1>-- 2、除了网络，还要看机器配置，MySQL Server配置差了，sql写得再好，效率也不会太高；</span>

<span class=c1>-- 3、另外批量这个词，是指一次插入多条数据，我们除了要注意数据的条数，还要注意一条数据的大小，举个例子：比如一条记录的数据量有1M，10条记录的数据量就10M，这时一次插100条，100M数据，嘿嘿，你试试看！！所以，一次插入多少数据，一定要经过多次测试后再决定，别人1次插100条最优，你可能1次插10条才最优，没有绝对的最优值（批量插入未必总是比单条插入效率高）。</span>

<span class=c1>-- 4、数据库有个参数，max_allowed_packet，也就是每一个包（sql）命令大小，默认是1M，那么sql的长度大于1M就会报错。你可能会说，咱们把这个参数设成10M，100M不就行了？？？对呀，没毛病，但你是DBA吗？你有权限吗？即使调大这一个参数，你要知道影响的可不止你这一张表，而是整个DB Server，那影响的可是很多库，很多表。</span>

<span class=c1>-- 5、批量插入并不是越快越好，我们可能希望越快越好，这很正常，节省时间嘛。但是我们一定要知道，数据库分读写，有集群，这就意味着，需要同步！！！如果有分库分表分区的情况，如果短时间内插入的数据量太大，数据库同步可能就会比较迷了，读写数据不一致的情况在所难免了，可能会因为一张表的批量插入，影响整个DB服务组的同步，同时还要考虑并发问题。</span>

<span class=c1>--如果使用 Oracle 数据库，我们需要在执行 INSERT 语句之后使用 COMMIT 语句提交修改　</span>
</code></pre></div> <div class=highlight><pre><span></span><code><span class=c1>-- REPLACE INSERT语句</span>

<span class=c1>-- REPLACE INTO是INSERT INTO的加强版，既可以更新数据也可以插入数据；</span>
<span class=c1>-- 在向表中插入数据的时候，经常遇到这样的情况：1. 首先判断数据是否存在； 2. 如果不存在，则插入；3.如果存在，则更新。</span>

<span class=c1>-- REPLACE INTO用于实时覆盖写入数据。写入数据时，会先根据主键判断待写入的数据是否已经存在于表中，并根据判断结果选择不同的方式写入数据：</span>

<span class=c1>-- 使用REPLACE INTO时，首先会根据主键或者唯一索引查看表中是否有该条记录，有的话则先删除，然后插入数据；没有该记录则直接插入。</span>

<span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=o>`</span><span class=n>stu</span><span class=o>`</span><span class=w> </span><span class=p>(</span>
<span class=w>  </span><span class=o>`</span><span class=n>id</span><span class=o>`</span><span class=w> </span><span class=nb>int</span><span class=p>(</span><span class=mi>11</span><span class=p>)</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=w> </span><span class=n>AUTO_INCREMENT</span><span class=p>,</span>
<span class=w>  </span><span class=o>`</span><span class=n>cid</span><span class=o>`</span><span class=w> </span><span class=nb>int</span><span class=p>(</span><span class=mi>11</span><span class=p>)</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=p>,</span>
<span class=w>  </span><span class=o>`</span><span class=n>name</span><span class=o>`</span><span class=w> </span><span class=nb>varchar</span><span class=p>(</span><span class=mi>32</span><span class=p>)</span><span class=w> </span><span class=k>DEFAULT</span><span class=w> </span><span class=k>NULL</span><span class=p>,</span>
<span class=w>  </span><span class=k>PRIMARY</span><span class=w> </span><span class=k>KEY</span><span class=w> </span><span class=p>(</span><span class=o>`</span><span class=n>id</span><span class=o>`</span><span class=p>),</span>
<span class=w>  </span><span class=k>UNIQUE</span><span class=w> </span><span class=k>KEY</span><span class=w> </span><span class=o>`</span><span class=n>cid</span><span class=o>`</span><span class=w> </span><span class=p>(</span><span class=o>`</span><span class=n>cid</span><span class=o>`</span><span class=p>)</span>
<span class=p>)</span><span class=w> </span><span class=n>ENGINE</span><span class=o>=</span><span class=n>InnoDB</span><span class=w>  </span><span class=k>DEFAULT</span><span class=w> </span><span class=n>CHARSET</span><span class=o>=</span><span class=n>utf8</span><span class=p>;</span>
<span class=c1>-- 其中id为自增主键，cid为唯一索引。</span>

<span class=c1>-- 插入两条数据</span>
<span class=k>INSERT</span><span class=w> </span><span class=k>INTO</span><span class=w> </span><span class=n>stu</span><span class=p>(</span><span class=n>cid</span><span class=p>,</span><span class=w> </span><span class=n>name</span><span class=p>)</span><span class=w> </span><span class=k>VALUES</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span><span class=w> </span><span class=s1>&#39;1111&#39;</span><span class=p>);</span>
<span class=k>INSERT</span><span class=w> </span><span class=k>INTO</span><span class=w> </span><span class=n>stu</span><span class=p>(</span><span class=n>cid</span><span class=p>,</span><span class=w> </span><span class=n>name</span><span class=p>)</span><span class=w> </span><span class=k>VALUES</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span><span class=w> </span><span class=s1>&#39;2222&#39;</span><span class=p>);</span>
<span class=k>REPLACE</span><span class=w> </span><span class=k>INTO</span><span class=w> </span><span class=n>stu</span><span class=p>(</span><span class=n>cid</span><span class=p>,</span><span class=w> </span><span class=n>name</span><span class=p>)</span><span class=w> </span><span class=k>VALUES</span><span class=p>(</span><span class=mi>3</span><span class=p>,</span><span class=s1>&#39;3333&#39;</span><span class=p>);</span>


<span class=c1>-- 1    1   1111</span>
<span class=c1>-- 2    2   2222</span>
<span class=c1>-- 3    3   3333</span>


<span class=k>REPLACE</span><span class=w> </span><span class=k>INTO</span><span class=w> </span><span class=n>stu</span><span class=p>(</span><span class=n>cid</span><span class=p>,</span><span class=w> </span><span class=n>name</span><span class=p>)</span><span class=w> </span><span class=k>VALUES</span><span class=p>(</span><span class=mi>3</span><span class=p>,</span><span class=s1>&#39;33331&#39;</span><span class=p>);</span>
<span class=c1>-- 使用REPLACE INTO时，首先会根据主键或者唯一索引查看表中是否有该条记录，有的话则先删除，然后插入数据；没有该记录则直接插入。</span>
<span class=c1>-- 原先id为3的记录变成了id为4了，说明原先id为3的记录先删除了，然后新插入了id为4（id自增）的新记录</span>

<span class=c1>-- 1    1   1111</span>
<span class=c1>-- 2    2   2222</span>
<span class=c1>-- 4    3   33331</span>


<span class=c1>--再次执行replace，id为4和cid为2的原记录都存在，则被删除。然后再插入这条新纪录</span>
<span class=k>REPLACE</span><span class=w> </span><span class=k>INTO</span><span class=w> </span><span class=n>stu</span><span class=p>(</span><span class=n>id</span><span class=p>,</span><span class=w> </span><span class=n>cid</span><span class=p>,</span><span class=w> </span><span class=n>name</span><span class=p>)</span><span class=w> </span><span class=k>VALUES</span><span class=p>(</span><span class=mi>4</span><span class=p>,</span><span class=w> </span><span class=mi>2</span><span class=p>,</span><span class=s1>&#39;42&#39;</span><span class=p>)</span>
<span class=o>&gt;</span><span class=w> </span><span class=n>Affected</span><span class=w> </span><span class=k>rows</span><span class=p>:</span><span class=w> </span><span class=mi>3</span>
<span class=o>&gt;</span><span class=w> </span><span class=err>查询时间</span><span class=p>:</span><span class=w> </span><span class=mi>0</span><span class=p>.</span><span class=mi>007</span><span class=n>s</span>
<span class=c1>-- 1    1   1111</span>
<span class=c1>-- 4    2   42</span>
</code></pre></div> <div class=highlight><pre><span></span><code><span class=c1>-- INSERT INTO…SELECT…FROM 语句用于快速地从一个或多个表中取出数据，并将这些数据作为行数据插入另一个表中。</span>
<span class=c1>-- SELECT 子句返回的是一个查询到的结果集，INSERT 语句将这个结果集插入指定表中，结果集中的每行数据的字段数、字段的数据类型都必须与被操作的表完全一致。</span>
</code></pre></div> <p>数据库在插入、更新或者删除数据之前会执行数据的完整性检查。如果违反约束，将会返回错误信息，而不会修改数据。</p> <p>如果我们在定义表的字段时指定了默认值，也可以使用 DEFAULT 插入默认值</p> <h3 id=_8>数据更新<a class=headerlink href=#_8 title="Permanent link">&para;</a></h3> <p>SQL 标准使用 UPDATE 语句更新表中的数据。</p> <div class=highlight><pre><span></span><code><span class=c1>-- UPDATE 语句的基本语法如下</span>
<span class=k>UPDATE</span><span class=w> </span><span class=n>t</span>
<span class=k>SET</span><span class=w> </span><span class=n>col1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>expr1</span><span class=p>,</span>
<span class=w>    </span><span class=n>col2</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>expr2</span><span class=p>,</span>
<span class=w>    </span><span class=p>...</span>
<span class=w>    </span><span class=p>[</span><span class=k>WHERE</span><span class=w> </span><span class=n>condition</span><span class=p>];</span>

<span class=c1>-- 其中 t 是更新操作的目标表，SET 子句指定了需要更新的列和更新后的值，多个字段使用逗号进行分隔。</span>
<span class=c1>-- 如果指定了 WHERE 子句，只有满足条件的数据行才会被更新。如果没有指定条件，将会更新表中的所有数据行</span>

<span class=c1>-- 更新赵云的月薪和奖金</span>
<span class=k>UPDATE</span><span class=w> </span><span class=n>emp_devp</span>
<span class=k>SET</span><span class=w> </span><span class=n>salary</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>salary</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=mi>1000</span><span class=p>,</span>
<span class=w>    </span><span class=n>bonus</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>8000</span>
<span class=k>WHERE</span><span class=w> </span><span class=n>emp_name</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s1>&#39;赵云&#39;</span><span class=p>;</span>
</code></pre></div> <p>MySQL 数据库中 UPDATE 语句和 SQL 标准（以及其他数据库）实现上的一个差异。如果我们没有注意到这个问题，很可能会导致意料之外的结果。</p> <div class=highlight><pre><span></span><code><span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>t1</span><span class=p>(</span>
<span class=w> </span><span class=n>id</span><span class=w> </span><span class=nb>int</span><span class=p>,</span>
<span class=w> </span><span class=n>col1</span><span class=w> </span><span class=nb>int</span><span class=p>,</span>
<span class=w> </span><span class=n>col2</span><span class=w> </span><span class=nb>int</span>
<span class=p>);</span>

<span class=k>INSERT</span><span class=w> </span><span class=k>INTO</span><span class=w> </span><span class=n>t1</span><span class=w> </span><span class=k>VALUES</span><span class=w> </span><span class=p>(</span><span class=mi>1</span><span class=p>,</span><span class=w> </span><span class=mi>1</span><span class=p>,</span><span class=w> </span><span class=mi>1</span><span class=p>);</span>

<span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>t1</span><span class=p>;</span>
<span class=n>id</span><span class=o>|</span><span class=n>col1</span><span class=o>|</span><span class=n>col2</span><span class=o>|</span>
<span class=c1>--|----|----|</span>
<span class=mi>1</span><span class=o>|</span><span class=w>   </span><span class=mi>1</span><span class=o>|</span><span class=w>   </span><span class=mi>1</span><span class=o>|</span>



<span class=k>UPDATE</span><span class=w> </span><span class=n>t1</span>
<span class=k>SET</span><span class=w> </span><span class=n>col1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>col1</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=mi>1</span><span class=p>,</span>
<span class=w>   </span><span class=n>col2</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>col1</span>
<span class=k>WHERE</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span>

<span class=k>SELECT</span><span class=w> </span><span class=n>col1</span><span class=p>,</span><span class=w> </span><span class=n>col2</span>
<span class=k>FROM</span><span class=w> </span><span class=n>t1</span><span class=p>;</span>
</code></pre></div> <p>对于 SQL 标准以及其他数据库的实现，结果分别为  2  和  1。但是对于 MySQL，结果分别为  2  和  2</p> <p>对于 MySQL 而言，如果 UPDATE 语句在表达式中（col2 = col1）使用了前面被更新的字段（col1），将会使用该字段被更新后的值（2）而不是原来的值（1）。</p> <p>一般在编写 UPDATE 语句时，我们不需要关心多个字段的更新顺序。但是由于 MySQL 实现的问题，我们需要注意它们的语法顺序。</p> <h4 id=_9>关联更新<a class=headerlink href=#_9 title="Permanent link">&para;</a></h4> <p>有时候我们需要用 b 表去更新 a 表的记录，如果只有一个字段那通常我们可能就<code>update set a.xxx=(select b.xxx from b where a.ib.id)</code>，但是字段一多，显得就不是特别方便了，加上不好做限制，所以就了<code>update join</code></p> <div class=highlight><pre><span></span><code><span class=c1>-- 主表</span>
<span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=o>`</span><span class=n>unit</span><span class=o>`</span><span class=w> </span><span class=p>(</span>
<span class=w>  </span><span class=o>`</span><span class=n>unit_id</span><span class=o>`</span><span class=w> </span><span class=nb>int</span><span class=p>(</span><span class=mi>11</span><span class=p>)</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=w> </span><span class=n>AUTO_INCREMENT</span><span class=p>,</span>
<span class=w>  </span><span class=o>`</span><span class=n>price</span><span class=o>`</span><span class=w> </span><span class=nb>decimal</span><span class=p>(</span><span class=mi>10</span><span class=p>,</span><span class=mi>2</span><span class=p>)</span><span class=w> </span><span class=k>DEFAULT</span><span class=w> </span><span class=k>NULL</span><span class=w> </span><span class=k>COMMENT</span><span class=w> </span><span class=s1>&#39;价格指数&#39;</span><span class=p>,</span>
<span class=w>  </span><span class=o>`</span><span class=n>fix_flag</span><span class=o>`</span><span class=w> </span><span class=n>tinyint</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span><span class=w> </span><span class=k>DEFAULT</span><span class=w> </span><span class=s1>&#39;0&#39;</span><span class=w> </span><span class=k>COMMENT</span><span class=w> </span><span class=s1>&#39;修复标记&#39;</span>
<span class=p>)</span><span class=w> </span><span class=p>;</span>

<span class=c1>-- 修复表/关联更新表</span>
<span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=o>`</span><span class=n>unit_fix</span><span class=o>`</span><span class=w> </span><span class=p>(</span>
<span class=w>  </span><span class=o>`</span><span class=n>unit_id</span><span class=o>`</span><span class=w> </span><span class=nb>int</span><span class=p>(</span><span class=mi>11</span><span class=p>)</span><span class=w> </span><span class=k>DEFAULT</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=p>,</span>
<span class=w>  </span><span class=o>`</span><span class=n>price</span><span class=o>`</span><span class=w> </span><span class=nb>decimal</span><span class=p>(</span><span class=mi>10</span><span class=p>,</span><span class=mi>2</span><span class=p>)</span><span class=w> </span><span class=k>DEFAULT</span><span class=w> </span><span class=k>NULL</span><span class=w> </span><span class=k>COMMENT</span><span class=w> </span><span class=s1>&#39;价格指数&#39;</span>
<span class=p>)</span><span class=w> </span><span class=p>;</span>


<span class=c1>-- 更新</span>
<span class=k>UPDATE</span><span class=w> </span><span class=n>unit</span><span class=w> </span><span class=n>u</span>
<span class=k>SET</span><span class=w> </span><span class=n>u</span><span class=p>.</span><span class=n>bid_unit</span><span class=w> </span><span class=o>=</span><span class=p>(</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=n>x</span><span class=p>.</span><span class=n>price</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>unit_fix</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>x</span><span class=p>.</span><span class=n>unit_id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>u</span><span class=p>.</span><span class=n>unit_id</span><span class=w> </span><span class=p>),</span>
<span class=w>    </span><span class=n>u</span><span class=p>.</span><span class=n>fix_flag</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>1</span>
<span class=k>WHERE</span>
<span class=w>    </span><span class=n>u</span><span class=p>.</span><span class=n>unit_id</span><span class=w> </span><span class=k>IN</span><span class=w> </span><span class=p>(</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=n>xx</span><span class=p>.</span><span class=n>unit_id</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>unit_fix</span><span class=w> </span><span class=n>xx</span><span class=w> </span><span class=p>);</span>


<span class=c1>-- 关联更新</span>
<span class=k>UPDATE</span><span class=w> </span><span class=n>unit</span><span class=w> </span><span class=n>u</span>
<span class=k>JOIN</span><span class=w> </span><span class=n>unit_fix</span><span class=w> </span><span class=n>uf</span><span class=w> </span><span class=k>ON</span><span class=w> </span><span class=n>u</span><span class=p>.</span><span class=n>unit_id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>uf</span><span class=p>.</span><span class=n>unit_id</span>
<span class=k>SET</span><span class=w> </span><span class=n>u</span><span class=p>.</span><span class=n>price</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>uf</span><span class=p>.</span><span class=n>price</span><span class=p>,</span>
<span class=w>    </span><span class=n>u</span><span class=p>.</span><span class=n>fix_flag</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>1</span>
<span class=k>WHERE</span>
<span class=w>    </span><span class=n>uf</span><span class=p>.</span><span class=n>tender_id</span><span class=w> </span><span class=k>IS</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=p>;</span>


<span class=c1>-- 写法一</span>
<span class=k>UPDATE</span><span class=w> </span><span class=n>Tab1</span><span class=p>,</span><span class=w> </span><span class=n>Tab2</span><span class=p>,</span>
<span class=k>SET</span><span class=w> </span><span class=n>Tab1</span><span class=p>.</span><span class=n>C2</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Tab2</span><span class=p>.</span><span class=n>C2</span><span class=p>,</span><span class=w> </span><span class=n>Tab2</span><span class=p>.</span><span class=n>C3</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>expression</span>
<span class=k>WHERE</span><span class=w> </span><span class=n>Tab1</span><span class=p>.</span><span class=n>C1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Tab2</span><span class=p>.</span><span class=n>C1</span><span class=w> </span><span class=k>AND</span><span class=w> </span><span class=n>condition</span><span class=p>;</span>

<span class=c1>-- 写法二</span>
<span class=k>UPDATE</span><span class=w> </span><span class=n>T1</span><span class=p>,</span><span class=n>T2</span>
<span class=k>INNER</span><span class=w> </span><span class=k>JOIN</span><span class=w> </span><span class=n>T2</span><span class=w> </span><span class=k>ON</span><span class=w> </span><span class=n>T1</span><span class=p>.</span><span class=n>C1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>T2</span><span class=p>.</span><span class=n>C1</span>
<span class=k>SET</span><span class=w> </span><span class=n>T1</span><span class=p>.</span><span class=n>C2</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>T2</span><span class=p>.</span><span class=n>C2</span><span class=p>,</span>
<span class=w>      </span><span class=n>T2</span><span class=p>.</span><span class=n>C3</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>expression</span>
<span class=k>WHERE</span><span class=w> </span><span class=n>condition</span>
</code></pre></div> <h3 id=_10>数据删除<a class=headerlink href=#_10 title="Permanent link">&para;</a></h3> <p>SQL 标准使用 DELETE 语句删除表中的数据。</p> <div class=highlight><pre><span></span><code><span class=k>DELETE</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>t</span>
<span class=w>    </span><span class=p>[</span><span class=k>WHERE</span><span class=w> </span><span class=n>conditions</span><span class=p>];</span>

<span class=c1>-- 其中 t 是删除操作的目标表。</span>
<span class=c1>-- 如果指定了 WHERE 子句，只有满足条件的数据行才会被删除。如果没有指定条件，将会删除表中所有的数据行。</span>


<span class=c1>-- leetcode. 196. Delete Duplicate Emails 删除表中重复的数据</span>

<span class=c1>-- Person表中有ID（主键）和EMAIL两列，删除email重复的行，仅保留id最小的那一行</span>
<span class=k>DELETE</span><span class=w> </span><span class=n>p</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=n>Person</span><span class=w> </span><span class=n>p</span><span class=p>,</span><span class=w> </span><span class=n>Person</span><span class=w> </span><span class=n>q</span><span class=w> </span><span class=k>where</span><span class=w> </span><span class=n>p</span><span class=p>.</span><span class=n>Id</span><span class=o>&gt;</span><span class=n>q</span><span class=p>.</span><span class=n>Id</span><span class=w> </span><span class=k>AND</span><span class=w> </span><span class=n>q</span><span class=p>.</span><span class=n>Email</span><span class=o>=</span><span class=n>p</span><span class=p>.</span><span class=n>Email</span>

<span class=k>DELETE</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>Person</span>
<span class=k>WHERE</span><span class=w> </span><span class=n>Id</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>IN</span><span class=w> </span><span class=p>(</span>
<span class=w>    </span><span class=k>SELECT</span><span class=w> </span><span class=n>Id</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=p>(</span>
<span class=w>        </span><span class=k>SELECT</span><span class=w> </span><span class=k>MIN</span><span class=p>(</span><span class=n>Id</span><span class=p>)</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=n>Id</span>
<span class=w>        </span><span class=k>FROM</span><span class=w> </span><span class=n>Person</span>
<span class=w>        </span><span class=k>GROUP</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>Email</span>
<span class=w>    </span><span class=p>)</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=n>min_id</span><span class=w>  </span><span class=c1>-- 此处需使用别名，否则会发生报错</span>
<span class=p>);</span>
</code></pre></div> <p>如果我们想要删除表中的全部数据，数据量比较少时可以直接使用 DELETE 语句，但是这种方式对于数据量很大的表所需的时间比较长。</p> <p>此时，我们可以考虑使用快速删除全表数据的 TRUNCATE 语句。也称为截断表</p> <div class=highlight><pre><span></span><code><span class=c1>-- Oracle、MySQL、Microsoft SQL Server以及PostgreSQL</span>
<span class=k>TRUNCATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>emp_devp</span><span class=p>;</span>

<span class=c1>-- SQLite 没有提供 TRUNCATE 语句，不过它对 DELETE 语句进行了优化，如果我们不指定 WHERE 子句，实际的效果等同于 TRUNCATE 语句。</span>
</code></pre></div> <p>DELETE 和 TRUNCATE 语句都可以用于删除数据，但是这两种删除方式存在一些区别：</p> <ul> <li> <p>DELETE 语句通过 WHERE 子句删除指定的数据行，如果不指定过滤条件将会删除所有的数据。DELETE 属于数据操作语言（DML），删除数据后可以选择提交或者回滚，如果删除的数据较多时速度比较慢。</p> </li> <li> <p>TRUNCATE 语句用于快速删除表中的所有数据，并且释放表的存储空间。TRUNCATE 属于数据定义语言（DDL），删除数据时默认提交，无法回滚。TRUNCATE 语句相当于删除并重建表，通常执行速度很快。</p> </li> </ul> <h3 id=_11>合并数据<a class=headerlink href=#_11 title="Permanent link">&para;</a></h3> <p>SQL 标准于 2003 年增加了一个新的数据操作语句：MERGE（合并），它可以同时完成 INSERT 语句和 UPDATE 语句，甚至 DELETE 语句的操作。</p> <p>在 Web 应用开发过程中，经常有这样一种数据处理的需求模式。就是需要更新数据，但有可能这个数据现在并不存在，就需要先创建这个记录。</p> <p>就是所谓的 <code>UPDATE OR(IF NOT EXIST) INSERT</code> 模式。传统标准的 SQL 只有 UPDATE 和 INSERT 模式，要实现这样一个业务需求，就需要先做一个存在性判断，然后来决定使用 UPDATE 或者 INSERT，</p> <p>MERGE 其实就是不存在则 INSERT，存在则 UPDATE，所以可以把它拆分成：</p> <div class=highlight><pre><span></span><code><span class=k>UPDATE</span><span class=w> </span><span class=p>...</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>EXIST</span><span class=w> </span><span class=p>(</span><span class=k>SELECT</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=p>...</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>CONDITION</span><span class=p>)</span>
<span class=k>INSERT</span><span class=w> </span><span class=p>...</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=n>EXIST</span><span class=p>(</span><span class=k>SELECT</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=p>...</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>CONDITION</span><span class=p>)</span>
</code></pre></div> <p>MERGE 语句尝试根据键字段将源表与目标表进行比较，然后进行一些处理。 MERGE 语句实际上将 <code>INSERT，UPDATE，DELETE</code> 操作完全结合在一起。尽管 MERGE 语句比简单的 INSERT 或 UPDATE 稍微复杂一点，但是一旦您掌握了基本概念，就可以比使用单个 INSERT 或 UPDATE 更容易地更频繁地使用此 SQL MERGE。</p> <p>在典型 SQL 数据仓库解决方案中，通常非常重要的一点是要维护仓库中的数据历史记录，并参考要馈送到 ETL 工具的源数据。</p> <p>最常见的用例是尝试维护数据仓库中的尺寸变化缓慢（SCD）。</p> <p>在这种情况下，您需要将新记录插入数据仓库，从仓库中删除或标记不再位于源中的记录，并更新仓库中已在源中更新的记录的值。</p> <p>缓慢变化维的提出是因为在现实世界中，维度的属性并不是静态的，它会随着时间的流逝发生缓慢的变化，与数据增长较为快速的事实表相比，维度变化相对缓慢。因此这个就叫做==<strong>缓慢变化维</strong>==。</p> <p>这意味着现在您可以将所有 DML 语句（INSERT，UPDATE 和 DELETE）组合成一个语句。从数据处理的角度来看，这非常有帮助，因为它减少了针对三个语句中的每个语句从磁盘进行的 I/O 操作，现在仅从源读取一次数据。</p> <p>同样，MERGE 语句的性能在很大程度上取决于用于匹配源表和目标表的适当索引。</p> <p>除索引外，还必须优化连接条件。 我们还应该尝试过滤源表，以便该语句仅获取必要的记录以执行必要的操作。</p> <div class=highlight><pre><span></span><code><span class=c1>-- Oracle、Microsoft SQL Server 以及 PostgreSQL</span>
<span class=n>MEGRE</span><span class=w> </span><span class=k>INTO</span><span class=w> </span><span class=n>target_table</span><span class=w> </span><span class=p>[</span><span class=k>AS</span><span class=w> </span><span class=n>t_alias</span><span class=p>]</span>
<span class=k>USING</span><span class=w> </span><span class=n>source_table</span><span class=w> </span><span class=p>[</span><span class=k>AS</span><span class=w> </span><span class=n>s_alias</span><span class=p>]</span>
<span class=k>ON</span><span class=w> </span><span class=p>(</span><span class=n>conditions</span><span class=p>)</span>
<span class=k>WHEN</span><span class=w> </span><span class=n>MATCHED</span><span class=w> </span><span class=k>THEN</span>
<span class=w>  </span><span class=k>UPDATE</span>
<span class=w>  </span><span class=k>SET</span><span class=w> </span><span class=n>col1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>expr1</span><span class=p>,</span>
<span class=w>      </span><span class=n>col2</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>expr2</span><span class=p>,</span>
<span class=w>      </span><span class=p>...</span>
<span class=k>WHEN</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=n>MATCHED</span><span class=w> </span><span class=k>THEN</span>
<span class=w>  </span><span class=k>INSERT</span><span class=w> </span><span class=p>(</span><span class=n>col1</span><span class=p>,</span><span class=w> </span><span class=n>col2</span><span class=p>,</span><span class=w> </span><span class=p>...)</span>
<span class=w>  </span><span class=k>VALUES</span><span class=w> </span><span class=p>(</span><span class=n>expr1</span><span class=p>,</span><span class=w> </span><span class=n>expr2</span><span class=p>,</span><span class=w> </span><span class=p>...);</span>

<span class=c1>-- 其中 target_table 是合并操作的目标表。</span>
<span class=c1>-- USING 子句指定了数据源，可以是一个表或者查询语句。</span>
<span class=c1>-- ON 子句指定了数据合并的条件，通常使用主键或者唯一键相等作为合并的条件。</span>

<span class=c1>-- 对于数据源中的每条记录:</span>
<span class=c1>-- 如果目标表中存在匹配的记录则执行 WHEN MATCHED THEN 分支的更新操作，.</span>
<span class=c1>-- 如果目标表中不存在匹配的记录则执行 WHEN NOT MATCHED THEN 分支的插入操作。</span>
</code></pre></div> <p>MySQL 和 SQLite 没有提供标准 MERGE 语句，不过我们可以使用专有的语法实现合并操作。</p> <div class=highlight><pre><span></span><code><span class=c1>-- 在MySQL数据库中，如果在INSERT语句后面带上ON DUPLICATE KEY UPDATE子句，而要插入的行与表中现有记录的惟一索引或主键中产生重复值，那么就会发生旧行的更新；如果插入的行数据与现有表中记录的唯一索引或者主键不重复，则执行新纪录插入操作。另外，ON DUPLICATE KEY UPDATE不能写WHERE条件。</span>

<span class=c1>-- 就是从源表抽数到目标表，如果值存在则更新，不存在则插入</span>

<span class=c1>-- MySQL</span>
<span class=c1>-- MySQL使用 ON DUPLICATE KEY UPDATE 子句合并数据，插入数据时如果主键或者唯一索引出现重复值则执行更新操作。这种专有语法不支持 DELETE 子句。</span>
<span class=k>INSERT</span><span class=w> </span><span class=k>INTO</span><span class=w> </span><span class=n>emp_devp</span><span class=p>(</span><span class=n>emp_id</span><span class=p>,</span><span class=w> </span><span class=n>emp_name</span><span class=p>,</span><span class=w> </span><span class=n>sex</span><span class=p>,</span><span class=w> </span><span class=n>dept_id</span><span class=p>,</span><span class=w> </span><span class=n>manager</span><span class=p>,</span><span class=n>hire_date</span><span class=p>,</span><span class=w> </span><span class=n>job_id</span><span class=p>,</span><span class=w> </span><span class=n>salary</span><span class=p>,</span><span class=w> </span><span class=n>bonus</span><span class=p>,</span><span class=w> </span><span class=n>email</span><span class=p>)</span>
<span class=k>SELECT</span><span class=w> </span><span class=n>emp_id</span><span class=p>,</span><span class=w> </span><span class=n>emp_name</span><span class=p>,</span><span class=w> </span><span class=n>sex</span><span class=p>,</span><span class=w> </span><span class=n>dept_id</span><span class=p>,</span><span class=w> </span><span class=n>manager</span><span class=p>,</span><span class=n>hire_date</span><span class=p>,</span><span class=w> </span><span class=n>job_id</span><span class=p>,</span><span class=w> </span><span class=n>salary</span><span class=p>,</span><span class=w> </span><span class=n>bonus</span><span class=p>,</span><span class=w> </span><span class=n>email</span>
<span class=k>FROM</span><span class=w> </span><span class=n>employee</span><span class=w> </span><span class=n>s</span>
<span class=k>WHERE</span><span class=w> </span><span class=n>dept_id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>4</span>
<span class=k>ON</span><span class=w> </span><span class=n>DUPLICATE</span><span class=w> </span><span class=k>KEY</span><span class=w> </span><span class=k>UPDATE</span>
<span class=w>   </span><span class=n>emp_name</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>s</span><span class=p>.</span><span class=n>emp_name</span><span class=p>,</span><span class=w> </span><span class=n>sex</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>s</span><span class=p>.</span><span class=n>sex</span><span class=p>,</span>
<span class=w>   </span><span class=n>dept_id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>s</span><span class=p>.</span><span class=n>dept_id</span><span class=p>,</span><span class=w> </span><span class=n>manager</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>s</span><span class=p>.</span><span class=n>manager</span><span class=p>,</span>
<span class=w>   </span><span class=n>hire_date</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>s</span><span class=p>.</span><span class=n>hire_date</span><span class=p>,</span><span class=w> </span><span class=n>job_id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>s</span><span class=p>.</span><span class=n>job_id</span><span class=p>,</span>
<span class=w>   </span><span class=n>salary</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>s</span><span class=p>.</span><span class=n>salary</span><span class=p>,</span><span class=w> </span><span class=n>bonus</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>s</span><span class=p>.</span><span class=n>bonus</span><span class=p>,</span>
<span class=w>   </span><span class=n>email</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>s</span><span class=p>.</span><span class=n>email</span><span class=p>;</span>

<span class=c1>-- PostgreSQL和SQLite</span>
<span class=c1>-- PostgreSQL 和 SQLite 使用 ON CONFLICT(emp_id) DO UPDATE 子句合并数据，插入数据时如果 emp_id 出现重复值则执行更新操作，EXCLUDED 代表了数据源中的记录。这种专有语法不支持 DELETE 子句。</span>
<span class=k>INSERT</span><span class=w> </span><span class=k>INTO</span><span class=w> </span><span class=n>emp_devp</span><span class=p>(</span><span class=n>emp_id</span><span class=p>,</span><span class=w> </span><span class=n>emp_name</span><span class=p>,</span><span class=w> </span><span class=n>sex</span><span class=p>,</span><span class=w> </span><span class=n>dept_id</span><span class=p>,</span><span class=w> </span><span class=n>manager</span><span class=p>,</span><span class=n>hire_date</span><span class=p>,</span><span class=w> </span><span class=n>job_id</span><span class=p>,</span><span class=w> </span><span class=n>salary</span><span class=p>,</span><span class=w> </span><span class=n>bonus</span><span class=p>,</span><span class=w> </span><span class=n>email</span><span class=p>)</span>
<span class=k>SELECT</span><span class=w> </span><span class=n>emp_id</span><span class=p>,</span><span class=w> </span><span class=n>emp_name</span><span class=p>,</span><span class=w> </span><span class=n>sex</span><span class=p>,</span><span class=w> </span><span class=n>dept_id</span><span class=p>,</span><span class=w> </span><span class=n>manager</span><span class=p>,</span><span class=w> </span><span class=n>hire_date</span><span class=p>,</span><span class=w> </span><span class=n>job_id</span><span class=p>,</span><span class=w> </span><span class=n>salary</span><span class=p>,</span><span class=w> </span><span class=n>bonus</span><span class=p>,</span><span class=w> </span><span class=n>email</span>
<span class=k>FROM</span><span class=w> </span><span class=n>employee</span><span class=w> </span><span class=n>s</span>
<span class=k>WHERE</span><span class=w> </span><span class=n>dept_id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>4</span>
<span class=k>ON</span><span class=w> </span><span class=n>CONFLICT</span><span class=p>(</span><span class=n>emp_id</span><span class=p>)</span><span class=w> </span><span class=k>DO</span><span class=w> </span><span class=k>UPDATE</span>
<span class=k>SET</span><span class=w> </span><span class=n>emp_name</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>EXCLUDED</span><span class=p>.</span><span class=n>emp_name</span><span class=p>,</span><span class=w> </span><span class=n>sex</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>EXCLUDED</span><span class=p>.</span><span class=n>sex</span><span class=p>,</span>
<span class=w>    </span><span class=n>dept_id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>EXCLUDED</span><span class=p>.</span><span class=n>dept_id</span><span class=p>,</span><span class=w> </span><span class=n>manager</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>EXCLUDED</span><span class=p>.</span><span class=n>manager</span><span class=p>,</span>
<span class=w>    </span><span class=n>hire_date</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>EXCLUDED</span><span class=p>.</span><span class=n>hire_date</span><span class=p>,</span><span class=w> </span><span class=n>job_id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>EXCLUDED</span><span class=p>.</span><span class=n>job_id</span><span class=p>,</span>
<span class=w>    </span><span class=n>salary</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>EXCLUDED</span><span class=p>.</span><span class=n>salary</span><span class=p>,</span><span class=w> </span><span class=n>bonus</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>EXCLUDED</span><span class=p>.</span><span class=n>bonus</span><span class=p>,</span>
<span class=w>    </span><span class=n>email</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>EXCLUDED</span><span class=p>.</span><span class=n>email</span><span class=p>;</span>
</code></pre></div> <h3 id=_12>返回数据<a class=headerlink href=#_12 title="Permanent link">&para;</a></h3> <p>MySQL 对于 SQL 语句执行结果报文通常分为两类 Resultset 和 OK/ERR，针对 DML 语句则返回 OK/ERR 报文，其中包括几个影响记录，扫描记录等属性。类似 PostgreSQL/Oracle 都提供了<code>returning clause</code>支持 DML(INSERT/UPDATE/DELETE) 后跟 <code>RETURNING</code> 子句返回 Resultset。</p> <p>在某些使用场景下，需要在<code>DML</code>操作后返回刚操作的数据行。实现这个需求一般有两种办法：</p> <ul> <li> <p>一是在开启事务后在<code>DML</code>语句后紧跟一条 SELECT 语句。</p> </li> <li> <p>二是使用触发器等较为复杂的操作实现。</p> </li> </ul> <p>前者主要会增加一条 SELECT 语句的开销，后者则会令 SQL 的实现变得更加复杂并且不够灵活（需要创建触发器）。 因此，RETURNING 语法的设计主要针对该场景的优化，通过在 DML 语句后增加 RETURNING 关键字可以灵活高效地实现上述的需求。</p> <div class=highlight><pre><span></span><code><span class=c1>--PostgreSQL</span>
<span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>users</span><span class=w> </span><span class=p>(</span><span class=n>firstname</span><span class=w> </span><span class=nb>text</span><span class=p>,</span><span class=w> </span><span class=n>lastname</span><span class=w> </span><span class=nb>text</span><span class=p>,</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=nb>serial</span><span class=w> </span><span class=k>primary</span><span class=w> </span><span class=k>key</span><span class=p>);</span>

<span class=k>INSERT</span><span class=w> </span><span class=k>INTO</span><span class=w> </span><span class=n>users</span><span class=w> </span><span class=p>(</span><span class=n>firstname</span><span class=p>,</span><span class=w> </span><span class=n>lastname</span><span class=p>)</span><span class=w> </span><span class=k>VALUES</span><span class=w> </span><span class=p>(</span><span class=s1>&#39;Joe&#39;</span><span class=p>,</span><span class=w> </span><span class=s1>&#39;Cool&#39;</span><span class=p>)</span><span class=w> </span><span class=n>RETURNING</span><span class=w> </span><span class=n>id</span><span class=p>;</span>


<span class=k>UPDATE</span><span class=w> </span><span class=n>products</span><span class=w> </span><span class=k>SET</span><span class=w> </span><span class=n>price</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>price</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=mi>1</span><span class=p>.</span><span class=mi>10</span>
<span class=w>  </span><span class=k>WHERE</span><span class=w> </span><span class=n>price</span><span class=w> </span><span class=o>&lt;=</span><span class=w> </span><span class=mi>99</span><span class=p>.</span><span class=mi>99</span>
<span class=w>  </span><span class=n>RETURNING</span><span class=w> </span><span class=n>name</span><span class=p>,</span><span class=w> </span><span class=n>price</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=n>new_price</span><span class=p>;</span>

<span class=k>DELETE</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>products</span>
<span class=w>  </span><span class=k>WHERE</span><span class=w> </span><span class=n>obsoletion_date</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s1>&#39;today&#39;</span>
<span class=w>  </span><span class=n>RETURNING</span><span class=w> </span><span class=o>*</span><span class=p>;</span>
</code></pre></div> <p>使用 RETURNING 可以避免执行额外的数据库查询来收集数据，并且在否则难以可靠地识别修改的行时尤其有用。</p> <div class=highlight><pre><span></span><code><span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>users</span><span class=w> </span><span class=p>(</span>
<span class=w>    </span><span class=n>firstname</span><span class=w> </span><span class=nb>text</span><span class=p>,</span>
<span class=w>    </span><span class=n>lastname</span><span class=w> </span><span class=nb>text</span><span class=p>,</span>
<span class=w>    </span><span class=n>id</span><span class=w> </span><span class=nb>serial</span><span class=w> </span><span class=k>primary</span><span class=w> </span><span class=k>key</span>
<span class=p>);</span>

<span class=c1>-- 在INSERT INTO或者UPDATE的时候在最后面加上RETURNING colname，PostgreSQL会在插入或者更新数据之后会返回你指定的字段。</span>
<span class=c1>-- 当使用 serial列来提供唯一标识符时， RETURNING可以返回分配给新行的ID：</span>
<span class=k>INSERT</span><span class=w> </span><span class=k>INTO</span><span class=w> </span><span class=n>users</span><span class=w> </span><span class=p>(</span><span class=n>firstname</span><span class=p>,</span><span class=w> </span><span class=n>lastname</span><span class=p>)</span><span class=w> </span><span class=k>VALUES</span><span class=w> </span><span class=p>(</span><span class=s1>&#39;Joe&#39;</span><span class=p>,</span><span class=w> </span><span class=s1>&#39;Cool&#39;</span><span class=p>)</span><span class=w> </span><span class=n>RETURNING</span><span class=w> </span><span class=n>id</span><span class=p>;</span>
</code></pre></div> <h3 id=_13>外键约束与级联操作<a class=headerlink href=#_13 title="Permanent link">&para;</a></h3> <p>如果 DML 语句违反了外键约束，数据库会返回错误并取消数据操作。例如：</p> <div class=highlight><pre><span></span><code><span class=c1>-- 违反外键约束，职位不存在</span>
<span class=k>INSERT</span><span class=w> </span><span class=k>INTO</span><span class=w> </span><span class=n>employee</span><span class=w> </span><span class=p>(</span><span class=n>emp_name</span><span class=p>,</span><span class=w> </span><span class=n>sex</span><span class=p>,</span><span class=w> </span><span class=n>dept_id</span><span class=p>,</span><span class=w> </span><span class=n>manager</span><span class=p>,</span><span class=w> </span><span class=n>hire_date</span><span class=p>,</span>
<span class=w>                      </span><span class=n>job_id</span><span class=p>,</span><span class=w> </span><span class=n>salary</span><span class=p>,</span><span class=w> </span><span class=n>bonus</span><span class=p>,</span><span class=w> </span><span class=n>email</span><span class=p>,</span><span class=w> </span><span class=n>comments</span><span class=p>,</span>
<span class=w>                      </span><span class=n>create_by</span><span class=p>,</span><span class=w> </span><span class=n>create_ts</span><span class=p>,</span><span class=w> </span><span class=n>update_by</span><span class=p>,</span><span class=w> </span><span class=n>update_ts</span><span class=p>)</span>
<span class=k>VALUES</span><span class=w> </span><span class=p>(</span><span class=s1>&#39;马超&#39;</span><span class=p>,</span><span class=w> </span><span class=s1>&#39;男&#39;</span><span class=p>,</span><span class=w> </span><span class=mi>5</span><span class=p>,</span><span class=w> </span><span class=mi>18</span><span class=p>,</span><span class=w> </span><span class=k>CURRENT_DATE</span><span class=p>,</span><span class=w> </span><span class=c1>-- Microsoft SQL Server 需要替换该函数</span>
<span class=w>        </span><span class=mi>11</span><span class=p>,</span><span class=w> </span><span class=mi>6000</span><span class=p>,</span><span class=w> </span><span class=k>NULL</span><span class=p>,</span><span class=w> </span><span class=s1>&#39;machao@shuguo.com&#39;</span><span class=p>,</span><span class=w> </span><span class=k>NULL</span><span class=p>,</span>
<span class=w>        </span><span class=s1>&#39;Admin&#39;</span><span class=p>,</span><span class=w> </span><span class=k>CURRENT_TIMESTAMP</span><span class=p>,</span><span class=w> </span><span class=k>NULL</span><span class=p>,</span><span class=w> </span><span class=k>NULL</span><span class=p>);</span>
</code></pre></div> <p>以上语句在插入数据时违反了外键约束，因为 job_id=11 的记录在 job 表中不存在，我们不能给员工分配一个不存在的职位。</p> <h3 id=_14>查询基础<a class=headerlink href=#_14 title="Permanent link">&para;</a></h3> <p>从表中选取筛选数据，需要使用 SELECT 语句，也就是用表中选出 SELECT 必要数据的意思。通过 SELECT 语句查询并选取必要数据的过程称为查询（query）</p> <div class=highlight><pre><span></span><code><span class=c1>-- 查询语句的基本结构</span>

<span class=k>select</span><span class=w> </span><span class=n>A1</span><span class=p>,</span><span class=n>A2</span><span class=p>,</span><span class=n>A3</span><span class=w> </span><span class=p>...</span><span class=w> </span><span class=n>An</span>
<span class=k>from</span><span class=w> </span><span class=n>r1</span><span class=p>,</span><span class=n>r2</span><span class=p>,</span><span class=n>r3</span><span class=w> </span><span class=p>...</span><span class=w> </span><span class=n>rn</span>
<span class=k>where</span><span class=w> </span><span class=n>P</span>

<span class=c1>-- 注意：这个方法只是用来理解SQL语句的查询结果</span>
<span class=c1>-- from 多个关系后，可以理解为所有关系的笛卡尔积</span>
<span class=c1>-- 谓词P对关系进行过滤</span>
<span class=c1>-- 再从 select 中提取需要的列</span>
<span class=c1>-- 实际上，组成笛卡尔积的时候，会尽可能先执行谓词过滤一些数据后，再进行笛卡尔积</span>
</code></pre></div> <h3 id=sql_5>SQL 查询语句的执行过程<a class=headerlink href=#sql_5 title="Permanent link">&para;</a></h3> <p>在编写了大量 SQL 脚本之后，您可能会在性能方面达到某种形式的平台期。您使用相同的策略提取见解并遇到相同类型的错误。</p> <p>幸运的是，您可以通过花时间了解如何评估 SQL 中的子句来改善编写查询的体验。在这里，我们讨论 SQL 中的执行顺序并解释它的重要性。</p> <p><strong>执行顺序</strong>：SQL 查询在评估子句时遵循特定的顺序，类似于数学运算遵循 PEMDAS 或 BIDMAS 的方式。</p> <p>从用户的角度来看，查询从第一个子句开始，到最后一个子句结束。但是，查询实际上并不是在执行时从上到下读取的。</p> <p>查询中子句的执行顺序如下：</p> <ol> <li> <p>FROM/JOIN：首先执行 FROM 和/或 JOIN 子句以确定感兴趣的数据。</p> </li> <li> <p>查询执行从 FROM 子句开始。在此步骤中，数据库系统访问 FROM 子句中指定的表并在它们之间执行任何必要的连接。联接根据指定的联接条件合并来自不同表的相关行。此步骤检索将用于进一步处理的初始数据集。</p> </li> <li> <p>WHERE：执行 WHERE 子句，过滤掉不满足约束条件的记录。</p> </li> <li> <p>访问和连接表后，将应用 WHERE 子句。WHERE 子句根据指定条件过滤连接表中的行。它允许您指定确定哪些行应包含在结果集中的条件。不满足条件的行将从进一步处理中剔除。</p> </li> <li> <p>GROUP BY：执行 GROUP BY 子句，根据一列或多列中的值对数据进行分组。</p> </li> <li> <p>HAVING：执行 HAVING 子句，删除创建的不满足约束的分组记录。</p> </li> <li> <p>SELECT：执行 SELECT 子句以派生所有所需的列和表达式。</p> </li> <li> <p>ORDER BY：执行 ORDER BY 子句以按升序或降序对派生值进行排序。</p> </li> <li> <p>LIMIT/OFFSET：最后，执行 LIMIT 和/或 OFFSET 子句以保留或跳过指定数量的行。</p> </li> </ol> <div class=highlight><pre><span></span><code><span class=c1>--SQL92标准</span>
<span class=k>SELECT</span><span class=w> </span><span class=k>DISTINCT</span><span class=w> </span><span class=p>...,...,...(</span><span class=err>存在聚合函数</span><span class=p>)</span>
<span class=k>FROM</span><span class=w> </span><span class=p>...,...,...(</span><span class=err>多表查询</span><span class=p>)</span>
<span class=k>WHERE</span><span class=w> </span><span class=err>多表的连接条件</span><span class=w> </span><span class=k>AND</span><span class=w> </span><span class=err>不包含聚合函数的过滤条件</span>
<span class=k>GROUP</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=p>...,...</span>
<span class=k>HAVING</span><span class=w> </span><span class=err>包含聚合函数的过滤条件</span>
<span class=k>ORDER</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=p>...,...(</span><span class=k>ASC</span><span class=o>/</span><span class=k>DESC</span><span class=p>)</span>
<span class=k>LIMIT</span><span class=w> </span><span class=p>...,...;</span>


<span class=c1>--SQL99标准</span>
<span class=k>SELECT</span><span class=w> </span><span class=k>DISTINCT</span><span class=w> </span><span class=p>...,...,...(</span><span class=err>存在聚合函数</span><span class=p>)</span><span class=w>             </span><span class=c1>---&gt;2</span>
<span class=k>FROM</span><span class=w> </span><span class=p>...</span><span class=w> </span><span class=p>(</span><span class=k>LEFT</span><span class=o>/</span><span class=k>RIGHT</span><span class=p>)</span><span class=w> </span><span class=k>JOIN</span><span class=w> </span><span class=p>...</span><span class=w> </span><span class=k>ON</span><span class=w> </span><span class=err>多表的连接条件</span><span class=w>   </span><span class=c1>---&gt;1</span>
<span class=k>WHERE</span><span class=w> </span><span class=err>不含聚合函数的过滤条件</span><span class=w>                         </span><span class=c1>---&gt;1</span>
<span class=k>GROUP</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=p>...,...</span><span class=w>                                 </span><span class=c1>---&gt;1</span>
<span class=k>HAVING</span><span class=w> </span><span class=err>包含聚合函数的过滤条件</span><span class=w>                        </span><span class=c1>---&gt;1</span>
<span class=k>ORDER</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=p>...,...(</span><span class=k>ASC</span><span class=o>/</span><span class=k>DESC</span><span class=p>)</span><span class=w>                              </span><span class=c1>---&gt;3</span>
<span class=k>LIMIT</span><span class=w> </span><span class=p>...,...;</span><span class=w>                                          </span><span class=c1>---&gt;3</span>
</code></pre></div> <h3 id=exist-in>EXIST 和 IN 查询<a class=headerlink href=#exist-in title="Permanent link">&para;</a></h3> <div class=highlight><pre><span></span><code><span class=k>SELECT</span><span class=w>  </span><span class=o>*</span>
<span class=k>FROM</span><span class=w> </span><span class=k>table_name</span>
<span class=k>WHERE</span><span class=w> </span><span class=n>col_name</span><span class=w> </span><span class=k>IN</span><span class=w> </span><span class=p>(</span><span class=n>value1</span><span class=p>,</span><span class=w> </span><span class=n>value2</span><span class=p>,...);</span>


<span class=c1>-- IN查询相当于多个 or 条件的叠加，比较好理解:等价于 where col_name=value1  or col_name=value2</span>


<span class=c1>-- 比如这样的IN查询</span>
<span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>t_user</span><span class=w> </span><span class=k>WHERE</span>
<span class=p>(</span><span class=n>first_name</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s1>&#39;first_name_1&#39;</span><span class=w> </span><span class=k>AND</span><span class=w> </span><span class=n>last_name</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s1>&#39;last_name_1&#39;</span><span class=p>)</span><span class=w> </span><span class=k>OR</span>
<span class=p>(</span><span class=n>first_name</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s1>&#39;first_name_2&#39;</span><span class=w> </span><span class=k>AND</span><span class=w> </span><span class=n>last_name</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s1>&#39;last_name_2&#39;</span><span class=p>)</span><span class=w> </span><span class=k>OR</span>
<span class=p>(</span><span class=n>first_name</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s1>&#39;first_name_3&#39;</span><span class=w> </span><span class=k>AND</span><span class=w> </span><span class=n>last_name</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s1>&#39;last_name_3&#39;</span><span class=p>)</span><span class=w> </span><span class=k>OR</span>
<span class=p>(</span><span class=n>first_name</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s1>&#39;first_name_4&#39;</span><span class=w> </span><span class=k>AND</span><span class=w> </span><span class=n>last_name</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s1>&#39;last_name_4&#39;</span><span class=p>)</span><span class=w> </span><span class=k>OR</span>
<span class=p>(</span><span class=n>first_name</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s1>&#39;first_name_5&#39;</span><span class=w> </span><span class=k>AND</span><span class=w> </span><span class=n>last_name</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s1>&#39;last_name_5&#39;</span><span class=p>)</span><span class=w> </span><span class=k>OR</span>
<span class=p>(</span><span class=n>first_name</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s1>&#39;first_name_6&#39;</span><span class=w> </span><span class=k>AND</span><span class=w> </span><span class=n>last_name</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s1>&#39;last_name_6&#39;</span><span class=p>)</span><span class=w> </span><span class=k>OR</span>
<span class=p>(</span><span class=n>first_name</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s1>&#39;first_name_7&#39;</span><span class=w> </span><span class=k>AND</span><span class=w> </span><span class=n>last_name</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s1>&#39;last_name_7&#39;</span><span class=p>);</span>

<span class=c1>-- MySQL还支持多列IN查询</span>
<span class=c1>-- PostgreSQL 同样也支持多列 IN 查询，在官方文档中，这种形式被称为&quot;行构造器&quot;，参见：PostgreSQL子查询表达式 。其多列查询的语法和 MySQL 相同</span>
<span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>t_user</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=p>(</span><span class=n>first_name</span><span class=p>,</span><span class=n>last_name</span><span class=p>)</span><span class=w> </span><span class=k>IN</span><span class=w> </span><span class=p>(</span>
<span class=w>    </span><span class=p>(</span><span class=s1>&#39;first_name_1&#39;</span><span class=p>,</span><span class=s1>&#39;last_name_1&#39;</span><span class=p>),</span>
<span class=w>    </span><span class=p>(</span><span class=s1>&#39;first_name_2&#39;</span><span class=p>,</span><span class=s1>&#39;last_name_2&#39;</span><span class=p>),</span>
<span class=w>    </span><span class=p>(</span><span class=s1>&#39;first_name_3&#39;</span><span class=p>,</span><span class=s1>&#39;last_name_3&#39;</span><span class=p>),</span>
<span class=w>    </span><span class=p>(</span><span class=s1>&#39;first_name_4&#39;</span><span class=p>,</span><span class=s1>&#39;last_name_4&#39;</span><span class=p>),</span>
<span class=w>    </span><span class=p>(</span><span class=s1>&#39;first_name_5&#39;</span><span class=p>,</span><span class=s1>&#39;last_name_5&#39;</span><span class=p>),</span>
<span class=w>    </span><span class=p>(</span><span class=s1>&#39;first_name_6&#39;</span><span class=p>,</span><span class=s1>&#39;last_name_6&#39;</span><span class=p>),</span>
<span class=w>    </span><span class=p>(</span><span class=s1>&#39;first_name_7&#39;</span><span class=p>,</span><span class=s1>&#39;last_name_7&#39;</span><span class=p>)</span>
<span class=p>);</span>

<span class=c1>-- IN查询的子条件返回字段，必须跟查找字段数量一致</span>
<span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>db_ftstat_smart</span><span class=p>.</span><span class=n>dm_org_base_latest</span><span class=w> </span><span class=k>WHERE</span>
<span class=w>       </span><span class=p>(</span><span class=n>org_id</span><span class=p>,</span><span class=n>org_code</span><span class=p>)</span><span class=w> </span><span class=k>IN</span>
<span class=p>(</span><span class=k>SELECT</span><span class=w> </span><span class=n>org_id</span><span class=p>,</span><span class=n>org_code</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>db_ftstat_smart</span><span class=p>.</span><span class=n>dm_org_cas_stat</span><span class=w> </span><span class=p>)</span><span class=w> </span><span class=p>;</span>

<span class=c1>-- 总的来说，in查询就是先将子查询条件的记录全都查出来，假设结果集为B，共有m条记录，然后再将子查询条件的结果集分解成m个，再进行m次查询。</span>

<span class=c1>-- 查找拥有员工的部门：三种方法</span>
<span class=k>SELECT</span><span class=w> </span><span class=o>*</span>
<span class=k>FROM</span><span class=w> </span><span class=n>department</span><span class=w> </span><span class=n>d</span>
<span class=k>WHERE</span><span class=w> </span><span class=k>EXISTS</span><span class=w> </span><span class=p>(</span><span class=k>SELECT</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>employee</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>dept_id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>d</span><span class=p>.</span><span class=n>dept_id</span><span class=p>);</span>

<span class=k>SELECT</span><span class=w> </span><span class=o>*</span>
<span class=k>FROM</span><span class=w> </span><span class=n>department</span><span class=w> </span><span class=n>d</span>
<span class=k>WHERE</span><span class=w> </span><span class=n>dept_id</span><span class=w> </span><span class=k>IN</span><span class=w> </span><span class=p>(</span><span class=k>SELECT</span><span class=w> </span><span class=n>dept_id</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>employee</span><span class=p>);</span>

<span class=k>SELECT</span><span class=w> </span><span class=o>*</span>
<span class=k>FROM</span><span class=w> </span><span class=n>department</span><span class=w> </span><span class=n>d</span>
<span class=k>WHERE</span><span class=w> </span><span class=n>dept_id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>ANY</span><span class=w> </span><span class=p>(</span><span class=k>SELECT</span><span class=w> </span><span class=n>dept_id</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>employee</span><span class=p>);</span>
</code></pre></div> <p>"所有的 x 都满足条件 P" 或者 "存在（至少一个）满足条件 P 的 x"，前者称为："全称量词"，后者称为"存在量词"，分别记作 ∀（A 的下倒）、∃（E 的左倒）。</p> <p>SQL 中的 <code>EXISTS</code> 谓词实现了谓词逻辑中的存在量词，然而遗憾的是，SQL 却并没有实现全称量词。</p> <p>但是没有全称量词并不算是 SQL 的致命缺陷，因为全称量词和存在量词只要定义了一个，另一个就可以被推导出来。</p> <p>EXISTS 运算符用于判断子查询结果的存在性。只要子查询返回了任何结果，就表示满足查询条件；如果子查询没有返回任何结果，就表示不满足查询条件。</p> <p>在 SQL 中，为了表达全称量化，需要将 "所有的行都满足条件 P" 这样的命题转换成 "不存在不满足条件 P 的行"</p> <div class=highlight><pre><span></span><code><span class=c1>-- 学生成绩表</span>
<span class=k>DROP</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=k>IF</span><span class=w> </span><span class=k>EXISTS</span><span class=w> </span><span class=n>tbl_student_score</span><span class=p>;</span>
<span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>tbl_student_score</span><span class=w> </span><span class=p>(</span>
<span class=w>  </span><span class=n>id</span><span class=w> </span><span class=nb>INT</span><span class=p>(</span><span class=mi>8</span><span class=p>)</span><span class=w> </span><span class=n>unsigned</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=w> </span><span class=n>AUTO_INCREMENT</span><span class=w> </span><span class=k>COMMENT</span><span class=w> </span><span class=s1>&#39;自增主键&#39;</span><span class=p>,</span>
<span class=w>  </span><span class=n>sno</span><span class=w> </span><span class=nb>VARCHAR</span><span class=p>(</span><span class=mi>12</span><span class=p>)</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=w> </span><span class=k>COMMENT</span><span class=w> </span><span class=s1>&#39;学号&#39;</span><span class=p>,</span>
<span class=w>    </span><span class=n>subject</span><span class=w> </span><span class=nb>VARCHAR</span><span class=p>(</span><span class=mi>5</span><span class=p>)</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=w> </span><span class=k>COMMENT</span><span class=w> </span><span class=s1>&#39;课程&#39;</span><span class=p>,</span>
<span class=w>    </span><span class=n>score</span><span class=w> </span><span class=n>TINYINT</span><span class=p>(</span><span class=mi>3</span><span class=p>)</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=w> </span><span class=k>COMMENT</span><span class=w> </span><span class=s1>&#39;分数&#39;</span><span class=p>,</span>
<span class=w>  </span><span class=k>PRIMARY</span><span class=w> </span><span class=k>KEY</span><span class=w> </span><span class=p>(</span><span class=n>id</span><span class=p>)</span>
<span class=p>);</span>
<span class=k>INSERT</span><span class=w> </span><span class=k>INTO</span><span class=w> </span><span class=n>tbl_student_score</span><span class=p>(</span><span class=n>sno</span><span class=p>,</span><span class=n>subject</span><span class=p>,</span><span class=n>score</span><span class=p>)</span><span class=w> </span><span class=k>VALUES</span>
<span class=p>(</span><span class=s1>&#39;20190607001&#39;</span><span class=p>,</span><span class=s1>&#39;数学&#39;</span><span class=p>,</span><span class=mi>100</span><span class=p>),</span>
<span class=p>(</span><span class=s1>&#39;20190607001&#39;</span><span class=p>,</span><span class=s1>&#39;语文&#39;</span><span class=p>,</span><span class=mi>80</span><span class=p>),</span>
<span class=p>(</span><span class=s1>&#39;20190607001&#39;</span><span class=p>,</span><span class=s1>&#39;物理&#39;</span><span class=p>,</span><span class=mi>80</span><span class=p>),</span>
<span class=p>(</span><span class=s1>&#39;20190608003&#39;</span><span class=p>,</span><span class=s1>&#39;数学&#39;</span><span class=p>,</span><span class=mi>80</span><span class=p>),</span>
<span class=p>(</span><span class=s1>&#39;20190608003&#39;</span><span class=p>,</span><span class=s1>&#39;语文&#39;</span><span class=p>,</span><span class=mi>95</span><span class=p>),</span>
<span class=p>(</span><span class=s1>&#39;20190609006&#39;</span><span class=p>,</span><span class=s1>&#39;数学&#39;</span><span class=p>,</span><span class=mi>40</span><span class=p>),</span>
<span class=p>(</span><span class=s1>&#39;20190609006&#39;</span><span class=p>,</span><span class=s1>&#39;语文&#39;</span><span class=p>,</span><span class=mi>90</span><span class=p>),</span>
<span class=p>(</span><span class=s1>&#39;20190610011&#39;</span><span class=p>,</span><span class=s1>&#39;数学&#39;</span><span class=p>,</span><span class=mi>80</span><span class=p>);</span>

<span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>tbl_student_score</span><span class=p>;</span>


<span class=c1>-- 查询出&quot;所有科目分数都在 50 分以上的学生&quot;</span>
<span class=c1>-- 20190607001、20190608003、20190610011 这三个学生满足条件，我们需要将这 3 个学生查出来</span>

<span class=c1>-- 将查询条件“所有科目分数都在 50 分以上” 转换成它的双重否定 “没有一个科目分数不满 50 分”，然后用 NOT EXISTS 来表示转换后的命题</span>

<span class=c1>-- 没有一个科目分数不满 50 分</span>
<span class=k>SELECT</span><span class=w> </span><span class=k>DISTINCT</span><span class=w> </span><span class=n>sno</span>
<span class=k>FROM</span><span class=w> </span><span class=n>tbl_student_score</span><span class=w> </span><span class=n>tss1</span>
<span class=k>WHERE</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>EXISTS</span><span class=w> </span><span class=c1>-- 不存在满足以下条件的行</span>
<span class=p>(</span><span class=w>    </span><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>tbl_student_score</span><span class=w> </span><span class=n>tss2</span>
<span class=w>    </span><span class=k>WHERE</span><span class=w> </span><span class=n>tss2</span><span class=p>.</span><span class=n>sno</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>tss1</span><span class=p>.</span><span class=n>sno</span>
<span class=w>    </span><span class=k>AND</span><span class=w> </span><span class=n>tss2</span><span class=p>.</span><span class=n>score</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=mi>50</span><span class=w>    </span><span class=c1>-- 分数不满50 分的科目</span>
<span class=p>);</span>
</code></pre></div> <p>在使用 IN 和 NOT IN 时是无法选取出 NULL 数据的。</p> <p>实际结果也是如此，NULL 终究还是需要使用 IS NULL 和 IS NOT NULL 来进行判断。</p> <h3 id=with-cte>WITH 查询（CTE）<a class=headerlink href=#with-cte title="Permanent link">&para;</a></h3> <p>由于业务的客观复杂性，有时候会写出长达 2000 行的单条 SQL 语句，其中包含大量的聚合和多层子查询嵌套，维护此类 SQL 堪称开发人员的噩梦。</p> <p>CTE 通用表达式(Common table expression)简称 CTE，由 SQL:1999 标准引入。它是一种更加便捷的复用查询结果的方法。</p> <p>它可以极大提升开发人员和 DBA 编写复杂业务逻辑 SQL 的效率，增强代码的可维护性。</p> <p>可以认为是在单个 SELECT、INSERT、UPDATE、DELETE 或 CREATE VIEW 语句的执行范围内定义的临时结果集。</p> <p>CTE 与派生表类似，具体表现在不存储为对象，并且只在查询期间有效。与派生表的不同之处在于，CTE 可自引用，还可在同一查询中引用多次。</p> <p>在使用编程语言时，我们通常会定义一些变量和函数（方法）。变量可以被重复使用；函数（方法）可以将代码模块化，从而提高程序的可读性与可维护性。</p> <p>与此类似，SQL 中的通用表表达式也能够实现查询结果的模块化和重复利用，简化复杂的连接查询和子查询。</p> <div class=highlight><pre><span></span><code><span class=c1>--CTE语句如下</span>
<span class=c1>-- cte_name 指定了 CTE 的名称，后面是可选的字段名。</span>
<span class=c1>-- AS关键字后面的子查询是CTE 的定义语句，定义了它的表结构和数据。</span>
<span class=c1>-- 最后的 SELECT 是主查询语句，它可以引用前面定义的 CTE。除了 SELECT 之外，主查询语句也可以是 INSERT、UPDAT 或 DELETE 等。</span>

<span class=k>WITH</span><span class=w> </span><span class=n>cte_name</span><span class=p>(</span><span class=n>col1</span><span class=p>,</span><span class=w> </span><span class=n>col2</span><span class=p>,</span><span class=w> </span><span class=p>...)</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=p>(</span>
<span class=w> </span><span class=n>subquery</span>
<span class=p>)</span>
<span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>cte_name</span><span class=p>;</span>

<span class=k>WITH</span>
<span class=w>  </span><span class=n>cte1</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=p>(</span><span class=k>SELECT</span><span class=w> </span><span class=n>a</span><span class=p>,</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>table1</span><span class=p>),</span>
<span class=w>  </span><span class=n>cte2</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=p>(</span><span class=k>SELECT</span><span class=w> </span><span class=k>c</span><span class=p>,</span><span class=w> </span><span class=n>d</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>table2</span><span class=p>)</span>
<span class=k>SELECT</span><span class=w> </span><span class=n>b</span><span class=p>,</span><span class=w> </span><span class=n>d</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>cte1</span><span class=w> </span><span class=k>JOIN</span><span class=w> </span><span class=n>cte2</span>
<span class=k>WHERE</span><span class=w> </span><span class=n>cte1</span><span class=p>.</span><span class=n>a</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>cte2</span><span class=p>.</span><span class=k>c</span><span class=p>;</span>



<span class=c1>-- 列表中的名称数量必须与查询结果中的字段数量相同</span>
<span class=k>WITH</span><span class=w> </span><span class=n>cte</span><span class=w> </span><span class=p>(</span><span class=n>col1</span><span class=p>,</span><span class=w> </span><span class=n>col2</span><span class=p>)</span><span class=w> </span><span class=k>AS</span>
<span class=p>(</span>
<span class=w>  </span><span class=k>SELECT</span><span class=w> </span><span class=mi>1</span><span class=p>,</span><span class=w> </span><span class=mi>2</span>
<span class=w>  </span><span class=k>UNION</span><span class=w> </span><span class=k>ALL</span>
<span class=w>  </span><span class=k>SELECT</span><span class=w> </span><span class=mi>3</span><span class=p>,</span><span class=w> </span><span class=mi>4</span>
<span class=p>)</span>
<span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>cte</span><span class=p>;</span>


<span class=c1>-- 子查询的CTE写法</span>
<span class=c1>-- CTE 将子查询的结果集用 with 语句提到最前面，取一个别名，再在后面的语句中使用</span>
<span class=k>with</span><span class=w> </span><span class=n>derived</span><span class=p>(...)</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=p>(</span>
<span class=w>    </span><span class=n>subquery</span>
<span class=p>)</span>
<span class=k>select</span><span class=w> </span><span class=p>...</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=n>derived</span><span class=p>,</span><span class=w> </span><span class=n>table_name1</span><span class=w> </span><span class=err>……</span><span class=p>;</span>


<span class=c1>-- CTE 可以引用其他CTE</span>
<span class=k>with</span><span class=w> </span><span class=n>derived_one</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=p>(</span>
<span class=w>    </span><span class=n>subquery</span>
<span class=p>),</span>
<span class=n>derived_two</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=p>(</span>
<span class=w>    </span><span class=k>select</span><span class=w> </span><span class=err>……</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=n>derived_one</span>
<span class=p>)</span>
<span class=k>select</span><span class=w> </span><span class=err>……</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=n>derived_one</span><span class=p>,</span><span class=w> </span><span class=n>derived_two</span><span class=w> </span><span class=err>……</span><span class=p>;</span>

<span class=c1>-- 在同一个语句级别中只允许存在一个WITH子句，有效的语法格式是为一个WITH子句定义多个从句，使用逗号进行分隔：</span>
<span class=c1>-- 在包含WITH子句的查询中，可以使用CTE的名称访问相应 CTE 的结果集。</span>
<span class=c1>-- 前面定义的CTE可以在其他的CTE中进行引用，因此 CTE 可以基于前面的 CTE 进行定义。</span>
<span class=c1>-- 引用自己的 CTE 被称为递归 CTE。递归 CTE 的使用场景包括生成序列，遍历层次数据或树状结构的数据。</span>
<span class=c1>-- 通用表表达式属于 DML 语句的可选部分。</span>




<span class=c1>--找出预算值最大的系:系名，预算</span>
<span class=c1>-- 方法一</span>
<span class=k>select</span><span class=w> </span><span class=n>dept_name</span><span class=w> </span><span class=p>,</span><span class=w> </span><span class=n>budget</span>
<span class=w> </span><span class=k>from</span><span class=w> </span><span class=n>department</span><span class=w> </span><span class=p>,</span>
<span class=w> </span><span class=p>(</span><span class=k>SELECT</span><span class=w> </span><span class=k>max</span><span class=p>(</span><span class=w> </span><span class=n>budget</span><span class=w> </span><span class=p>)</span><span class=k>as</span><span class=w> </span><span class=n>budget</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>department</span><span class=p>)</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=n>max_budget</span>

<span class=w>   </span><span class=k>where</span><span class=w> </span><span class=n>department</span><span class=p>.</span><span class=n>budget</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>max_budget</span><span class=p>.</span><span class=n>budget</span>


<span class=c1>-- 先用with语句查出一个临时表 max_budget ( VALUE )，</span>
<span class=err>这里面存了所有系里面的最大的预算值。再将这个表与系表关联查询</span>
<span class=k>WITH</span><span class=w> </span><span class=n>max_budget</span><span class=w> </span><span class=p>(</span><span class=n>value</span><span class=p>)</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=p>(</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=k>max</span><span class=p>(</span><span class=w> </span><span class=n>budget</span><span class=w> </span><span class=p>)</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>department</span><span class=w> </span><span class=p>)</span><span class=w> </span><span class=k>SELECT</span>
<span class=n>budget</span>
<span class=k>FROM</span>
<span class=w>    </span><span class=n>department</span><span class=p>,</span>
<span class=w>    </span><span class=n>max_budget</span>
<span class=k>WHERE</span>
<span class=w>    </span><span class=n>department</span><span class=p>.</span><span class=n>budget</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>max_budget</span><span class=p>.</span><span class=n>value</span>
</code></pre></div> <p><strong>CTE 相较于派生表有 4 个明显的优势：</strong></p> <ul> <li>更好的可读性</li> </ul> <div class=highlight><pre><span></span><code><span class=w>    </span><span class=k>SELECT</span><span class=w> </span><span class=p>...</span>
<span class=w>    </span><span class=k>FROM</span><span class=w> </span><span class=n>t1</span><span class=w> </span><span class=k>LEFT</span><span class=w> </span><span class=k>JOIN</span><span class=w> </span><span class=p>((</span><span class=k>SELECT</span><span class=w> </span><span class=p>...</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=p>...)</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=n>dt</span><span class=w> </span><span class=k>JOIN</span><span class=w> </span><span class=n>t2</span><span class=w> </span><span class=k>ON</span><span class=w> </span><span class=p>...)</span><span class=w> </span><span class=k>ON</span><span class=w> </span><span class=p>...</span>


<span class=w>    </span><span class=k>WITH</span><span class=w> </span><span class=n>dt</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=p>(</span><span class=k>SELECT</span><span class=w> </span><span class=p>...</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=p>...)</span>
<span class=w>    </span><span class=k>SELECT</span><span class=w> </span><span class=p>...</span>
<span class=w>    </span><span class=k>FROM</span><span class=w> </span><span class=n>t1</span><span class=w> </span><span class=k>LEFT</span><span class=w> </span><span class=k>JOIN</span><span class=w> </span><span class=p>(</span><span class=n>dt</span><span class=w> </span><span class=k>JOIN</span><span class=w> </span><span class=n>t2</span><span class=w> </span><span class=k>ON</span><span class=w> </span><span class=p>...)</span><span class=w> </span><span class=k>ON</span><span class=w> </span><span class=p>...</span>
</code></pre></div> <p>​</p> <ul> <li>可以被多次引用</li> </ul> <div class=highlight><pre><span></span><code><span class=w>    </span><span class=c1>-- 传统派生表子查询写法：每个子查询都要写完成SQL</span>

<span class=w>    </span><span class=k>SELECT</span><span class=w> </span><span class=p>...</span>
<span class=w>    </span><span class=k>FROM</span><span class=w> </span><span class=p>(</span><span class=k>SELECT</span><span class=w> </span><span class=n>a</span><span class=p>,</span><span class=w> </span><span class=n>b</span><span class=p>,</span><span class=w> </span><span class=k>SUM</span><span class=p>(</span><span class=k>c</span><span class=p>)</span><span class=w> </span><span class=n>s</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>t1</span><span class=w> </span><span class=k>GROUP</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>a</span><span class=p>,</span><span class=w> </span><span class=n>b</span><span class=p>)</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=n>d1</span>
<span class=w>    </span><span class=k>JOIN</span><span class=w> </span><span class=p>(</span><span class=k>SELECT</span><span class=w> </span><span class=n>a</span><span class=p>,</span><span class=w> </span><span class=n>b</span><span class=p>,</span><span class=w> </span><span class=k>SUM</span><span class=p>(</span><span class=k>c</span><span class=p>)</span><span class=w> </span><span class=n>s</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>t1</span><span class=w> </span><span class=k>GROUP</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>a</span><span class=p>,</span><span class=w> </span><span class=n>b</span><span class=p>)</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=n>d2</span><span class=w> </span><span class=k>ON</span><span class=w> </span><span class=n>d1</span><span class=p>.</span><span class=n>b</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>d2</span><span class=p>.</span><span class=n>a</span><span class=p>;</span>

<span class=w>    </span><span class=c1>-- CTE写法：一次生成，多次引用</span>

<span class=w>    </span><span class=k>WITH</span><span class=w> </span><span class=n>d</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=p>(</span><span class=k>SELECT</span><span class=w> </span><span class=n>a</span><span class=p>,</span><span class=w> </span><span class=n>b</span><span class=p>,</span><span class=w> </span><span class=k>SUM</span><span class=p>(</span><span class=k>c</span><span class=p>)</span><span class=w> </span><span class=n>s</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>t1</span><span class=w> </span><span class=k>GROUP</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>a</span><span class=p>,</span><span class=w> </span><span class=n>b</span><span class=p>)</span>
<span class=w>    </span><span class=k>SELECT</span><span class=w> </span><span class=p>...</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>d</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=n>d1</span><span class=w> </span><span class=k>JOIN</span><span class=w> </span><span class=n>d</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=n>d2</span><span class=w> </span><span class=k>ON</span><span class=w> </span><span class=n>d1</span><span class=p>.</span><span class=n>b</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>d2</span><span class=p>.</span><span class=n>a</span><span class=p>;</span>
</code></pre></div> <p>​</p> <ul> <li>可以引用其他的 CTE</li> </ul> <div class=highlight><pre><span></span><code><span class=w>    </span><span class=c1>-- 传统这种不行，会报表不存在，要用更复杂的子查询</span>
<span class=w>    </span><span class=k>SELECT</span><span class=w> </span><span class=p>...</span>
<span class=w>    </span><span class=k>FROM</span><span class=w> </span><span class=p>(</span><span class=k>SELECT</span><span class=w> </span><span class=p>...</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=p>...)</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=n>d1</span><span class=p>,</span><span class=w> </span><span class=p>(</span><span class=k>SELECT</span><span class=w> </span><span class=p>...</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>d1</span><span class=w> </span><span class=p>...)</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=n>d2</span><span class=w> </span><span class=p>...</span>


<span class=w>    </span><span class=c1>-- 派生表写法</span>
<span class=w>    </span><span class=k>WITH</span><span class=w> </span><span class=n>d1</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=p>(</span><span class=k>SELECT</span><span class=w> </span><span class=p>...</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=p>...),</span>
<span class=w>    </span><span class=n>d2</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=p>(</span><span class=k>SELECT</span><span class=w> </span><span class=p>...</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>d1</span><span class=w> </span><span class=p>...)</span>
<span class=w>    </span><span class=k>SELECT</span>
<span class=w>    </span><span class=k>FROM</span><span class=w> </span><span class=n>d1</span><span class=p>,</span><span class=w> </span><span class=n>d2</span><span class=w> </span><span class=p>...</span>
</code></pre></div> <ul> <li>性能的提升</li> </ul> <h4 id=cte>递归 CTE<a class=headerlink href=#cte title="Permanent link">&para;</a></h4> <p>递归 CTE 是一种特殊的 CTE，其子查询会引用自己的名字。</p> <p><code>WITH</code>子句必须以<code>WITH RECURSIVE</code>开头。</p> <p>递归 CTE 子查询包括两部分：<code>seed查询</code>和<code>recursive查询</code>，由<code>UNION[ALL]</code>或<code>UNION DISTINCT</code>分隔。</p> <div class=highlight><pre><span></span><code><span class=c1>-- 递归CTE ,  MySQL、PostgreSQL 以及 SQLite</span>
<span class=k>WITH</span><span class=w> </span><span class=k>RECURSIVE</span><span class=w> </span><span class=n>derived</span><span class=p>(</span><span class=n>n</span><span class=p>)</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=p>(</span>
<span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=mi>1</span>
<span class=w> </span><span class=k>UNION</span><span class=w> </span><span class=k>ALL</span>
<span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=n>n</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>derived</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>n</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=mi>5</span>
<span class=p>)</span>
<span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>derived</span><span class=p>;</span>

<span class=c1>-- 以上语句的执行结果是一个连续的数字序列：1,2,3,4,5</span>

<span class=c1>-- 如果在WITH子句中引用了自己，WITH子句必须使用WITH RECURSIVE。（如果没有 CTE 引用自己，也可以使用RECURSIVE，但不强制。）</span>

<span class=c1>-- 递归 CTE 的子查询由两部分组成，中间使用UNION [ALL]或者UNION DISTINCT进行连接：</span>

<span class=c1>-- 第一个SELECT语句用于生成初始数据行，该语句不会引用 CTE 自身。</span>
<span class=c1>-- 第二个SELECT语句在它的FROM子句中引用了 CTE自身，通过递归产生更多的结果。</span>
<span class=c1>-- 当第二个语句不会产生更多的新数据时结束递归。因此，递归 CTE由一个非递归的SELECT语句和一个递归的SELECT语句组成。</span>
<span class=c1>-- CTE最终结果中的字段类型由非递归的SELECT语句决定，所有字段都可以为空。查询结果的字段类型与递归SELECT语句无关。</span>
<span class=c1>-- 如果递归部分和非递归部分使用UNION DISTINCT进行连接，查询结果将会排除重复的数据行。</span>
<span class=c1>-- 这种方式可以用于执行传递闭包（transitive closure，例如两个地点之间的乘车路线）的查询，防止无限循环。</span>

<span class=c1>-- 递归部分的每次迭代只针对上次迭代生成的新数据行进行操作。</span>
<span class=c1>-- 如果递归部分包含多个查询块，迭代时每个查询块的执行顺序不固定，每个查询块基于它自己前一次迭代的结果，或者上次迭代结束后其他查询块生成的结果进行操作。</span>


<span class=c1>-- 前面递归 CTE 示例中的非递归语句如下，它会产生一条初始化的数据：</span>
<span class=k>SELECT</span><span class=w> </span><span class=mi>1</span>
<span class=c1>-- 它的递归部分如下：</span>
<span class=k>SELECT</span><span class=w> </span><span class=n>n</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>cte</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>n</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=mi>5</span>
<span class=c1>-- 每次迭代时，SELECT语句将会产生一个比上一次结果中的 n 大 1 的新值。</span>
<span class=c1>-- 第一次迭代基于初始值（1）进行操作，生成 1+1=2；</span>
<span class=c1>-- 第二次迭代基于第一次迭代的结果（2），生成 2+1=3；如此等等。</span>
<span class=c1>-- 迭代一直执行到递归结束，此处为 n 的值大于或等于 5。</span>
<span class=c1>-- 如果递归部分产生的结果比非递归部分的字段长度更大，需要在非递归部分指定一个更宽的字段类型，避免数据被截断。</span>



<span class=c1>-- 假设用树形结构来描述一个部门的组织架构</span>

<span class=c1>-- DDL  用id来标识一个人，用manager_id来表示向上一个人汇报</span>
<span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>db_test</span><span class=p>.</span><span class=n>employees_mgr</span><span class=w> </span><span class=p>(</span>
<span class=w>    </span><span class=n>id</span><span class=w> </span><span class=nb>INT</span><span class=w> </span><span class=k>PRIMARY</span><span class=w> </span><span class=k>KEY</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=p>,</span>
<span class=w>    </span><span class=n>name</span><span class=w> </span><span class=nb>VARCHAR</span><span class=w> </span><span class=p>(</span><span class=w> </span><span class=mi>100</span><span class=w> </span><span class=p>)</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=p>,</span>
<span class=w>    </span><span class=n>manager_id</span><span class=w> </span><span class=nb>INT</span><span class=w> </span><span class=k>NULL</span><span class=p>,</span>
<span class=w>    </span><span class=k>INDEX</span><span class=w> </span><span class=p>(</span><span class=w> </span><span class=n>manager_id</span><span class=w> </span><span class=p>),</span>
<span class=w>    </span><span class=k>FOREIGN</span><span class=w> </span><span class=k>KEY</span><span class=w> </span><span class=p>(</span><span class=w> </span><span class=n>manager_id</span><span class=w> </span><span class=p>)</span><span class=w> </span><span class=k>REFERENCES</span><span class=w> </span><span class=n>employees_mgr</span><span class=w> </span><span class=p>(</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=p>)</span>
<span class=p>);</span>


<span class=c1>-- test data</span>
<span class=k>insert</span><span class=w> </span><span class=k>into</span><span class=w> </span><span class=n>db_test</span><span class=p>.</span><span class=n>employees_mgr</span><span class=w> </span><span class=k>values</span>
<span class=p>(</span><span class=mi>333</span><span class=p>,</span><span class=w> </span><span class=ss>&quot;Yasmina&quot;</span><span class=p>,</span><span class=w> </span><span class=k>null</span><span class=p>),</span><span class=w> </span><span class=cm>/* Yasmina is the CEO (manager_id is null) */</span>
<span class=p>(</span><span class=mi>198</span><span class=p>,</span><span class=w> </span><span class=ss>&quot;John&quot;</span><span class=p>,</span><span class=w> </span><span class=mi>333</span><span class=p>),</span><span class=w>     </span><span class=cm>/* John has id 198 and reports to 333 (Yasmina) */</span>
<span class=p>(</span><span class=mi>692</span><span class=p>,</span><span class=w> </span><span class=ss>&quot;Tarek&quot;</span><span class=p>,</span><span class=w> </span><span class=mi>333</span><span class=p>),</span><span class=w>    </span><span class=cm>/* Tarek has id 692 and reports to 333 (Yasmina) */</span>
<span class=p>(</span><span class=mi>29</span><span class=p>,</span><span class=w> </span><span class=ss>&quot;Pedro &quot;</span><span class=p>,</span><span class=w> </span><span class=mi>198</span><span class=p>),</span><span class=w>    </span><span class=cm>/* Pedro has id 29 and reports to 198 (John) */</span>
<span class=p>(</span><span class=mi>4610</span><span class=p>,</span><span class=w> </span><span class=ss>&quot;Sarah&quot;</span><span class=p>,</span><span class=w> </span><span class=mi>29</span><span class=p>);</span><span class=w>    </span><span class=cm>/* Sarah has id 4610 and reports to 29 (Pedro) */</span>


<span class=c1>-- 要查询出如下这种树形结果</span>

<span class=o>+</span><span class=c1>------+---------+--------------------+</span>
<span class=o>|</span><span class=w> </span><span class=n>id</span><span class=w>   </span><span class=o>|</span><span class=w> </span><span class=n>name</span><span class=w>    </span><span class=o>|</span><span class=w> </span><span class=n>path</span><span class=w>               </span><span class=o>|</span>
<span class=o>+</span><span class=c1>------+---------+--------------------+</span>
<span class=o>|</span><span class=w>  </span><span class=mi>333</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=n>Yasmina</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=mi>333</span><span class=w>                </span><span class=o>|</span>
<span class=o>|</span><span class=w>  </span><span class=mi>198</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=n>John</span><span class=w>    </span><span class=o>|</span><span class=w> </span><span class=mi>333</span><span class=o>-&gt;</span><span class=mi>198</span><span class=w>           </span><span class=o>|</span>
<span class=o>|</span><span class=w>  </span><span class=mi>692</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=n>Tarek</span><span class=w>   </span><span class=o>|</span><span class=w> </span><span class=mi>333</span><span class=o>-&gt;</span><span class=mi>692</span><span class=w>           </span><span class=o>|</span>
<span class=o>|</span><span class=w>   </span><span class=mi>29</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=n>Pedro</span><span class=w>   </span><span class=o>|</span><span class=w> </span><span class=mi>333</span><span class=o>-&gt;</span><span class=mi>198</span><span class=o>-&gt;</span><span class=mi>29</span><span class=w>       </span><span class=o>|</span>
<span class=o>|</span><span class=w> </span><span class=mi>4610</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=n>Sarah</span><span class=w>   </span><span class=o>|</span><span class=w> </span><span class=mi>333</span><span class=o>-&gt;</span><span class=mi>198</span><span class=o>-&gt;</span><span class=mi>29</span><span class=o>-&gt;</span><span class=mi>4610</span><span class=w> </span><span class=o>|</span>
<span class=o>+</span><span class=c1>------+---------+--------------------+</span>
<span class=mi>5</span><span class=w> </span><span class=k>rows</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=k>set</span><span class=w> </span><span class=p>(</span><span class=mi>0</span><span class=p>.</span><span class=mi>00</span><span class=w> </span><span class=n>sec</span><span class=p>)</span>
<span class=n>mysql</span><span class=o>&gt;</span>


<span class=c1>-- MySQL8.0中支持with子句</span>
<span class=c1>-- 通过递归CTE来查询用户的层级关系</span>
<span class=c1>-- 规划一个ID，name，path这样的一个层级临时表</span>
<span class=w> </span><span class=k>with</span><span class=w> </span><span class=k>recursive</span><span class=w> </span><span class=n>employee_paths</span><span class=w> </span><span class=p>(</span><span class=n>id</span><span class=p>,</span><span class=w> </span><span class=n>name</span><span class=p>,</span><span class=w> </span><span class=n>path</span><span class=p>)</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=p>(</span>
<span class=w>     </span><span class=c1>--先查最顶层节点</span>
<span class=w>     </span><span class=k>select</span><span class=w> </span><span class=n>id</span><span class=p>,</span><span class=w> </span><span class=n>name</span><span class=p>,</span><span class=w> </span><span class=k>cast</span><span class=p>(</span><span class=n>id</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=nb>char</span><span class=p>(</span><span class=mi>200</span><span class=p>))</span>
<span class=w>     </span><span class=k>from</span><span class=w> </span><span class=n>db_test</span><span class=p>.</span><span class=n>employees_mgr</span>
<span class=w>     </span><span class=k>where</span><span class=w> </span><span class=n>manager_id</span><span class=w> </span><span class=k>is</span><span class=w> </span><span class=k>null</span>
<span class=w>     </span><span class=k>union</span><span class=w> </span><span class=k>all</span>
<span class=w>     </span><span class=c1>-- 递归查询</span>
<span class=w>     </span><span class=k>select</span><span class=w> </span><span class=n>e</span><span class=p>.</span><span class=n>id</span><span class=p>,</span><span class=w> </span><span class=n>e</span><span class=p>.</span><span class=n>name</span><span class=p>,</span><span class=w> </span><span class=n>concat</span><span class=p>(</span><span class=n>ep</span><span class=p>.</span><span class=n>path</span><span class=p>,</span><span class=w> </span><span class=s1>&#39;-&gt;&#39;</span><span class=p>,</span><span class=w> </span><span class=n>e</span><span class=p>.</span><span class=n>id</span><span class=p>)</span>
<span class=w>     </span><span class=k>from</span><span class=w> </span><span class=n>employee_paths</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=n>ep</span>
<span class=w>     </span><span class=k>join</span><span class=w> </span><span class=n>db_test</span><span class=p>.</span><span class=n>employees_mgr</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=n>e</span>
<span class=w>     </span><span class=k>on</span><span class=w> </span><span class=n>ep</span><span class=p>.</span><span class=n>id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>e</span><span class=p>.</span><span class=n>manager_id</span>
<span class=w>    </span><span class=p>)</span>
<span class=w>     </span><span class=k>select</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=n>employee_paths</span><span class=p>;</span>
</code></pre></div> <h3 id=_15>查询排序<a class=headerlink href=#_15 title="Permanent link">&para;</a></h3> <p>理解 SQL 最重要的一点就是要明白表不保证是有序的，因为表是为了代表一个集合（如果有重复项，则是多集），而集合是无序的。</p> <blockquote> <p>在 SQL 世界中，顺序不是一组数据的固有属性。因此，除非您使用 <code>order by</code> 子句查询您的数据，否则您无法从 <code>RDBMS</code> 保证您的数据将按特定顺序返回——甚至以一致的顺序返回。</p> </blockquote> <p>在关系模型中，所有操作和关系都基于关系代数和关系(集合)中的结果，但在<code>SQL</code>中情况略有不同，因 SELECT 查询并不保证返回一个真正的集合(即，由唯一行组成的无序集合)。</p> <p>首先，SQL 不要求表必须符合集合条件。SQL 表可以没有键，行也不一定具有唯一性，在这些情况下表都不是集合，而是多集(multiset)或包(bag)。但即使正在查询的表具有主键、也符合集合的条件，针对这个表的 SELECT 查询任然可能返回包含重复的结果。</p> <p>在描述 SELECT 查询的输出时，经常会使用结果集这个属于，不过结果集并不一定非得严格满足数学意义上的集合条件。</p> <p>如果在查询表时不指定<code>ORDER BY</code>子句，那么虽然查询可以返回一个结果表，但 MySQL Server 可以自由地按任意顺序对结果中的行进行排序。（注意，这个不一定可靠）</p> <p>为了确保结果中的行按照一定的顺序进行排序，唯一的方法就是显示地指定一个<code>ORDER BY</code>子句。</p> <p><code>SQL</code>支持多个字段进行<code>ORDER BY</code>排序，各字段之间用逗号","隔开。</p> <div class=highlight><pre><span></span><code><span class=w> </span><span class=p>[</span><span class=k>ORDER</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=err>{</span><span class=n>col_name</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=n>expr</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=k>position</span><span class=err>}</span>
<span class=w>      </span><span class=p>[</span><span class=k>ASC</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=k>DESC</span><span class=p>],</span><span class=w> </span><span class=p>...</span><span class=w> </span><span class=p>[</span><span class=k>WITH</span><span class=w> </span><span class=k>ROLLUP</span><span class=p>]]</span>
<span class=w>    </span><span class=p>[</span><span class=k>LIMIT</span><span class=w> </span><span class=err>{</span><span class=p>[</span><span class=k>offset</span><span class=p>,]</span><span class=w> </span><span class=k>row_count</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=k>row_count</span><span class=w> </span><span class=k>OFFSET</span><span class=w> </span><span class=k>offset</span><span class=err>}</span><span class=p>]</span>


<span class=c1>-- ORDER BY后面可以接列名，别名，列号（数字）、表达式、函数、分组函数等</span>
<span class=c1>-- 如果不显示指出是升序ASC还是降序DESC，则默认为是升序</span>
<span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>tablename</span><span class=w> </span><span class=k>ORDER</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>column1</span><span class=p>,</span><span class=n>column2</span><span class=p>,</span><span class=n>column3</span><span class=w> </span><span class=p>;</span>

<span class=c1>-- 如果排序字段中存在相同的数据，那么它们的排序顺序是随机的。为了进一步明确这些数据的排序顺序，可以使用多列排序。</span>
<span class=c1>-- ORDER BY column1,column2         表示：column1和column2都是升序</span>
<span class=c1>-- ORDER BY column1,column2 DESC    表示：column1升序，column2降序</span>


<span class=c1>-- ORDER BY 语句的语法糖(syntax sugar)。可以用编号 1， 2 来指定。</span>
<span class=k>SELECT</span><span class=w> </span><span class=n>id</span><span class=p>,</span><span class=w> </span><span class=n>firstname</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>students</span><span class=w> </span><span class=k>ORDER</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=mi>1</span><span class=p>,</span><span class=mi>2</span><span class=w> </span><span class=p>;</span>



<span class=c1>-- 排序的键并非一定要是某一个列，也可以是列组成的表达式。</span>
<span class=k>SELECT</span><span class=w> </span><span class=n>id</span><span class=p>,</span><span class=w> </span><span class=n>firstname</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>students</span><span class=w> </span><span class=k>ORDER</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>class_id</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=mi>1000</span><span class=w> </span><span class=o>+</span><span class=mi>10</span><span class=w>  </span><span class=p>;</span>
</code></pre></div> <h4 id=_16>空值排序<a class=headerlink href=#_16 title="Permanent link">&para;</a></h4> <p>空值（NULL）在数据库中表示未知或者缺失的数据。如果排序的字段中存在空值时，应该如何处理呢？</p> <p>不同数据库系统对于空值的排序位置采用了不同的处理方式。</p> <ul> <li>MySQL、Microsoft SQL Server 以及 SQLite 认为排序时空值最小，升序排序时空值排在最前，降序排序时空值排在最后。</li> </ul> <blockquote> <p>By default, PostgreSQL considers NULL values larger than any non-NULL value</p> </blockquote> <ul> <li>Oracle 和 PostgreSQL 认为排序时空值最大，升序排序时空值排在最后，降序排序时空值排在最前。</li> </ul> <p>Oracle、PostgreSQL 以及 SQLite 支持使用 <code>NULLS FIRST</code> 和 <code>NULLS LAST</code> 指定空值的排序位置。</p> <h4 id=_17>中文排序<a class=headerlink href=#_17 title="Permanent link">&para;</a></h4> <p>在创建数据库或者表时，我们通常会指定一个字符集和排序规则。字符集（Charset）决定了数据库能够存储哪些字符，比如 ASCII 字符集只能存储简单的英文、数字和一些控制字符，GB2312 字符集可以存储中文，Unicode 字符集能够支持世界上的各种文字。</p> <p>排序规则（Collation）定义了字符集中字符的排序顺序，包括是否区分大小写、是否区分重音等。对于中文而言，排序方式与英文有所不同，中文通常需要按照拼音、偏旁部首或者笔画进行排序。</p> <p>如果想要支持中文排序，最简单的方式就是使用支持中文排序的字符集和排序规则。如果使用的字符集和排序规则不满足我们的排序需求，可以通过其他方法实现。</p> <div class=highlight><pre><span></span><code><span class=c1>-- 对字符串类型中的中文字段排序</span>

<span class=c1>--</span>
</code></pre></div> <p>最近做项目遇到一个需求：</p> <p>对数据按照更新时间和创建时间进行综合排序，即对数据的操作时间进行排序，但是数据表中没有操作时间这个字段，需要根据更新时间和创建时间进行处理。更新时间存在时，按照更新时间排序，更新时间不存在时，使用创建时间排序，最后更新时间和创建时间一起排序。</p> <p><strong><a href=../foundmental/suoyin.md#mysql-排序优化>排序优化</a></strong></p> <p>排序是 blocking 的，实现的难点就在于内存消耗。假设输入的数据可以完全存放在内存中，那我们直接用快速排序就万事大吉了。如果还要精益求精，那就需要看如何才能减少比较和交换的次数，更有甚者，去追求 CPU register 或者 L1, L2 缓存的利用率。如果数据量太大，不能一次性全存放在内存中呢。</p> <p>这就需要用到我们上一期提到过的 <code>spill to disk</code> 技巧了：需要把数据暂存到文件系统中。这里，就引出今天提到的第一个算法：外部归并排序(external merge sort)。工程中要实现一个正确并且高效的外部归并排序是挺有挑战的，所以有些数据库系统在执行时需要消耗大量的内存或者干脆要求加入 limit 语句来限制排序数量。</p> <h3 id=_18>派生表和子查询<a class=headerlink href=#_18 title="Permanent link">&para;</a></h3> <p>在数据库中，我们经常使用子查询和派生表来进行查询。</p> <p><code>derived table</code>中文译为派生表，关于派生表的含义，翻阅了 MySQL 的官方手册，并没有找到相对应的解释，不过在 SQL92 标准中有对它进行定义。</p> <blockquote> <p>A derived table is a table derived directly or indirectly from one or more other tables by the evaluation of a <query expression>.The values of a derived table are derived from the values of the underlying tables when the <query expression> is evaluated.</p> </blockquote> <p>不同数据库对于 FROM 子句中的子查询称呼不同。例如，MySQL 称之为派生表（Derived Table），Oracle 则称之为内联视图（Inline View）。</p> <div class=highlight><pre><span></span><code><span class=c1>-- 子查询</span>
<span class=c1>-- 在另一个查询(外部查询)中嵌套另一个查询语句(内部查询)，并使用内部查询的结果值作为外部查询条件。</span>
<span class=c1>-- 子查询在where中</span>
<span class=c1>-- where条件比对的值是从其他表查出来的。</span>
<span class=c1>-- 其实不光是 where ，select 后面跟的字段名也可以是从其他表中查出来的。</span>

<span class=k>SELECT</span>
<span class=w>       </span><span class=n>customerNumber</span><span class=p>,</span><span class=w> </span><span class=n>checkNumber</span><span class=p>,</span><span class=w> </span><span class=n>amount</span>
<span class=k>FROM</span>
<span class=w>   　　 </span><span class=n>payments</span>
<span class=k>WHERE</span>
<span class=w> 　　   </span><span class=n>amount</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=k>SELECT</span><span class=w>  </span><span class=k>MAX</span><span class=p>(</span><span class=n>amount</span><span class=p>)</span><span class=w> </span><span class=n>FROMpayments</span><span class=p>);</span>


<span class=c1>-- 标量子查询 （一行一列）</span>
<span class=c1>-- 那些只返回一个单一值的子查询称之为标量子查询：子查询里面的查询结果只返回一行一列一个值的情况。</span>
<span class=c1>-- 子查询可以像常量一样被用于 SELECT、WHERE、GROUP BY、HAVING 以及 ORDER BY 等子句中。</span>
<span class=k>SELECT</span><span class=w> </span><span class=p>(</span><span class=k>SELECT</span><span class=w> </span><span class=n>m1</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>e1</span><span class=w> </span><span class=k>LIMIT</span><span class=w> </span><span class=mi>1</span><span class=p>);</span>
<span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>e1</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>m1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=k>SELECT</span><span class=w> </span><span class=k>MIN</span><span class=p>(</span><span class=n>m2</span><span class=p>)</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>e2</span><span class=p>);</span>
<span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>e1</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>m1</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=p>(</span><span class=k>SELECT</span><span class=w> </span><span class=k>MIN</span><span class=p>(</span><span class=n>m2</span><span class=p>)</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>e2</span><span class=p>);</span>

<span class=c1>-- 计算员工月薪与平均月薪之间的差值</span>
<span class=k>SELECT</span><span class=w> </span><span class=n>emp_name</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=ss>&quot;员工姓名&quot;</span><span class=p>,</span><span class=w> </span><span class=n>salary</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=ss>&quot;月薪&quot;</span><span class=p>,</span>
<span class=w>       </span><span class=n>salary</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=p>(</span><span class=k>SELECT</span><span class=w> </span><span class=k>AVG</span><span class=p>(</span><span class=n>salary</span><span class=p>)</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>employee</span><span class=p>)</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=ss>&quot;差值&quot;</span>
<span class=k>FROM</span><span class=w> </span><span class=n>employee</span><span class=p>;</span>


<span class=c1>-- 行子查询（一行多列）</span>
<span class=c1>-- 顾名思义，就是返回一条记录的子查询，不过这条记录需要包含多个列（只包含一个列就成了标量子查询了）。</span>
<span class=c1>-- 其中的(SELECT m2, n2 FROM e2 LIMIT 1)就是一个行子查询</span>
<span class=c1>-- 整条语句的含义就是要从 e1 表中找一些记录，这些记录的 m1 和 n1 列分别等于子查询结果中的 m2 和 n2 列</span>
<span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>e1</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=p>(</span><span class=n>m1</span><span class=p>,</span><span class=w> </span><span class=n>n1</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=k>SELECT</span><span class=w> </span><span class=n>m2</span><span class=p>,</span><span class=w> </span><span class=n>n2</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>e2</span><span class=w> </span><span class=k>LIMIT</span><span class=w> </span><span class=mi>1</span><span class=p>);</span>

<span class=c1>-- 查找所有与&quot;孙乾&quot;在同一个部门并且职位相同的员工</span>

<span class=c1>-- Oracle、MySQL、PostgreSQL 以及 SQLite</span>
<span class=k>SELECT</span><span class=w> </span><span class=n>emp_name</span><span class=p>,</span><span class=w> </span><span class=n>dept_id</span><span class=p>,</span><span class=w> </span><span class=n>job_id</span>
<span class=k>FROM</span><span class=w> </span><span class=n>employee</span>
<span class=k>WHERE</span><span class=w> </span><span class=p>(</span><span class=n>dept_id</span><span class=p>,</span><span class=w> </span><span class=n>job_id</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=k>SELECT</span><span class=w> </span><span class=n>dept_id</span><span class=p>,</span><span class=w> </span><span class=n>job_id</span>
<span class=w>                           </span><span class=k>FROM</span><span class=w> </span><span class=n>employee</span>
<span class=w>                           </span><span class=k>WHERE</span><span class=w> </span><span class=n>emp_name</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s1>&#39;孙乾&#39;</span><span class=p>)</span>
<span class=k>AND</span><span class=w> </span><span class=n>emp_name</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=s1>&#39;孙乾&#39;</span><span class=p>;</span>

<span class=c1>-- 其中，外部查询的 WHERE 子句中包含一个行子查询，返回了&quot;孙乾&quot;所在的部门编号和职位编号，这两个值构成了一个记录。</span>
<span class=c1>-- 然后，外部查询使用该记录作为条件进行数据过滤，AND 运算符用于排除&quot;孙乾&quot;自己。</span>
<span class=c1>-- Microsoft SQL Server 目前不支持行子查询。</span>

<span class=c1>-- 列子查询（一列数据）</span>
<span class=c1>-- 列子查询自然就是查询出一个列的数据，不过这个列的数据需要包含多条记录</span>
<span class=c1>-- 其中的(SELECT m2 FROM e2)就是一个列子查询，表明查询出 e2 表的 m2 列 的所有值作为外层查询 IN 语句的参数。</span>
<span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>e1</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>m1</span><span class=w> </span><span class=k>IN</span><span class=w> </span><span class=p>(</span><span class=k>SELECT</span><span class=w> </span><span class=n>m2</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>e2</span><span class=p>);</span>

<span class=c1>-- 表子查询（二维多行多列）</span>
<span class=c1>-- 顾名思义，就是子查询的结果既包含很多条记录，又包含很多个列</span>
<span class=c1>-- 对于返回多行数据的子查询，我们可以使用 IN 或者 NOT IN 运算符进行比较。</span>
<span class=c1>-- 其中的(SELECT m2, n2 FROM e2)就是一个表子查询、此SQL必须要在m1，n1都满足的条件下方可成立</span>
<span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>e1</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=p>(</span><span class=n>m1</span><span class=p>,</span><span class=w> </span><span class=n>n1</span><span class=p>)</span><span class=w> </span><span class=k>IN</span><span class=w> </span><span class=p>(</span><span class=k>SELECT</span><span class=w> </span><span class=n>m2</span><span class=p>,</span><span class=w> </span><span class=n>n2</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>e2</span><span class=p>);</span>
<span class=c1>-- 因为单个值（外部查询条件中的字段）与多个值（子查询返回的多个元组记录）的比较不能使用比较运算符（=、!=、&lt;、&lt;=、&gt;、&gt;= 等）。</span>

<span class=c1>-- ALL 运算符与比较运算符（=、!=、&lt;、&lt;=、&gt;、&gt;=）的组合分别表示等于、不等于、小于、小于或等于、大于、大于或等于子查询结果中的全部数据。</span>


<span class=c1>-- From子句中的子查询</span>
<span class=c1>-- 派生表（子查询）</span>
<span class=c1>-- FROM后面跟的表是通过其他查询查出来的，这种查询叫派生表，派生表必须要有别名，以便稍后在查询中引用其名称。</span>
<span class=c1>-- 这种子查询后边的 AS t 表明这个子 查询的结果就相当于一个名称为 t 的表，这个名叫 t 的表的列就是子查询结果中的列（m和n）。</span>
<span class=c1>-- 这个放在 FROM 子句中的子查询本质上相当于一个表，但又和我们平常使用的表有点儿不一样，MySQL 把这种由子查询结果集组成的临时表称之为派生表。</span>
<span class=k>SELECT</span><span class=w> </span><span class=n>m</span><span class=p>,</span><span class=w> </span><span class=n>n</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=p>(</span><span class=k>SELECT</span><span class=w> </span><span class=n>m2</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=n>m</span><span class=p>,</span><span class=w> </span><span class=n>n2</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=n>n</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>e2</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>m2</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=mi>2</span><span class=p>)</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=n>t</span><span class=p>;</span>
<span class=c1>-- 派生表也是从 select 语句中返回的虚拟表。</span>
<span class=k>SELECT</span>
<span class=w>    </span><span class=n>column_list</span>
<span class=k>FROM</span>
<span class=w>    </span><span class=p>(</span><span class=k>SELECT</span><span class=w> </span><span class=n>column_list</span><span class=w> </span><span class=p>...</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>table_1</span><span class=p>)</span><span class=w> </span><span class=n>derived_table_name</span>
<span class=k>WHERE</span><span class=w> </span><span class=n>derived_table_name</span><span class=p>.</span><span class=n>c1</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=mi>0</span><span class=p>;</span>


<span class=c1>-- 一般来说，子查询可以像普通查询一样包含各种子句，例如 JOIN、WHERE、GROUP BY 等，甚至可以嵌套其他的子查询。但是需要注意，不同数据库对于子查询中 ORDER BY 子句的处理方式存在差异。</span>

<span class=c1>-- 通常来说，子查询中的排序没有实际意义，不会影响到查询结果和显示顺序。只有外部查询中的 ORDER BY 子句能够决定最终结果的显示顺序。</span>
</code></pre></div> <h3 id=_19>联表查询<a class=headerlink href=#_19 title="Permanent link">&para;</a></h3> <h4 id=_20>笛卡尔积/交叉连接<a class=headerlink href=#_20 title="Permanent link">&para;</a></h4> <p>笛卡尔积是指在数学中，两个集合 X 和 Y 的笛卡尓积（Cartesian product），又称直积，表示为 <code>X × Y</code>，第一个对象是 X 的成员，而第二个对象是 Y 的所有可能有序对的其中一个成员。</p> <p>笛卡尔积又叫笛卡尔乘积，是一个叫笛卡尔的人提出来的。 简单的说就是两个集合相乘的结果。</p> <p>假设集合 A={a, b}，集合 B={0, 1, 2}，则两个集合的笛卡尔积为{(a, 0), (a, 1), (a, 2), (b, 0), (b, 1), (b, 2)}。</p> <p>遍历左表的每一行数据，用左表每一行数据分别于与右表的每一行数据做关联</p> <div class=highlight><pre><span></span><code><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>stu</span><span class=w> </span><span class=k>CROSS</span><span class=w> </span><span class=k>JOIN</span><span class=w> </span><span class=k>class</span><span class=p>;</span>
<span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>stu</span><span class=p>,</span><span class=k>class</span><span class=p>;</span>
<span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>stu</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=p>,</span><span class=w>  </span><span class=k>class</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=k>JOIN</span><span class=w> </span><span class=k>ON</span><span class=w> </span><span class=mi>1</span><span class=o>=</span><span class=mi>1</span><span class=w> </span><span class=p>;</span>
<span class=w> </span><span class=c1>-- 可以看出，笛卡尔乘积的运算量超级大，一般不会使用笛卡尔乘积做表关联查询</span>
</code></pre></div> <div class="admonition 注意"> <p class=admonition-title>注意</p> </div> <p>在 MySQL 中， <code>CROSS JOIN</code> 等价于 <code>INNER JOIN</code> ， 这两个可以互换使用。但是在标准 SQL 中，这两个并不一样。</p> <h4 id=_21>自然连接<a class=headerlink href=#_21 title="Permanent link">&para;</a></h4> <p>对于两个表，自然连接是先找出两个表所有共用的属性，然后在 <strong>共用属性上做匹配，找出相同的行进行连接。（一定要注意连接谓词是所有的共有属性集合，即两个表上所有相同的列名）</strong></p> <p><code>natural join</code> 无需声明连接条件，sql 执行器会自动寻找连接的两个表中相同的字段去生成连接条件，然后取数据的交集。其实自然连接就是自动生成连接条件的内连接，他也不是什么新的连接，就是一个为了简化写法的语法糖而已</p> <div class=highlight><pre><span></span><code><span class=c1>-- 标准SQL写法一</span>
<span class=k>SELECT</span><span class=w> </span><span class=n>user_name</span><span class=p>,</span><span class=n>dept_name</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=k>user</span><span class=w> </span><span class=k>NATURAL</span><span class=w> </span><span class=k>JOIN</span><span class=w> </span><span class=n>dept</span><span class=w> </span><span class=p>;</span><span class=w>                  </span><span class=c1>--直接自然连接，无需手动添加连接字段，执行器会自动找同名的字段。</span>

<span class=c1>-- 标准SQL写法二</span>
<span class=k>SELECT</span><span class=w> </span><span class=n>user_name</span><span class=p>,</span><span class=n>dept_name</span><span class=w> </span><span class=k>FROM</span><span class=w>  </span><span class=k>user</span><span class=p>,</span><span class=w> </span><span class=n>dept</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=k>user</span><span class=p>.</span><span class=n>id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>dept</span><span class=p>.</span><span class=n>id</span><span class=w>  </span><span class=p>...</span><span class=w>  </span><span class=c1>--自己手动所有共有属性都连接起来。</span>

<span class=c1>-- MySQL写法三</span>
<span class=c1>-- select name , id , title from A1 natural join A2 natural join A3</span>
<span class=c1>-- select name , id , title from A1 natural join A2 , A3 where A2.id = A3.id</span>
<span class=c1>-- 这两个写法的结果可能不一样，</span>
<span class=c1>-- 第一个可以认为将A1 A2进行自然连接的结果，再与A3进行自然连接</span>
<span class=c1>-- 第二个可以认为将A1 A2进行自然连接的结果，再与A3进行等值连接</span>
</code></pre></div> <h4 id=_22>等值连接<a class=headerlink href=#_22 title="Permanent link">&para;</a></h4> <p>对两个表，等值连接是明确一组属性上进行匹配。然后进行连接。(连接谓词是在选定的属性集合)，<strong>所以自然连接是一种特殊的等值连接。这种方法可能更加通用。</strong></p> <div class=highlight><pre><span></span><code><span class=c1>-- 在这个例子中，只在ID上进行匹配。要求两个表都要有ID这个字段。</span>
<span class=c1>-- 使用 using 语法 ， select ... from T1 join T2 using(id)</span>
<span class=k>select</span><span class=w> </span><span class=n>user_name</span><span class=p>,</span><span class=n>dept_name</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=k>user</span><span class=w> </span><span class=k>join</span><span class=w> </span><span class=n>dept</span><span class=w> </span><span class=k>using</span><span class=w> </span><span class=p>(</span><span class=n>id</span><span class=p>)</span><span class=w> </span><span class=p>;</span>

<span class=c1>-- 使用 join on 关键字，on条件允许在参与连接的关系上设置连接谓词。</span>
<span class=k>select</span><span class=w>  </span><span class=n>user_name</span><span class=p>,</span><span class=n>dept_name</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=k>user</span><span class=w> </span><span class=k>join</span><span class=w> </span><span class=n>dept</span><span class=w> </span><span class=k>on</span><span class=w> </span><span class=k>user</span><span class=p>.</span><span class=n>id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>dept</span><span class=p>.</span><span class=n>id</span><span class=w> </span><span class=p>;</span>

<span class=c1>-- tb1 inner join tb2 on something</span>
<span class=c1>-- 不保留未匹配的元组</span>

<span class=k>select</span><span class=w>  </span><span class=n>user_name</span><span class=p>,</span><span class=n>dept_name</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=n>students</span><span class=w>  </span><span class=k>left</span><span class=w> </span><span class=k>outer</span><span class=w> </span><span class=k>join</span><span class=w> </span><span class=n>dept</span><span class=w> </span><span class=k>on</span><span class=w> </span><span class=k>user</span><span class=p>.</span><span class=n>id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>dept</span><span class=p>.</span><span class=n>id</span><span class=w> </span><span class=p>;</span>
</code></pre></div> <h4 id=_23>内连接<a class=headerlink href=#_23 title="Permanent link">&para;</a></h4> <p>内连接包括自然连接，不等值连接和等值连接。上面这些连接，都是常规连接，都可以理解成内连接，两个表中的列互相匹配时，只按照少的那个表匹配。</p> <h4 id=_24>外连接<a class=headerlink href=#_24 title="Permanent link">&para;</a></h4> <p>左外连接（LEFT OUTER JOIN）：结果表中除了包括满足连接条件的行外，还包括左表的所有行。</p> <p>【例】 查找所有学生情况，以及他们选修的课程号，若学生未选修任何课，也要包括其情况</p> <p>left 左边的表为主表，left 右边的表为从表。返回结果行数以 left 左边的表的行数为最后的数据行，对于左表中有些数据行在右表中找不到它所匹配的数据行记录时候，返回结果的时候这些行后面通常会以 `null`` 来填充。</p> <p>本例执行时，若有学生未选任何课程，则结果表中相应行的课程号字段值为 NULL。</p> <p>右外连接（RIGHT OUTER JOIN）：结果表中除了包括满足连接条件的行外，还包括右表的所有行。</p> <p>完全外连接（FULL OUTER JOIN）：结果表中除了包括满足连接条件的行外，还包括两个表的所有行</p> <p><a href=https://www.cnblogs.com/blknemo/p/12391172.html>参考</a></p> <h4 id=_25>半连接<a class=headerlink href=#_25 title="Permanent link">&para;</a></h4> <p>半连接 <code>SEMI JOIN</code> 是指在两表关联时，当第二个表中存在一个或多个匹配记录时，返回第一个表的记录。</p> <p>比如 <code>IN/EXIST</code> 子查询。如果按照 <code>IN/EXIST</code> 谓词的原语义去执行，对外查询的每行记录都去计算 <code>IN/EXIST</code> 谓词的结果。子查询的内容就需要单独执行，在关联子查询的情况下，子查询需要多次重复执行，整体的执行效率很低。实际上，部分存在性问题(SPJ 子查询)类似于外查询的多个表与子查询的多个表(以下简述为外表和内表)的连接(JOIN)问题，能连接上说明存在。</p> <p>但是与普通 JOIN 不同的点在于，当外表和内表 JOIN 的时候，外表的每行记录都有可能和内表的多行连接上，这就导致了外表行的重复记录，但是按照原语义 IN/EXIST 子查询只是对外表行上进行的过滤，数据只能减少，而不能膨胀。</p> <p>与普通 JOIN 不同，<code>SEMI JOIN</code> 中第一个表里的记录最多只返回一次。<code>SEMI JOIN</code> 通常无法直接用 SQL 语句来表示，而是由 IN 或 EXISTS 子查询转换得到。</p> <p>半连接只会返回左表中的数据，右表只用于条件判断。另外，即使右表中存在多个匹配的数据，左边中的数据只返回一次。半连接通常用于存在性判断，例如哪些顾客购买了产品，而不需要知道他们购买的具体产品和数量。</p> <div class=highlight><pre><span></span><code><span class=c1>-- 查找拥有员工的部门</span>
<span class=k>SELECT</span><span class=w> </span><span class=o>*</span>
<span class=k>FROM</span><span class=w> </span><span class=n>department</span><span class=w> </span><span class=n>d</span>
<span class=k>WHERE</span><span class=w> </span><span class=k>EXISTS</span><span class=w> </span><span class=p>(</span><span class=k>SELECT</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>employee</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>dept_id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>d</span><span class=p>.</span><span class=n>dept_id</span><span class=p>);</span>

<span class=c1>-- 也可以用IN查询</span>
<span class=k>SELECT</span><span class=w> </span><span class=o>*</span>
<span class=k>FROM</span><span class=w> </span><span class=n>department</span><span class=w> </span><span class=n>d</span>
<span class=k>WHERE</span><span class=w> </span><span class=n>dept_id</span><span class=w> </span><span class=k>IN</span><span class=w> </span><span class=p>(</span><span class=k>SELECT</span><span class=w> </span><span class=n>dept_id</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>employee</span><span class=p>);</span>

<span class=c1>-- 也可以用 =ANY 操作符</span>
<span class=k>SELECT</span><span class=w> </span><span class=o>*</span>
<span class=k>FROM</span><span class=w> </span><span class=n>department</span><span class=w> </span><span class=n>d</span>
<span class=k>WHERE</span><span class=w> </span><span class=n>dept_id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>ANY</span><span class=w> </span><span class=p>(</span><span class=k>SELECT</span><span class=w> </span><span class=n>dept_id</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>employee</span><span class=p>);</span>
</code></pre></div> <p><a href=http://mysql.taobao.org/monthly/2024/06/02/ >http://mysql.taobao.org/monthly/2024/06/02/</a></p> <h4 id=_26>反连接<a class=headerlink href=#_26 title="Permanent link">&para;</a></h4> <p>反连接返回左表中与右表不匹配的数据行，通常体现为 <code>NOT EXISTS</code> 或者 <code>NOT IN</code> 子查询。反连接的逻辑与半连接正好相反。</p> <p>反连接只会返回左表中的数据，右表只用于条件判断。反查询常见的应用包括：查找没有员工的部门信息，或者没有购买任何产品的顾客信息等。</p> <div class=highlight><pre><span></span><code><span class=c1>-- 查找没有员工的部门</span>
<span class=k>SELECT</span><span class=w> </span><span class=o>*</span>
<span class=k>FROM</span><span class=w> </span><span class=n>department</span><span class=w> </span><span class=n>d</span>
<span class=k>WHERE</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>EXISTS</span><span class=w> </span><span class=p>(</span><span class=k>SELECT</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>employee</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>dept_id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>d</span><span class=p>.</span><span class=n>dept_id</span><span class=p>);</span>
</code></pre></div> <h4 id=_27>不等值连接<a class=headerlink href=#_27 title="Permanent link">&para;</a></h4> <p>不等值连接：在连接条件使用除等于运算符以外的其它比较运算符比较被连接的列的列值。这些运算符包括&gt;、&gt;=、&lt;=、&lt;、!&gt;、!&lt;和&lt;&gt;。</p> <h3 id=_28>分组查询<a class=headerlink href=#_28 title="Permanent link">&para;</a></h3> <p><strong>标准 SQL 规定，在对表进行聚合查询的时候，只能在 SELECT 子句中写下面 3 种内容：通过 GROUP BY 子句指定的聚合键、聚合函数（SUM 、AVG 等）、常量。</strong></p> <p>在标准 SQL，正常的如果对一个表进行分组查询，分组会进行去重，每一组查询的结果集应该只有一行数据。</p> <p>分组，主要是使用 <code>GROUP BY</code> 子句，一般是按照 <code>WHERE</code> 条件过滤之后的结果集进行分组， <code>GROUP BY</code> 一般和聚合函数一起使用才有意义。</p> <blockquote> <p>注意，<code>WHERE</code>子句只能指定行的条件，而不能指定组的条件。</p> </blockquote> <p>很多人都知道聚合查询的限制，但是很少有人能正确地理解为什么会有这样的约束。</p> <p><strong>标准 SQL 规定：分组查询中的要查询的列必须是 group by 中要分组的列或聚集函数或常量。</strong></p> <p>表 tbl_student_class 中的 cname 存储的是每位学生的班级信息，但需要注意的是，这里的 cname 只是每个学生的属性，并不是小组的属性。</p> <p>而 <code>GROUP BY</code> 又是聚合操作，操作的对象就是由多个学生组成的小组，因此，小组的属性只能是平均或者总和等统计性质的属性</p> <p>询问每个学生的 cname 是可以的，但是询问由按照班级分组后的多个学生组成的小组的 cname 就没有意义了。</p> <p>对于小组来说，只有"一共多少学生"或者"最大学号是多少？"这样的问法才是有意义的。强行将适用于个体的属性套用于团体之上，纯粹是一种分类错误。</p> <p><code>GROUP BY</code> 的作用是将一个个元素划分成若干个子集，使用 <code>GROUP BY</code> 聚合之后，<code>SQL</code> 的操作对象便由 0 阶的"行"变为了 1 阶的"行的集合"。</p> <p>此时行的属性便不能使用了。SQL 的世界其实是层级分明的等级社会，将低阶概念的属性用在高阶概念上会导致秩序的混乱，这是不允许的。</p> <p>按多字段分组，所有字段值相同的才能算一组。<code>GROUP BY X, Y</code> 意思是将所有具有相同 X 字段值和 Y 字段值的记录放到一个分组里。</p> <p><a href=https://www.cnblogs.com/youzhibing/p/11516154.html>参考</a></p> <p><a href=https://www.cnblogs.com/weix-l/p/7521278.html>参考 2</a></p> <div class=highlight><pre><span></span><code><span class=c1>-- 查询每个系的男教师平均工资(系名，平均工资)</span>
<span class=c1>-- where过滤出所有男教师。group by按系分组，聚合计算查出需要的列</span>
<span class=k>select</span><span class=w> </span><span class=n>dept_name</span><span class=w> </span><span class=p>,</span><span class=k>avg</span><span class=p>(</span><span class=n>salary</span><span class=p>)</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=n>instructor</span><span class=w>  </span><span class=k>where</span><span class=w> </span><span class=n>employe_type</span><span class=o>=</span><span class=ss>&quot;male&quot;</span><span class=w> </span><span class=k>group</span><span class=w> </span><span class=k>by</span><span class=w> </span><span class=n>dept_name</span>


<span class=c1>-- 对于下面这样的两个表：</span>

<span class=c1>-- 项目（项目名称，项目经理，价格）</span>
<span class=c1>-- 消费（消费流水号，会员手机号，项目名称，消费金额，消费日期）</span>
<span class=c1>-- 每个项目只能有一个项目经理，一个项目经理只能负责一个项目</span>


<span class=c1>-- 问题：统计出所负责项目消费总金额大于等于10万的项目和项目经理信息</span>



<span class=k>SELECT</span>
<span class=w>    </span><span class=err>项目</span><span class=p>.</span><span class=err>项目名称</span><span class=p>,</span>
<span class=w>    </span><span class=err>项目</span><span class=p>.</span><span class=err>项目经理</span><span class=p>,</span>
<span class=w>    </span><span class=k>sum</span><span class=p>(</span><span class=w> </span><span class=err>消费金额</span><span class=w> </span><span class=p>)</span>
<span class=k>FROM</span>
<span class=w>    </span><span class=err>项目</span><span class=p>,</span><span class=err>消费</span>
<span class=k>WHERE</span>
<span class=w>    </span><span class=err>项目</span><span class=p>.</span><span class=err>项目名称</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=err>消费</span><span class=p>.</span><span class=err>项目名称</span>
<span class=k>GROUP</span><span class=w> </span><span class=k>BY</span>
<span class=w>    </span><span class=err>项目</span><span class=p>.</span><span class=err>项目名称</span><span class=w> </span><span class=err>项目</span><span class=p>.</span><span class=err>项目经理</span>
<span class=k>HAVING</span>
<span class=w>    </span><span class=k>sum</span><span class=p>(</span><span class=w> </span><span class=err>消费金额</span><span class=w> </span><span class=p>)</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=mi>10000</span>
<span class=k>ORDER</span><span class=w> </span><span class=k>BY</span>
<span class=w>    </span><span class=k>sum</span><span class=p>(</span><span class=w> </span><span class=err>消费金额</span><span class=w> </span><span class=p>)</span><span class=w> </span><span class=k>DESC</span>
</code></pre></div> <h4 id=_29>分组合计小计<a class=headerlink href=#_29 title="Permanent link">&para;</a></h4> <p>在 <code>SQL</code> 中可以使用 <code>GROUP BY</code> 子句的扩展选项：<code>ROLLUP</code>。<code>ROLLUP</code> 可以生成按照层级进行汇总的结果，类似于财务报表中的小计、合计和总计。</p> <div class=highlight><pre><span></span><code><span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=o>`</span><span class=n>tbl_ware</span><span class=o>`</span><span class=w> </span><span class=p>(</span>
<span class=w>  </span><span class=o>`</span><span class=n>ware_id</span><span class=o>`</span><span class=w> </span><span class=nb>BIGINT</span><span class=p>(</span><span class=mi>20</span><span class=p>)</span><span class=w> </span><span class=n>UNSIGNED</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=w> </span><span class=n>AUTO_INCREMENT</span><span class=w> </span><span class=k>COMMENT</span><span class=w> </span><span class=s1>&#39;商品id&#39;</span><span class=p>,</span>
<span class=w>  </span><span class=o>`</span><span class=n>ware_name</span><span class=o>`</span><span class=w> </span><span class=nb>VARCHAR</span><span class=p>(</span><span class=mi>100</span><span class=p>)</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=w> </span><span class=k>COMMENT</span><span class=w> </span><span class=s1>&#39;商品名称&#39;</span><span class=p>,</span>
<span class=w>  </span><span class=o>`</span><span class=n>ware_category</span><span class=o>`</span><span class=w> </span><span class=nb>VARCHAR</span><span class=p>(</span><span class=mi>100</span><span class=p>)</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=w> </span><span class=k>COMMENT</span><span class=w> </span><span class=s1>&#39;商品类别&#39;</span><span class=p>,</span>
<span class=w>  </span><span class=o>`</span><span class=n>sale_unit_price</span><span class=o>`</span><span class=w> </span><span class=nb>INT</span><span class=w> </span><span class=k>COMMENT</span><span class=w> </span><span class=s1>&#39;销售单价&#39;</span><span class=p>,</span>
<span class=w>  </span><span class=o>`</span><span class=n>purchase_unit_price</span><span class=o>`</span><span class=w> </span><span class=nb>INT</span><span class=w> </span><span class=k>COMMENT</span><span class=w> </span><span class=s1>&#39;进货单价&#39;</span><span class=p>,</span>
<span class=w>  </span><span class=o>`</span><span class=n>registration_date</span><span class=o>`</span><span class=w> </span><span class=nb>DATE</span><span class=w> </span><span class=k>COMMENT</span><span class=w> </span><span class=s1>&#39;登记日期&#39;</span><span class=p>,</span>
<span class=w>  </span><span class=k>PRIMARY</span><span class=w> </span><span class=k>KEY</span><span class=w> </span><span class=p>(</span><span class=o>`</span><span class=n>ware_id</span><span class=o>`</span><span class=p>)</span><span class=w> </span><span class=k>USING</span><span class=w> </span><span class=n>BTREE</span>
<span class=p>)</span><span class=w> </span><span class=n>ENGINE</span><span class=o>=</span><span class=n>InnoDB</span><span class=w> </span><span class=k>COMMENT</span><span class=o>=</span><span class=s1>&#39;产品&#39;</span><span class=p>;</span>

<span class=k>INSERT</span><span class=w> </span><span class=k>INTO</span><span class=w> </span><span class=n>tbl_ware</span><span class=w> </span><span class=k>VALUES</span>
<span class=p>(</span><span class=mi>1</span><span class=p>,</span><span class=s1>&#39;T恤衫&#39;</span><span class=p>,</span><span class=s1>&#39;衣服&#39;</span><span class=p>,</span><span class=mi>100</span><span class=p>,</span><span class=w> </span><span class=mi>50</span><span class=p>,</span><span class=s1>&#39;2023-12-15&#39;</span><span class=p>),</span>
<span class=p>(</span><span class=mi>2</span><span class=p>,</span><span class=s1>&#39;打孔器&#39;</span><span class=p>,</span><span class=s1>&#39;办公用品&#39;</span><span class=p>,</span><span class=mi>25</span><span class=p>,</span><span class=w> </span><span class=mi>10</span><span class=p>,</span><span class=s1>&#39;2023-12-15&#39;</span><span class=p>),</span>
<span class=p>(</span><span class=mi>3</span><span class=p>,</span><span class=s1>&#39;运动T恤&#39;</span><span class=p>,</span><span class=s1>&#39;衣服&#39;</span><span class=p>,</span><span class=mi>150</span><span class=p>,</span><span class=w> </span><span class=mi>50</span><span class=p>,</span><span class=s1>&#39;2023-12-15&#39;</span><span class=p>),</span>
<span class=p>(</span><span class=mi>4</span><span class=p>,</span><span class=s1>&#39;菜刀&#39;</span><span class=p>,</span><span class=s1>&#39;厨房用具&#39;</span><span class=p>,</span><span class=mi>75</span><span class=p>,</span><span class=w> </span><span class=mi>30</span><span class=p>,</span><span class=s1>&#39;2023-12-15&#39;</span><span class=p>),</span>
<span class=p>(</span><span class=mi>5</span><span class=p>,</span><span class=s1>&#39;高压锅&#39;</span><span class=p>,</span><span class=s1>&#39;厨房用具&#39;</span><span class=p>,</span><span class=mi>600</span><span class=p>,</span><span class=w> </span><span class=mi>200</span><span class=p>,</span><span class=s1>&#39;2023-12-15&#39;</span><span class=p>),</span>
<span class=p>(</span><span class=mi>6</span><span class=p>,</span><span class=s1>&#39;叉子&#39;</span><span class=p>,</span><span class=s1>&#39;厨房用具&#39;</span><span class=p>,</span><span class=mi>7</span><span class=p>,</span><span class=w> </span><span class=mi>3</span><span class=p>,</span><span class=s1>&#39;2023-12-15&#39;</span><span class=p>),</span>
<span class=p>(</span><span class=mi>7</span><span class=p>,</span><span class=s1>&#39;菜板&#39;</span><span class=p>,</span><span class=s1>&#39;厨房用具&#39;</span><span class=p>,</span><span class=mi>98</span><span class=p>,</span><span class=w> </span><span class=mi>30</span><span class=p>,</span><span class=s1>&#39;2023-12-15&#39;</span><span class=p>),</span>
<span class=p>(</span><span class=mi>8</span><span class=p>,</span><span class=s1>&#39;圆珠笔&#39;</span><span class=p>,</span><span class=s1>&#39;办公用品&#39;</span><span class=p>,</span><span class=mi>5</span><span class=p>,</span><span class=w> </span><span class=mi>2</span><span class=p>,</span><span class=s1>&#39;2023-12-15&#39;</span><span class=p>);</span>


<span class=c1>-- 统计每个类别产品的总进价</span>
<span class=k>SELECT</span><span class=w> </span><span class=n>ware_category</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=s1>&#39;商品类别&#39;</span><span class=w> </span><span class=p>,</span><span class=w> </span><span class=k>SUM</span><span class=p>(</span><span class=n>purchase_unit_price</span><span class=p>)</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=s1>&#39;总进价&#39;</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>tbl_ware</span><span class=w> </span><span class=k>GROUP</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>ware_category</span><span class=p>;</span>

<span class=c1>-- 如果还要同时统计所有总进价：两个SELECT结果集连接起来</span>
<span class=k>SELECT</span><span class=w> </span><span class=n>ware_category</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=s1>&#39;商品类别&#39;</span><span class=w> </span><span class=p>,</span><span class=w> </span><span class=k>SUM</span><span class=p>(</span><span class=n>purchase_unit_price</span><span class=p>)</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=s1>&#39;总进价&#39;</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>tbl_ware</span><span class=w> </span><span class=k>GROUP</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>ware_category</span><span class=p>;</span>
<span class=k>UNION</span><span class=w> </span><span class=k>ALL</span>
<span class=k>SELECT</span><span class=w> </span><span class=n>ware_category</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=s1>&#39;合计&#39;</span><span class=w> </span><span class=p>,</span><span class=w> </span><span class=k>SUM</span><span class=p>(</span><span class=n>purchase_unit_price</span><span class=p>)</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=s1>&#39;总进价&#39;</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>tbl_ware</span><span class=w> </span><span class=p>;</span>


<span class=c1>-- 最后一行其实就是合计，WITH ROLLUP 是 MySQL 的独有写法</span>
<span class=k>SELECT</span><span class=w> </span><span class=n>ware_category</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=s1>&#39;商品类别&#39;</span><span class=w> </span><span class=p>,</span><span class=w> </span><span class=k>SUM</span><span class=p>(</span><span class=n>purchase_unit_price</span><span class=p>)</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=s1>&#39;总进价&#39;</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>tbl_ware</span><span class=w> </span><span class=k>GROUP</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>ware_category</span><span class=w> </span><span class=k>WITH</span><span class=w> </span><span class=k>ROLLUP</span><span class=p>;</span>
</code></pre></div> <h4 id=mysql-group-by>MySQL group by 隐式排序<a class=headerlink href=#mysql-group-by title="Permanent link">&para;</a></h4> <p><a href=../foundmental/suoyin.md#mysql-group-by>隐式排序和降序索引</a></p> <h4 id=_30>分组原理和优化<a class=headerlink href=#_30 title="Permanent link">&para;</a></h4> <p><code>MySQL</code> 内部对 <code>GROUP BY</code> 的实现方式有三种，松散索引，紧凑索引，临时文件（文件排序）。</p> <p>在没有合适的索引可用的时候，通常先扫描整个表提取数据并创建一个临时表，然后按照<code>GROUP BY</code>指定的列进行排序。在这个临时表里面，对于每一个 GROUP 的数据行来说是连续在一起的。</p> <p>完成排序之后，就可以发现所有的 GROUPS，并可以执行聚集函数（aggregate function）。<mark>可以看到，在没有使用索引的时候，需要创建临时表和排序</mark> 。在执行计划中通常可以看到"Using temporary; Using filesort"。</p> <div class=highlight><pre><span></span><code><span class=k>explain</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=n>city</span><span class=w> </span><span class=p>,</span><span class=k>count</span><span class=p>(</span><span class=o>*</span><span class=p>)</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=s1>&#39;NUM&#39;</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=k>user</span><span class=w> </span><span class=k>GROUP</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>city</span><span class=p>;</span>
</code></pre></div> <p>在 Extra 字段里面，我们可以看到以下信息：</p> <ul> <li>用到了 Using temporary, 表示执行时创建了一个内部临时表。</li> </ul> <p>注意这里的临时表可能是内存上的临时表，也有可能是硬盘上的临时表，当然，如果临时表比较小，就是基于内存的，可以肯定的是：基于内存的临时表的性能高，时间消耗肯定要比基于硬盘的临时表的实际消耗小。</p> <ul> <li>用到了 Using filesort， 表示执行过程中没有使用索引的排序，而是使用临时文件。</li> </ul> <p>"Using filesort"是 MySQL 的 EXPLAIN 输出中的一个短语，表示查询需要使用临时文件对结果集进行排序。这可能发生在查询包括<code>ORDER BY</code>子句或<code>GROUP BY</code>子句时，而数据库无法使用索引满足排序顺序。</p> <p><mark>使用临时文件对大型结果集进行排序可能会导致磁盘 I/O 和内存使用方面的昂贵开销，因此最好尽可能避免"Using filesort"</mark> </p> <p>一些避免文件排序的策略包括使用适当的索引优化查询，限制结果集的大小或修改查询以使用不同的排序算法。</p> <p>那么 <code>GROUP BY</code> 语句为啥会同时用到临时表和临时文件排序呢？</p> <p>首先看下整个执行流程：</p> <ul> <li>在执行过程中首先创建内存临时表，表里有 city, num 两个字段，city 为主键。</li> <li>扫描 user 表，依次取出一行数据，数据中 city 字段的值为 c;</li> <li>如果临时表中没有主键为 c 的行， 则插入一条新纪录（c ， 1）；</li> <li>如果存在，则更新该行为 （c, num + 1)；</li> <li>遍历完后，再根据 city 进行排序，最后将结果集返回给客户端。</li> </ul> <h5 id=_31>分组操作如何利用索引？<a class=headerlink href=#_31 title="Permanent link">&para;</a></h5> <p>因为<code>InnoDB</code>使用基于<code>B+ tree</code>的索引组织表，因此索引上的列满足天然有序性，对于组合索引，对组合键值有序；这个特性可以被用于索引扫描不同的<code>group</code>，而不需要扫描全部的索引列。</p> <p><strong>因而使用索引进行分组的最重要的前提条件是所有<code>GROUP BY</code>的参照列（分组依据的列）来自于同一个索引，且索引按照顺序存储所有的 keys（即 BTREE index，而 HASH index 没有顺序的概念）</strong></p> <ul> <li> <p><strong>在松散索引扫描方式下，分组操作和范围预测（如果有的话）一起执行完成的。</strong></p> </li> <li> <p><strong>在紧凑索引扫描方式下，先对索引执行范围扫描（range scan），再对结果元组进行分组。</strong></p> </li> </ul> <p>当<code>MySQL</code>完全利用索引扫描来实现<code>GROUP BY</code>的时候，并不需要扫描所有满足条件的索引键即可完成分组操作的方式，称为<code>loose index scan</code>，它可以最大限度的减少需要扫描的<code>ROWS</code>；</p> <p><mark><strong>松散索引扫描和紧凑索引扫描的最大区别是是否需要扫描整个索引或者整个范围扫描</strong></mark> </p> <h6 id=loose-index-scan><strong>松散索引(Loose Index Scan)</strong><a class=headerlink href=#loose-index-scan title="Permanent link">&para;</a></h6> <p>松散索引扫描相当于<code>Oracle</code>中的 <mark>跳跃索引扫描（skip index scan）</mark> ，就是不需要连续扫描索引中的每一个元组，扫描时仅考虑索引中的一部分。</p> <ul> <li> <p>当查询中没有<code>WHERE</code>条件的时候，松散索引扫描读取的索引元组的个数和<code>GROUPS</code>的数量相同。</p> </li> <li> <p>如果<code>WHERE</code>条件包含范围预测，松散索引扫描查找每个<code>GROUP</code>中第一个满足范围条件，然后再读取最少可能数的 keys。松散索引扫描只需要读取很少量的数据就可以完成<code>GROUP BY</code>操作，因而执行效率非常高。</p> </li> </ul> <p>使用松散索引扫描需要满足以下条件：</p> <ol> <li>单表查询</li> <li><code>GROUP BY</code>指定的分组列是索引的一个最左前缀，并且没有其它的列。比如表 t1（ c1,c2,c3,c4）上建立了索引（c1,c2,c3）。如果查询包含<code>group by c1,c2</code>，那么可以使用松散索引扫描。但是<code>group by c2,c3</code>(不是索引最左前缀)和<code>group by c1,c2,c4</code>(c4 字段不在索引中)。</li> <li>如果在选择列表<code>select list</code>中存在聚集函数，只能使用 <code>min()</code>和<code>max()</code>两个聚集函数，并且指定的是同一列（如果<code>min()</code>和<code>max()</code>同时存在）。这一列必须在索引中，且紧跟着<code>GROUP BY</code>指定的列。比如<code>select t1,t2,min(t3),max(t3) from t1 group by c1,c2</code>。</li> <li>如果查询中存在除了<code>GROUP BY</code>指定的列之外的索引其他部分，那么必须以常量的形式出现（除了<code>min()</code>和<code>max()</code>两个聚集函数）。比如:</li> </ol> <div class=highlight><pre><span></span><code><span class=c1>-- 不能使用松散索引扫描</span>
<span class=k>select</span><span class=w> </span><span class=n>c1</span><span class=p>,</span><span class=n>c3</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=n>t1</span><span class=w> </span><span class=k>group</span><span class=w> </span><span class=k>by</span><span class=w> </span><span class=n>c1</span><span class=p>,</span><span class=n>c2</span><span class=p>;</span>
<span class=c1>-- 可以使用松散索引扫描</span>
<span class=k>select</span><span class=w> </span><span class=n>c1</span><span class=p>,</span><span class=n>c3</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=n>t1</span><span class=w> </span><span class=k>where</span><span class=w> </span><span class=n>c3</span><span class=w> </span><span class=o>=</span><span class=w>  </span><span class=mi>3</span><span class=w> </span><span class=k>group</span><span class=w> </span><span class=k>by</span><span class=w> </span><span class=n>c1</span><span class=p>,</span><span class=n>c2</span><span class=p>;</span>
</code></pre></div> <ol> <li>索引中的列必须索引整个数据列的值<code>(full column values must be indexed)</code>，而不是一个前缀索引。比如，<code>c1 varchar(20), INDEX (c1(10))</code> 这个索引没发用作松散索引扫描。(建前缀索引，与上面提到的索引的最左前缀是不同的)</li> </ol> <p><strong>如果查询能够使用松散索引扫描，那么执行计划中 Etra 中提示"using index for group-by"</strong></p> <p>自从 <code>MySQL5.5</code> 开始，松散索引扫描可以作用于在<code>SELECT LIST</code>中其它形式的聚集函数，除了<code>MIN()</code>和<code>MAX()</code>之外，还支持：</p> <ol> <li><code>AVG(DISTINCT)</code>, <code>SUM(DISTINCT)</code>和<code>COUNT(DISTINCT)</code>可以使用松散索引扫描。<code>AVG(DISTINCT)</code>, <code>SUM(DISTINCT)</code>只能使用单一列作为参数。而<code>COUNT(DISTINCT)</code>可以使用多列参数。</li> <li>在查询中必须没有<code>GROUP BY</code>和<code>DISTINCT</code>条件。</li> <li>之前声明的松散扫描限制条件同样起作用。</li> </ol> <p>在官方文档中提到，当有<code>GROUP BY</code>子句时，在特定的情况下可以使用松散索引，减少扫描的次数。官方文档中给出了以下的一些情况可以使用到松散索引</p> <div class=highlight><pre><span></span><code><span class=n>an</span><span class=w> </span><span class=k>index</span><span class=w> </span><span class=n>idx</span><span class=p>(</span><span class=n>c1</span><span class=p>,</span><span class=n>c2</span><span class=p>,</span><span class=n>c3</span><span class=p>)</span><span class=w> </span><span class=k>on</span><span class=w> </span><span class=k>table</span><span class=w> </span><span class=n>t1</span><span class=p>(</span><span class=n>c1</span><span class=p>,</span><span class=n>c2</span><span class=p>,</span><span class=n>c3</span><span class=p>,</span><span class=n>c4</span><span class=p>)</span>

<span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=o>`</span><span class=n>t1</span><span class=o>`</span><span class=w> </span><span class=p>(</span>
<span class=w>    </span><span class=o>`</span><span class=n>c1</span><span class=o>`</span><span class=w> </span><span class=nb>int</span><span class=p>(</span><span class=mi>11</span><span class=p>)</span><span class=w> </span><span class=k>DEFAULT</span><span class=w> </span><span class=k>NULL</span><span class=p>,</span>
<span class=w>    </span><span class=o>`</span><span class=n>c2</span><span class=o>`</span><span class=w> </span><span class=nb>int</span><span class=p>(</span><span class=mi>11</span><span class=p>)</span><span class=w> </span><span class=k>DEFAULT</span><span class=w> </span><span class=k>NULL</span><span class=p>,</span>
<span class=w>    </span><span class=o>`</span><span class=n>c3</span><span class=o>`</span><span class=w> </span><span class=nb>int</span><span class=p>(</span><span class=mi>11</span><span class=p>)</span><span class=w> </span><span class=k>DEFAULT</span><span class=w> </span><span class=k>NULL</span><span class=p>,</span>
<span class=w>    </span><span class=o>`</span><span class=n>c4</span><span class=o>`</span><span class=w> </span><span class=nb>int</span><span class=p>(</span><span class=mi>11</span><span class=p>)</span><span class=w> </span><span class=k>DEFAULT</span><span class=w> </span><span class=k>NULL</span><span class=p>,</span>
<span class=w>    </span><span class=k>KEY</span><span class=w> </span><span class=o>`</span><span class=n>idx_g</span><span class=o>`</span><span class=w> </span><span class=p>(</span><span class=o>`</span><span class=n>c1</span><span class=o>`</span><span class=p>,</span><span class=o>`</span><span class=n>c2</span><span class=o>`</span><span class=p>,</span><span class=o>`</span><span class=n>c3</span><span class=o>`</span><span class=p>)</span>
<span class=p>)</span><span class=w> </span><span class=n>ENGINE</span><span class=o>=</span><span class=n>InnoDB</span><span class=w> </span><span class=k>DEFAULT</span><span class=w> </span><span class=n>CHARSET</span><span class=o>=</span><span class=n>utf8mb4</span><span class=p>;</span>

<span class=c1>-- 下面的查询可以使用松散索引扫描</span>
<span class=k>SELECT</span><span class=w> </span><span class=n>c1</span><span class=p>,</span><span class=w> </span><span class=n>c2</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>t1</span><span class=w> </span><span class=k>GROUP</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>c1</span><span class=p>,</span><span class=w> </span><span class=n>c2</span><span class=p>;</span>
<span class=k>SELECT</span><span class=w> </span><span class=k>DISTINCT</span><span class=w> </span><span class=n>c1</span><span class=p>,</span><span class=w> </span><span class=n>c2</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>t1</span><span class=p>;</span>
<span class=k>SELECT</span><span class=w> </span><span class=n>c1</span><span class=p>,</span><span class=w> </span><span class=k>MIN</span><span class=p>(</span><span class=n>c2</span><span class=p>)</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>t1</span><span class=w> </span><span class=k>GROUP</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>c1</span><span class=p>;</span>
<span class=k>SELECT</span><span class=w> </span><span class=n>c1</span><span class=p>,</span><span class=w> </span><span class=n>c2</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>t1</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>c1</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>const</span><span class=w> </span><span class=k>GROUP</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>c1</span><span class=p>,</span><span class=w> </span><span class=n>c2</span><span class=p>;</span>
<span class=k>SELECT</span><span class=w> </span><span class=k>MAX</span><span class=p>(</span><span class=n>c3</span><span class=p>),</span><span class=w> </span><span class=k>MIN</span><span class=p>(</span><span class=n>c3</span><span class=p>),</span><span class=w> </span><span class=n>c1</span><span class=p>,</span><span class=w> </span><span class=n>c2</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>t1</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>c2</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=n>const</span><span class=w> </span><span class=k>GROUP</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>c1</span><span class=p>,</span><span class=w> </span><span class=n>c2</span><span class=p>;</span>
<span class=k>SELECT</span><span class=w> </span><span class=n>c2</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>t1</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>c1</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>const</span><span class=w> </span><span class=k>GROUP</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>c1</span><span class=p>,</span><span class=w> </span><span class=n>c2</span><span class=p>;</span>
<span class=k>SELECT</span><span class=w> </span><span class=n>c1</span><span class=p>,</span><span class=w> </span><span class=n>c2</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>t1</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>c3</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>const</span><span class=w> </span><span class=k>GROUP</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>c1</span><span class=p>,</span><span class=w> </span><span class=n>c2</span><span class=p>;</span>


<span class=c1>-- 下面的查询不能使用松散索引扫描</span>
<span class=k>SELECT</span><span class=w> </span><span class=n>c1</span><span class=p>,</span><span class=w> </span><span class=k>SUM</span><span class=p>(</span><span class=n>c2</span><span class=p>)</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>t1</span><span class=w> </span><span class=k>GROUP</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>c1</span><span class=p>;</span>
<span class=k>SELECT</span><span class=w> </span><span class=n>c1</span><span class=p>,</span><span class=w> </span><span class=n>c2</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>t1</span><span class=w> </span><span class=k>GROUP</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>c2</span><span class=p>,</span><span class=w> </span><span class=n>c3</span><span class=p>;</span>
<span class=k>SELECT</span><span class=w> </span><span class=n>c1</span><span class=p>,</span><span class=w> </span><span class=n>c3</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>t1</span><span class=w> </span><span class=k>GROUP</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>c1</span><span class=p>,</span><span class=w> </span><span class=n>c2</span><span class=p>;</span>
</code></pre></div> <p>为什么松散索引扫描被限制成只能MIN()和MAX()，而不能用其他的SUM()、COUNT()、AVG()、DISTINCT()等聚合函数呢？</p> <ul> <li> <p>索引是有序的。</p> </li> <li> <p>找到某一组的第一条记录就是该组的最小值，</p> </li> <li> <p>找到该组的最后一条记录就是该组的最大值。</p> </li> </ul> <p>所以，扫描时只需跳到每个组的第一行或最后一行，成本极低。<strong>松散索引的特性是"跳过组内大部分记录"，只看一条代表性的记录（比如第一条）</strong>。</p> <h6 id=tight-index-scan>紧凑索引扫描(Tight Index Scan)<a class=headerlink href=#tight-index-scan title="Permanent link">&para;</a></h6> <p>紧凑索引扫描可能是**全索引扫描**或者**范围索引扫描**，具体也要取决于查询条件。</p> <p>当松散索引扫描条件没有满足的时候，<code>GROUP BY</code>仍然有可能避免创建临时表。如果在 <code>WHERE</code> 条件有范围扫描，那么紧凑索引扫描仅读取满足这些条件的 keys（索引元组），否则执行全索引扫描。</p> <p>这种方式读取所有 <code>WHERE</code> 条件定义的范围内的 keys，或者扫描整个索引，因而称作**紧凑索引扫描**。对于紧凑索引扫描，只有在所有满足范围条件的 <code>keys</code> 被找到之后才会执行分组操作。</p> <p>如果紧凑索引扫描起作用，那么必须满足：</p> <p>在查询中存在常量相等<code>WHERE</code>条件字段（索引中的字段），且该字段在<code>GROUP BY</code>指定的字段的前面或者中间。来自于相等条件的常量能够填充搜索 keys 中的 gaps，因而可以构成一个索引的完整前缀。</p> <p>索引前缀能够用于索引查找。如果要求对<code>GROUP BY</code>的结果进行排序，并且查找字段组成一个索引前缀，那么 MySQL 同样可以避免额外的排序操作。</p> <div class=highlight><pre><span></span><code><span class=c1>-- （1）SQL执行计划 &quot;Using where; Using index&quot; 使用紧凑索引扫描，索引列范围查询</span>
<span class=k>explain</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=k>DISTINCT</span><span class=w> </span><span class=o>`</span><span class=n>c1</span><span class=o>`</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>t1</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=o>`</span><span class=n>c2</span><span class=o>`&gt;</span><span class=s1>&#39;B&#39;</span><span class=p>;</span>

<span class=c1>-- （2）SQL执行计划 &quot;Using where; Using index for group-by&quot; 使用松散索引扫描，索引列等值查询</span>
<span class=k>explain</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=k>DISTINCT</span><span class=w> </span><span class=o>`</span><span class=n>c1</span><span class=o>`</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>t1</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=o>`</span><span class=n>c2</span><span class=o>`=</span><span class=s1>&#39;B&#39;</span><span class=p>;</span>

<span class=c1>-- （3）SQL执行计划 &quot;Using index for group-by&quot; 使用松散索引扫描</span>
<span class=k>explain</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=k>MIN</span><span class=p>(</span><span class=n>c2</span><span class=p>)</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=n>t1</span><span class=w> </span><span class=k>group</span><span class=w> </span><span class=k>by</span><span class=w> </span><span class=n>c1</span><span class=p>;</span>

<span class=c1>-- （4）SQL执行计划 &quot;Using index&quot; 使用min/max之外的其它聚集函数，则不能使用松散索引扫描，使用紧凑索引扫描</span>
<span class=k>explain</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=k>SUM</span><span class=p>(</span><span class=n>c2</span><span class=p>)</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=n>t1</span><span class=w> </span><span class=k>group</span><span class=w> </span><span class=k>by</span><span class=w> </span><span class=n>c1</span><span class=p>;</span>

<span class=c1>-- （5）SQL执行计划 &quot;Using index for group-by&quot; 使用松散索引扫描，满足索引前缀</span>
<span class=k>explain</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=o>`</span><span class=n>c1</span><span class=o>`</span><span class=p>,</span><span class=o>`</span><span class=n>c2</span><span class=o>`</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>t1</span><span class=w> </span><span class=k>GROUP</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=o>`</span><span class=n>c1</span><span class=o>`</span><span class=p>,</span><span class=o>`</span><span class=n>c2</span><span class=o>`</span><span class=p>;</span>

<span class=c1>-- （6）SQL执行计划 &quot;Using where; Using index for group-by&quot; 使用松散索引扫描，满足索引前缀、索引列等值查询</span>
<span class=k>explain</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=o>`</span><span class=n>c1</span><span class=o>`</span><span class=p>,</span><span class=o>`</span><span class=n>c2</span><span class=o>`</span><span class=p>,</span><span class=o>`</span><span class=n>c3</span><span class=o>`</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>t1</span><span class=w>  </span><span class=k>WHERE</span><span class=w> </span><span class=n>c3</span><span class=o>=</span><span class=s1>&#39;C&#39;</span><span class=w> </span><span class=k>GROUP</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=o>`</span><span class=n>c1</span><span class=o>`</span><span class=p>,</span><span class=o>`</span><span class=n>c2</span><span class=o>`</span><span class=p>;</span>

<span class=c1>-- （7）SQL执行计划 &quot;Using where; Using index for group-by&quot; 使用松散索引扫描，虽然不满足索引前缀，但前缀中的列为常量</span>
<span class=k>explain</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=o>`</span><span class=n>c1</span><span class=o>`</span><span class=p>,</span><span class=o>`</span><span class=n>c2</span><span class=o>`</span><span class=p>,</span><span class=o>`</span><span class=n>c3</span><span class=o>`</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>t1</span><span class=w>  </span><span class=k>WHERE</span><span class=w> </span><span class=n>c1</span><span class=o>=</span><span class=s1>&#39;C&#39;</span><span class=w> </span><span class=k>GROUP</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=o>`</span><span class=n>c1</span><span class=o>`</span><span class=p>,</span><span class=o>`</span><span class=n>c2</span><span class=o>`</span><span class=p>,</span><span class=o>`</span><span class=n>c3</span><span class=o>`</span><span class=p>;</span>

<span class=c1>-- （8）SQL执行计划 &quot;Using index; Using temporary; Using filesort&quot;，使用临时表，不满足前缀索引，分组无法走索引，需要临时表并对分组内元素排序</span>
<span class=k>explain</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=o>`</span><span class=n>c2</span><span class=o>`</span><span class=p>,</span><span class=o>`</span><span class=n>c3</span><span class=o>`</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>t1</span><span class=w> </span><span class=k>GROUP</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=o>`</span><span class=n>c2</span><span class=o>`</span><span class=p>,</span><span class=o>`</span><span class=n>c3</span><span class=o>`</span><span class=p>;</span>

<span class=c1>-- （9）SQL执行计划 &quot;Using index; Using temporary; Using filesort&quot;，使用临时表，不满足前缀索引，分组无法走索引，需要临时表并对分组内元素排序</span>
<span class=k>explain</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=o>`</span><span class=n>c1</span><span class=o>`</span><span class=p>,</span><span class=o>`</span><span class=n>c3</span><span class=o>`</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>t1</span><span class=w> </span><span class=k>GROUP</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=o>`</span><span class=n>c1</span><span class=o>`</span><span class=p>,</span><span class=o>`</span><span class=n>c3</span><span class=o>`</span><span class=p>;</span>

<span class=c1>-- （10）SQL执行计划 &quot;Using where; Using index&quot;，使用紧凑索引扫描，却别于（9）使用临时表，尽管不满足前缀索引，但前缀中的列为常量</span>
<span class=k>explain</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=o>`</span><span class=n>c1</span><span class=o>`</span><span class=p>,</span><span class=o>`</span><span class=n>c3</span><span class=o>`</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>t1</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>c2</span><span class=o>=</span><span class=s1>&#39;B&#39;</span><span class=w> </span><span class=k>GROUP</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=o>`</span><span class=n>c1</span><span class=o>`</span><span class=p>,</span><span class=o>`</span><span class=n>c3</span><span class=o>`</span><span class=p>;</span>
</code></pre></div> <h6 id=_32>尽量使用内存表<a class=headerlink href=#_32 title="Permanent link">&para;</a></h6> <p>如果<code>GROUP BY</code>需要统计的数据不多，我们可以尽量只使用内存临时表；因为如果<code>GROUP BY</code>的过程因为内存临时表放不下数据，从而用到磁盘临时表的话，是比较耗时的。因此可以适当调大<code>tmp_table_size</code>参数，来避免用到磁盘临时表。</p> <h6 id=sql_big_result>使用 SQL_BIG_RESULT 优化<a class=headerlink href=#sql_big_result title="Permanent link">&para;</a></h6> <p>如果数据量实在太大怎么办呢？总不能无限调大<code>tmp_table_size</code>吧？但也不能眼睁睁看着数据先放到内存临时表，随着数据插入发现到达上限，再转成磁盘临时表吧？这样就有点不智能啦。</p> <p>因此，如果预估数据量比较大，我们使用<code>SQL_BIG_RESULT</code>这个提示直接用磁盘临时表。MySQl 优化器发现，磁盘临时表是 B+树存储，存储效率不如数组来得高。因此会直接用数组来存。</p> <div class=highlight><pre><span></span><code><span class=k>SELECT</span><span class=w> </span><span class=n>SQL_BIG_RESULT</span><span class=w> </span><span class=n>city</span><span class=p>,</span><span class=k>count</span><span class=p>(</span><span class=o>*</span><span class=p>)</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=n>num</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>staff</span><span class=w> </span><span class=k>GROUP</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>city</span><span class=p>;</span>
</code></pre></div> <h3 id=_33>对分组限定条件<a class=headerlink href=#_33 title="Permanent link">&para;</a></h3> <p>对分组的结果限定查询查询条件，使用 <code>HAVING</code> 子句，为要分组的标准限定条件。<strong>即对分组之后再对数据进行过滤</strong></p> <p>HAVING 操作的对象是组，那么其使用的要素是有一定限制的，能够使用的要素有 3 种: 常数、聚合函数和聚合键 ，聚合键也就是 <code>GROUP BY</code> 子句中指定的列名。</p> <p><code>WHERE</code>是在分组（聚合）前对记录进行筛选，而<code>HAVING</code>是在分组结束后的结果里筛选，最后返回过滤后的结果。</p> <p><code>HAVING</code>子句必须写在<code>GROUP BY</code>子句之后，其在<code>RDBMS</code>内部的执行顺序也排在<code>GROUP BY</code>子句之后。</p> <div class=highlight><pre><span></span><code><span class=c1>--仅查询平均工资大于4000的系，列出这样系的系名和平均工资</span>

<span class=k>SELECT</span><span class=w> </span><span class=n>dept_name</span><span class=w> </span><span class=p>,</span><span class=k>avg</span><span class=p>(</span><span class=n>salary</span><span class=p>)</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>instructor</span><span class=w> </span><span class=k>GROUP</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>dept_name</span><span class=w> </span><span class=k>HAVING</span><span class=w> </span><span class=k>AVG</span><span class=p>(</span><span class=n>salary</span><span class=p>)</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=mi>4000</span><span class=p>;</span>

<span class=k>SELECT</span><span class=w> </span><span class=n>user_id</span><span class=w>  </span><span class=k>FROM</span><span class=w> </span><span class=k>user</span><span class=w> </span><span class=k>GROUP</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>user_id</span>

<span class=c1>-- 另外一种思路，把所有系的平均工资查出来，再从这个结果里面查平均工资大于4000的</span>
<span class=k>SELECT</span><span class=w>   </span><span class=n>dept_name</span><span class=w> </span><span class=p>,</span><span class=w> </span><span class=k>avg</span><span class=p>(</span><span class=n>salary</span><span class=p>)</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=p>(</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=n>dept_name</span><span class=w> </span><span class=p>,</span><span class=k>avg</span><span class=p>(</span><span class=n>salary</span><span class=p>)</span><span class=w>  </span><span class=k>FROM</span><span class=w> </span><span class=n>instructor</span><span class=w> </span><span class=k>GROUP</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>dept_name</span><span class=w> </span><span class=p>)</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=k>AVG</span><span class=p>(</span><span class=n>salary</span><span class=p>)</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=mi>4000</span><span class=p>;</span>
</code></pre></div> <p><a href=https://www.cnblogs.com/youzhibing/p/14175336.html>参考</a></p> <h3 id=_34>去重查询<a class=headerlink href=#_34 title="Permanent link">&para;</a></h3> <p>按照<code>SQL</code>标准，<code>DISTINCT</code>是一种用于去除<code>SELECT</code>语句返回结果中重复行的关键字。在使用<code>SELECT</code>语句查询数据时，如果结果集中包含重复的行，可以使用<code>SELECT DISTINCT</code>语句来去除这些重复的行</p> <div class=highlight><pre><span></span><code><span class=c1>-- distinct支持单列、多列的去重方式</span>

<span class=k>SELECT</span><span class=w> </span><span class=n>name</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>users</span><span class=p>;</span><span class=w>                 </span><span class=c1>--返回一个包含重复行的结果集</span>
<span class=k>SELECT</span><span class=w> </span><span class=k>DISTINCT</span><span class=w> </span><span class=n>name</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>users</span><span class=p>;</span><span class=w>        </span><span class=c1>--去除重复的行</span>
<span class=c1>-- 需要注意的是，DISTINCT 关键字会对查询的性能产生一定的影响，因为它需要对结果集进行排序和去重的操作。因此，在使用 DISTINCT 关键字时需要谨慎，尽可能地使用索引来优化查询，以提高查询的性能。</span>

<span class=k>SELECT</span><span class=w> </span><span class=k>DISTINCT</span><span class=w> </span><span class=n>columns</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=k>table_name</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>where_conditions</span><span class=p>;</span><span class=w>   </span><span class=c1>--DISTINCT用法</span>
<span class=c1>-- 按照SQL标准，DISTINCT子句将所有NULL值视为相同的值，如果列具有NULL值，并且对该列使用DISTINCT子句，MySQL将保留一个NULL值，并删除其它的NULL值。</span>



<span class=c1>-- 多列的去重则是根据指定的去重的列信息来进行，即只有所有指定的列信息都相同，才会被认为是重复的信息。</span>
<span class=k>SELECT</span><span class=w> </span><span class=k>DISTINCT</span><span class=w> </span><span class=n>column1</span><span class=p>,</span><span class=n>column2</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=k>table_name</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>where_conditions</span><span class=p>;</span>


<span class=c1>-- 这条语句中的 DISTINCT 表示返回不同部门 id 和性别的组合值。</span>
<span class=k>SELECT</span><span class=w> </span><span class=k>DISTINCT</span><span class=w> </span><span class=n>dept_id</span><span class=p>,</span><span class=w> </span><span class=n>sex</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>employee</span><span class=p>;</span>

<span class=c1>-- GROUP BY也可以达到同样的效果</span>
<span class=k>SELECT</span><span class=w> </span><span class=n>dept_id</span><span class=p>,</span><span class=w> </span><span class=n>sexFROM</span><span class=w> </span><span class=n>employee</span><span class=w> </span><span class=k>GROUP</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>dept_id</span><span class=p>,</span><span class=w> </span><span class=n>sex</span><span class=p>;</span>
</code></pre></div> <div class=highlight><pre><span></span><code><span class=c1>-- 所有列都相同，才被认为是重复的。</span>
<span class=k>SELECT</span><span class=w> </span><span class=k>DISTINCT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=k>TABLE</span>

<span class=c1>-- 两条记录之间之后只有部分字段的值是有重复的，但是主键唯一</span>
<span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>ID</span><span class=w> </span><span class=k>IN</span><span class=w> </span><span class=p>(</span><span class=k>SELECT</span><span class=w> </span><span class=k>MAX</span><span class=p>(</span><span class=n>ID</span><span class=p>)</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=k>GROUP</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=p>[</span><span class=err>去除重复的字段名列表</span><span class=p>,....])</span>
</code></pre></div> <p><code>GROUP BY</code>主要的使用场景是在分组聚合。具体来说，<code>GROUP BY</code>子句通常用于将查询结果按照一个或多个列进行分组，然后对每个组进行聚合计算。</p> <p>例如，假设一个表存储了每个人的姓名、年龄和所在城市，可以使用<code>GROUP BY</code>子句按照城市对人进行分组，并计算每个城市的平均年龄或人口数量等统计信息。</p> <p><code>GROUP BY</code>子句通常与聚合函数（例如 COUNT、SUM、AVG、MAX 和 MIN）一起使用，以计算每个组的聚合值。例如，可以使用 <code>GROUP BY</code> 子句和 <code>COUNT</code> 函数来计算每个城市中的人数。</p> <p>但是，除了分组聚合，<code>GROUP BY</code>还可以用来进行数据去重</p> <blockquote> <p>需要注意的是：GROUP BY 子句会对结果集进行排序，因此可能会导致使用临时文件排序。如果查询中包含 ORDER BY 子句，使用不当会产生临时文件排序，容易产生慢 SQL 问题。</p> </blockquote> <p>MySQL 查询去重的小结</p> <ul> <li> <p>在语义相同，有索引的情况下，group by 和 distinct 效率相同； group by 和 distinct 都能使用索引，而索引天然有序，可以避免排序，因此二者效率相同；此情况下，group by 和 distinct 近乎等价，distinct 可以被看做是特殊的 group by；</p> </li> <li> <p>在语义相同，无索引的情况下，distinct 效率高于 group by； 原因是 distinct 和 group by 都会进行分组操作，但 group by 在 Mysql8.0 之前会进行隐式排序，导致触发 filesort，执行效率更低； 从 Mysql8.0 开始，Mysql 就删除了隐式排序；所以 Mysql8.0 后，此时在语义相同，无索引的情况下，group by 和 distinct 的执行效率也是近乎等价的；</p> </li> <li> <p>更推荐使用 group by； group by 语义更为清晰，可对数据进行更为复杂的一些处理；group by 的使用灵活性更高，group by 能根据分组情况，对数据进行更为复杂的处理，例如通过 having 对数据进行过滤，或通过聚合函数对数据进行运算；</p> </li> </ul> <h4 id=_35>分组去重的关系和区别<a class=headerlink href=#_35 title="Permanent link">&para;</a></h4> <h3 id=_36>集合查询<a class=headerlink href=#_36 title="Permanent link">&para;</a></h3> <div class=highlight><pre><span></span><code><span class=c1>-- SQL语句中存在3个著名的量词，SOME ALL 和 ANY</span>
<span class=c1>-- ALL：只有当其所有数据都满足条件时，条件才成立</span>
<span class=c1>-- ANY：只要有一条数据满足条件，条件就成立</span>
<span class=c1>-- SOME：其中存在一些数据满足条件，作用和Any大致相同 常规的使用中看作一致即可</span>

<span class=c1>-- AS 更名的用处：给查询结果的列名改一个名字，给要查询的表改一个名字。尤其是在同一个表中进行比较。</span>

<span class=c1>-- 教师表  instructor(ID, name, dept_name, salary)</span>
<span class=c1>-- 找出满足下面条件的所有教师的姓名：他们的工资比 Biology 系教师的最低工资要高</span>

<span class=c1>-- 方法一</span>
<span class=c1>-- 将一个表和它自己进行笛卡尔积运算，然后再过滤</span>
<span class=k>select</span><span class=w> </span><span class=k>distinct</span><span class=w> </span><span class=n>T</span><span class=p>.</span><span class=n>name</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=n>instructor</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=n>T</span><span class=p>,</span><span class=w> </span><span class=n>instructor</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=n>S</span><span class=w> </span><span class=k>where</span><span class=w> </span><span class=n>T</span><span class=p>.</span><span class=n>salary</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=n>S</span><span class=p>.</span><span class=n>salary</span><span class=w> </span><span class=k>and</span><span class=w> </span><span class=n>S</span><span class=p>.</span><span class=n>dep_tname</span><span class=o>=</span><span class=s1>&#39;Biology&#39;</span><span class=p>;</span>

<span class=c1>-- &gt;some 比较:  至少比集合中某一个值要大</span>
<span class=c1>-- 大于some就是：比最小的还要大</span>
<span class=c1>-- 小于some就是，比最大的还要小</span>
<span class=c1>--方法二</span>
<span class=c1>--等价上面的写法，使用 &gt; some 格式判断，子查询查出 Biology 系所有的工资组成集合。再用 &gt;some 比较</span>
<span class=k>select</span><span class=w> </span><span class=n>name</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=n>instructor</span><span class=w> </span><span class=k>where</span><span class=w> </span><span class=n>salary</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=k>some</span><span class=w> </span><span class=p>(</span><span class=k>select</span><span class=w> </span><span class=n>salary</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=n>instructor</span><span class=w> </span><span class=k>where</span><span class=w> </span><span class=n>dep_tname</span><span class=o>=</span><span class=s1>&#39;Biology&#39;</span><span class=w> </span><span class=p>);</span>



<span class=c1>-- 找出满足下面条件的所有教师的姓名：他们的工资比 Biology 系每个教师的最高工资要高</span>

<span class=c1>-- 方法一：子查询中找出Biology系的最高工资</span>
<span class=k>select</span><span class=w> </span><span class=n>name</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=n>instructor</span><span class=w> </span><span class=k>where</span><span class=w> </span><span class=n>salary</span><span class=w> </span><span class=o>&gt;</span><span class=w>  </span><span class=p>(</span><span class=k>select</span><span class=w> </span><span class=k>MAX</span><span class=p>(</span><span class=n>salary</span><span class=p>)</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=n>instructor</span><span class=w> </span><span class=k>where</span><span class=w> </span><span class=n>dep_tname</span><span class=o>=</span><span class=s1>&#39;Biology&#39;</span><span class=w>  </span><span class=p>);</span>

<span class=c1>-- 方法二：大于所有</span>
<span class=c1>-- &gt;all 比较，比集合中的所有值都大。</span>
<span class=k>select</span><span class=w> </span><span class=n>name</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=n>instructor</span><span class=w> </span><span class=k>where</span><span class=w> </span><span class=n>salary</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=k>all</span><span class=w> </span><span class=p>(</span><span class=k>select</span><span class=w> </span><span class=n>salary</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=n>instructor</span><span class=w> </span><span class=k>where</span><span class=w> </span><span class=n>dep_tname</span><span class=o>=</span><span class=s1>&#39;Biology&#39;</span><span class=w> </span><span class=p>);</span>

<span class=c1>-- 找出平均工资最高的系</span>

<span class=c1>-- 按系名分组，计算每个系的平均工资，并将结果按照平均工资从高到低排序。最后，只返回排序结果中的第一行，即平均成绩最高的那个系。</span>

<span class=k>SELECT</span>
<span class=w>  </span><span class=n>dept_name</span><span class=p>,</span>
<span class=w>  </span><span class=k>AVG</span><span class=p>(</span><span class=n>salary</span><span class=p>)</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=n>avg_salary</span>
<span class=k>FROM</span>
<span class=w>  </span><span class=n>instructor</span>
<span class=k>GROUP</span><span class=w> </span><span class=k>BY</span>
<span class=w>  </span><span class=n>dept_name</span>
<span class=k>ORDER</span><span class=w> </span><span class=k>BY</span>
<span class=w>  </span><span class=n>avg_salary</span><span class=w> </span><span class=k>DESC</span>
<span class=k>LIMIT</span>
<span class=w>  </span><span class=mi>1</span><span class=p>;</span>


<span class=c1>-- 方法：先查出所有系的平均工资做为一个集合，再在所有系的平均的工资里面比较，找出最大值。</span>
<span class=k>select</span><span class=w> </span><span class=n>dept_name</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=n>instructor</span><span class=w> </span><span class=k>group</span><span class=w> </span><span class=k>by</span><span class=w> </span><span class=n>dept_name</span><span class=w> </span><span class=k>having</span><span class=w> </span><span class=k>avg</span><span class=p>(</span><span class=n>salary</span><span class=p>)</span><span class=w> </span><span class=o>&gt;=</span><span class=k>all</span><span class=w> </span><span class=p>(</span><span class=k>select</span><span class=w> </span><span class=k>avg</span><span class=p>(</span><span class=n>salary</span><span class=p>)</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=n>instructor</span><span class=w> </span><span class=k>group</span><span class=w> </span><span class=k>by</span><span class=w> </span><span class=n>deptname</span><span class=p>);</span>
</code></pre></div> <h3 id=_37>集合运算<a class=headerlink href=#_37 title="Permanent link">&para;</a></h3> <p>SQL 面向集合特性最明显的体现就是 UNION（并集运算）、INTERSECT（交集运算）和 EXCEPT/MINUS（差集运算）。</p> <p>这些集合运算符的作用都是将两个集合并成一个集合，因此需要满足以下条件：</p> <ul> <li>两边的集合中字段的数量和顺序必须相同；</li> <li>两边的集合中对应字段的类型必须匹配或兼容。</li> </ul> <p>具体来说，<code>UNION</code> 和 <code>UNION ALL</code> 用于计算两个集合的并集，返回出现在第一个查询结果或者第二个查询结果中的数据。它们的区别在于 <code>UNION</code> 排除了结果中的重复数据，<code>UNION ALL</code> 保留了重复数据。</p> <p><code>SQL</code> 中的关系概念来自数学中的集合理论，因此 <code>UNION</code>、<code>INTERSECT</code> 和 <code>EXCEPT</code> 分别来自集合论中的<code>并集（$\cup$）</code>、<code>交集（$\cap$）</code>和<code>差集（$\setminus$）</code>运算。需要注意的是，集合理论中的集合不允许存在重复的数据，但是 <code>SQL</code> 允许。</p> <p>因此，<code>SQL</code> 中的集合也被称为多重集合（multiset）；多重集合与集合理论中的集合都是无序的，但是 <code>SQL</code> 可以通过 <code>ORDER BY</code> 子句对查询结果进行排序。</p> <div class=highlight><pre><span></span><code><span class=c1>-- 并集（union）</span>

<span class=c1>-- 并集 union 自动去重(效率很低)，将两个结果集求并集，如果想合并没有刻意要删除重复行。可以保留重复，则使用union all</span>

<span class=c1>-- UNION 必须由两条或两条以上的 SELECT 语句组成，语句之间用关键字 UNION 分隔（因此，如果组合4条 SELECT 语句，将要使用3个UNION 关键字）。</span>
<span class=c1>-- UNION 中的每个查询必须包含相同的列、表达式或聚集函数（不过各个列不需要以相同的次序列出）。</span>
<span class=c1>-- 列数据类型必须兼容：类型不必完全相同，但必须是DBMS可以隐含地转换的类型（例如，不同的数值类型或不同的日期类型）。</span>

<span class=c1>-- 找出在2009年秋季或在2010年春季开课的课程信息</span>
<span class=p>(</span><span class=k>select</span><span class=w> </span><span class=n>course_id</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=n>section</span><span class=w> </span><span class=k>where</span><span class=w> </span><span class=n>semester</span><span class=o>=</span><span class=s1>&#39;Fall&#39;</span><span class=w> </span><span class=k>and</span><span class=w> </span><span class=k>year</span><span class=o>=</span><span class=mi>2009</span><span class=p>)</span><span class=w> </span><span class=k>union</span><span class=w> </span><span class=p>(</span><span class=k>select</span><span class=w> </span><span class=n>course_id</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=n>section</span><span class=w> </span><span class=k>where</span><span class=w> </span><span class=n>semester</span><span class=o>=</span><span class=s1>&#39;Spring&#39;</span><span class=w> </span><span class=k>and</span><span class=w> </span><span class=k>year</span><span class=o>=</span><span class=mi>2010</span><span class=p>);</span>

<span class=c1>-- 也等价于下面这条查询</span>
<span class=k>select</span><span class=w> </span><span class=n>course_id</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=n>section</span><span class=w> </span><span class=k>where</span><span class=w> </span><span class=p>(</span><span class=n>semester</span><span class=o>=</span><span class=s1>&#39;Fall&#39;</span><span class=w> </span><span class=k>and</span><span class=w> </span><span class=k>year</span><span class=o>=</span><span class=mi>2009</span><span class=p>)</span><span class=w> </span><span class=k>or</span><span class=w> </span><span class=p>(</span><span class=n>semester</span><span class=o>=</span><span class=s1>&#39;Spring&#39;</span><span class=w> </span><span class=k>and</span><span class=w> </span><span class=k>year</span><span class=o>=</span><span class=mi>2010</span><span class=p>);</span>



<span class=c1>-- 交集（intersect all）</span>

<span class=c1>-- 交集 intersect all</span>
<span class=c1>-- 找出在2009年秋季和2010年春季同时开课的课程信息</span>
<span class=p>(</span><span class=k>select</span><span class=w> </span><span class=n>course_id</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=n>section</span><span class=w> </span><span class=k>where</span><span class=w> </span><span class=n>semester</span><span class=o>=</span><span class=s1>&#39;Fall&#39;</span><span class=w> </span><span class=k>and</span><span class=w> </span><span class=k>year</span><span class=o>=</span><span class=mi>2009</span><span class=p>)</span><span class=w> </span><span class=k>intersect</span><span class=w> </span><span class=k>all</span><span class=w> </span><span class=p>(</span><span class=k>select</span><span class=w> </span><span class=n>course_id</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=n>section</span><span class=w> </span><span class=k>where</span><span class=w> </span><span class=n>semester</span><span class=o>=</span><span class=s1>&#39;Spring&#39;</span><span class=w> </span><span class=k>and</span><span class=w> </span><span class=k>year</span><span class=o>=</span><span class=mi>2010</span><span class=p>);</span>


<span class=c1>-- 差运算 (expect)</span>
<span class=c1>-- EXCEPT 子句/运算符用于将两个 SELECT 语句结合在一起，并返回第一个 SELECT 语句的结果中那些不存在于第二个 SELECT 语句结果的记录</span>
<span class=c1>-- 找出在2009年秋季开课，2010年春季没开课的课程信息</span>
<span class=p>(</span><span class=k>select</span><span class=w> </span><span class=n>course_id</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=n>section</span><span class=w> </span><span class=k>where</span><span class=w> </span><span class=n>semester</span><span class=o>=</span><span class=s1>&#39;Fall&#39;</span><span class=w> </span><span class=k>and</span><span class=w> </span><span class=k>year</span><span class=o>=</span><span class=mi>2009</span><span class=p>)</span><span class=w> </span><span class=n>expect</span><span class=w> </span><span class=p>(</span><span class=k>select</span><span class=w> </span><span class=n>course_id</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=n>section</span><span class=w> </span><span class=k>where</span><span class=w> </span><span class=n>semester</span><span class=o>=</span><span class=s1>&#39;Spring&#39;</span><span class=w> </span><span class=k>and</span><span class=w> </span><span class=k>year</span><span class=o>=</span><span class=mi>2010</span><span class=p>);</span>



<span class=c1>-- 集合成员资格测试  in ，测试元组是否是集合中的成员。集合一般是由select查出来的。用于筛出在集合中的元素。</span>

<span class=c1>-- 找出在2009年秋季和2010年春季同时开课的课程信息</span>
<span class=c1>-- in关键字用于测试关素是否是集合中的成员。对于这个例子，3个查询条件：1、秋季；2、2009学期，3、课程id必须2010年春季开课的课程id一样。</span>
<span class=c1>-- 使用in关键字来描述这个查询。</span>
<span class=k>select</span><span class=w> </span><span class=n>course_id</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=n>section</span><span class=w> </span><span class=k>where</span><span class=w> </span><span class=n>semester</span><span class=o>=</span><span class=s1>&#39;Fall&#39;</span><span class=w> </span><span class=k>and</span><span class=w> </span><span class=k>year</span><span class=o>=</span><span class=mi>2009</span><span class=w> </span><span class=k>and</span><span class=w> </span><span class=n>course_id</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=p>(</span><span class=k>select</span><span class=w> </span><span class=n>course_id</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=n>section</span><span class=w> </span><span class=k>where</span><span class=w> </span><span class=n>semester</span><span class=o>=</span><span class=s1>&#39;Spring&#39;</span><span class=w> </span><span class=k>and</span><span class=w> </span><span class=k>year</span><span class=o>=</span><span class=mi>2010</span><span class=p>);</span>


<span class=c1>-- 集合成员资格测试 not in ，测试元组是否是集合中的成员。用于筛出不在集合中的元素。</span>
</code></pre></div> <h3 id=_38>行转列/列转行<a class=headerlink href=#_38 title="Permanent link">&para;</a></h3> <p>行列转换在做报表分析时是经常遇到的</p> <ul> <li> <p>行转列：将多行数据转换成一行显示，或将一列数据转换成多列显示。</p> </li> <li> <p>列转行：将一行数据转换成多行显示，或将多列数据转换成一列显示。</p> </li> </ul> <div class=highlight><pre><span></span><code><span class=k>create</span><span class=w> </span><span class=k>table</span><span class=w> </span><span class=n>rowtocolumn</span><span class=w> </span><span class=p>(</span><span class=n>name</span><span class=w> </span><span class=n>string</span><span class=p>,</span><span class=w> </span><span class=n>subject</span><span class=w> </span><span class=n>string</span><span class=p>,</span><span class=w> </span><span class=k>result</span><span class=w> </span><span class=nb>bigint</span><span class=p>);</span>
<span class=k>insert</span><span class=w> </span><span class=k>into</span><span class=w> </span><span class=k>table</span><span class=w> </span><span class=n>rowtocolumn</span><span class=w> </span><span class=k>values</span>
<span class=p>(</span><span class=s1>&#39;张三&#39;</span><span class=w> </span><span class=p>,</span><span class=w> </span><span class=s1>&#39;语文&#39;</span><span class=w> </span><span class=p>,</span><span class=w> </span><span class=mi>74</span><span class=p>),</span>
<span class=p>(</span><span class=s1>&#39;张三&#39;</span><span class=w> </span><span class=p>,</span><span class=w> </span><span class=s1>&#39;数学&#39;</span><span class=w> </span><span class=p>,</span><span class=w> </span><span class=mi>83</span><span class=p>),</span>
<span class=p>(</span><span class=s1>&#39;张三&#39;</span><span class=w> </span><span class=p>,</span><span class=w> </span><span class=s1>&#39;物理&#39;</span><span class=w> </span><span class=p>,</span><span class=w> </span><span class=mi>93</span><span class=p>),</span>
<span class=p>(</span><span class=s1>&#39;李四&#39;</span><span class=w> </span><span class=p>,</span><span class=w> </span><span class=s1>&#39;语文&#39;</span><span class=w> </span><span class=p>,</span><span class=w> </span><span class=mi>74</span><span class=p>),</span>
<span class=p>(</span><span class=s1>&#39;李四&#39;</span><span class=w> </span><span class=p>,</span><span class=w> </span><span class=s1>&#39;数学&#39;</span><span class=w> </span><span class=p>,</span><span class=w> </span><span class=mi>84</span><span class=p>),</span>
<span class=p>(</span><span class=s1>&#39;李四&#39;</span><span class=w> </span><span class=p>,</span><span class=w> </span><span class=s1>&#39;物理&#39;</span><span class=w> </span><span class=p>,</span><span class=w> </span><span class=mi>94</span><span class=p>);</span>
</code></pre></div> <h3 id=sql-null-default>SQL 中的 null 和 DEFAULT<a class=headerlink href=#sql-null-default title="Permanent link">&para;</a></h3> <p>根据 ANSI SQL-92 规范，<code>NULL</code>既不是空字符串(对于字符或日期时间数据类型)，也不是零值(对于数字数据类型)。</p> <p>为了确保所有 null 被统一处理，ANSI SQL-92 规范规定所有数据类型的 null 必须是相同的。</p> <p>在 postgresql 14 中或更早的版本，唯一性约束将 null 与 null 视为是不相同的。这与 sql 标准是相同的，简而言之，null 表示 unknown。因而，null 值也就不违反唯一性约束。</p> <p>对于给定记录，当属性没有要存储的数据时，它由 SQL 值 NULL 表示。<strong>NULL 不是一个「值」，而是「没有值」。</strong></p> <ul> <li> <p>Oracle 将 NULL 和空字符串都当作 NULL 来处理。Oracle 需要一个 byte 来存储 NULL。</p> </li> <li> <p>PostgreSQL 将 NULL 和空字符串分开处理，NULL 是 NULL，空字符串是空字符串。PostgreSQL 不需要空间来存储 NULL。</p> </li> <li> <p>SQL Server 也是将 NULL 和空字符串分开处理，NULL 是 NULL，空字符串是空字符串。SQL Server 不需要空间来存储 NULL。</p> </li> </ul> <p>NULL 和空字符串上的唯一性约束</p> <ul> <li> <p>Oracle 中，具有唯一性约束的列，可以包含任意数量的 NULL 和空字符串；</p> </li> <li> <p>SQLServer 中，只是允许有一个 NULL、一个空字符串。</p> </li> <li> <p>对于 NULL，PostgreSQL 的处理方式类似 Oracle，而对于空字符串，PostgreSQL 的处理方式类似 SQLServer。</p> </li> <li> <p>MySQL ，唯一索引创建一个约束，使得索引中的所有值都必须是不同的。如果尝试添加一个键值与现有行匹配的新行，则会发生错误。如果在唯一索引中为列指定前缀值，则列值在前缀长度内必须是唯一的。唯一索引允许包含空值的列有多个空值。</p> </li> </ul> <p><strong>NULL</strong></p> <p>在 SQL 中建表，每个字段后面都加上 NULL 或 NOT NULL 修饰符来指定该字段是否可以为空(NULL)，还是说必须填上数据(NOT NULL)。</p> <p>MySQL 默认情况下指定字段为 NULL 修饰符，如果一个字段指定为 NOT NULL，MySQL 则不允许向该字段插入空值(这里面说的空值都为 NULL)，因为这是"规定"。</p> <p>但是在自增列和 TIMESTAMP 字段中，这个规则并不适用。向这些字段中插入 NULL 值将会导致插入下一个自动增加的值或者当前的时间戳。</p> <p>在 MySQL 中 null 不能使用任何运算符与其他字段或者变量（函数、存储过程）进行运算。若使用运算数据就可能会有问题。</p> <p>在写 SQL 条件语句时经常用到 不等于 != 的筛选条件。</p> <p>此时要注意此条件会将字段为 Null 的数据也当做满足不等于的条件而将数据筛选掉。（也就是说会忽略过滤掉为 null 的数据，导致数据不准确）。</p> <h3 id=_39>元数据查询<a class=headerlink href=#_39 title="Permanent link">&para;</a></h3> <div class=highlight><pre><span></span><code><span class=c1>-- 列出模式中的所有表</span>
<span class=w>    </span><span class=k>SELECT</span><span class=w> </span><span class=k>table_name</span>
<span class=w>    </span><span class=k>FROM</span><span class=w> </span><span class=n>information_schema</span><span class=p>.</span><span class=n>tables</span>
<span class=w>    </span><span class=k>WHERE</span><span class=w> </span><span class=n>table_schema</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s1>&#39;dbo&#39;</span>

<span class=c1>--列出表中的列</span>
<span class=w>   </span><span class=k>SELECT</span><span class=w> </span><span class=k>column_name</span><span class=p>,</span><span class=w> </span><span class=n>data_type</span><span class=p>,</span><span class=w> </span><span class=n>ordinal_position</span>
<span class=w>    </span><span class=k>FROM</span><span class=w> </span><span class=n>information_schema</span><span class=p>.</span><span class=n>columns</span>
<span class=w>    </span><span class=k>WHERE</span><span class=w> </span><span class=n>table_schema</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s1>&#39;dbo&#39;</span>
<span class=w>    </span><span class=k>AND</span><span class=w> </span><span class=k>table_name</span><span class=w>   </span><span class=o>=</span><span class=w> </span><span class=s1>&#39;EMP&#39;</span>
<span class=c1>--列出表的索引列</span>
<span class=w>    </span><span class=k>SELECT</span><span class=w> </span><span class=n>a</span><span class=p>.</span><span class=n>name</span><span class=w> </span><span class=k>table_name</span><span class=p>,</span>
<span class=w>        </span><span class=n>b</span><span class=p>.</span><span class=n>name</span><span class=w> </span><span class=n>index_name</span><span class=p>,</span>
<span class=w>        </span><span class=n>d</span><span class=p>.</span><span class=n>name</span><span class=w> </span><span class=k>column_name</span><span class=p>,</span>
<span class=w>        </span><span class=k>c</span><span class=p>.</span><span class=n>index_column_id</span>
<span class=w>    </span><span class=k>FROM</span><span class=w> </span><span class=n>sys</span><span class=p>.</span><span class=n>tables</span><span class=w> </span><span class=n>a</span><span class=p>,</span>
<span class=w>        </span><span class=n>sys</span><span class=p>.</span><span class=n>indexes</span><span class=w> </span><span class=n>b</span><span class=p>,</span>
<span class=w>        </span><span class=n>sys</span><span class=p>.</span><span class=n>index_columns</span><span class=w> </span><span class=k>c</span><span class=p>,</span>
<span class=w>        </span><span class=n>sys</span><span class=p>.</span><span class=n>columns</span><span class=w> </span><span class=n>d</span>
<span class=w>    </span><span class=k>WHERE</span><span class=w> </span><span class=n>a</span><span class=p>.</span><span class=n>object_id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>b</span><span class=p>.</span><span class=n>object_id</span>
<span class=w>         </span><span class=k>AND</span><span class=w> </span><span class=n>b</span><span class=p>.</span><span class=n>object_id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>c</span><span class=p>.</span><span class=n>object_id</span>
<span class=w>         </span><span class=k>AND</span><span class=w> </span><span class=n>b</span><span class=p>.</span><span class=n>index_id</span><span class=w>  </span><span class=o>=</span><span class=w> </span><span class=k>c</span><span class=p>.</span><span class=n>index_id</span>
<span class=w>         </span><span class=k>AND</span><span class=w> </span><span class=k>c</span><span class=p>.</span><span class=n>object_id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>d</span><span class=p>.</span><span class=n>object_id</span>
<span class=w>         </span><span class=k>AND</span><span class=w> </span><span class=k>c</span><span class=p>.</span><span class=n>column_id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>d</span><span class=p>.</span><span class=n>column_id</span>
<span class=w>         </span><span class=k>AND</span><span class=w> </span><span class=n>a</span><span class=p>.</span><span class=n>name</span><span class=w>      </span><span class=o>=</span><span class=w> </span><span class=s1>&#39;EMP&#39;</span>
<span class=c1>--5.4 列出表的约束</span>
<span class=w>     </span><span class=k>SELECT</span><span class=w> </span><span class=n>a</span><span class=p>.</span><span class=k>table_name</span><span class=p>,</span>
<span class=w>         </span><span class=n>a</span><span class=p>.</span><span class=k>constraint_name</span><span class=p>,</span>
<span class=w>         </span><span class=n>b</span><span class=p>.</span><span class=k>column_name</span><span class=p>,</span>
<span class=w>         </span><span class=n>a</span><span class=p>.</span><span class=n>constraint_type</span>
<span class=w>     </span><span class=k>FROM</span><span class=w> </span><span class=n>information_schema</span><span class=p>.</span><span class=n>table_constraints</span><span class=w> </span><span class=n>a</span><span class=p>,</span>
<span class=w>          </span><span class=n>information_schema</span><span class=p>.</span><span class=n>key_column_usage</span><span class=w> </span><span class=n>b</span>
<span class=w>     </span><span class=k>WHERE</span><span class=w> </span><span class=n>a</span><span class=p>.</span><span class=k>table_name</span><span class=w>      </span><span class=o>=</span><span class=w> </span><span class=s1>&#39;EMP&#39;</span>
<span class=w>           </span><span class=k>AND</span><span class=w> </span><span class=n>a</span><span class=p>.</span><span class=n>table_schema</span><span class=w>    </span><span class=o>=</span><span class=w> </span><span class=s1>&#39;dbo&#39;</span>
<span class=w>           </span><span class=k>AND</span><span class=w> </span><span class=n>a</span><span class=p>.</span><span class=k>table_name</span><span class=w>      </span><span class=o>=</span><span class=w> </span><span class=n>b</span><span class=p>.</span><span class=k>table_name</span>
<span class=w>           </span><span class=k>AND</span><span class=w> </span><span class=n>a</span><span class=p>.</span><span class=n>table_schema</span><span class=w>    </span><span class=o>=</span><span class=w> </span><span class=n>b</span><span class=p>.</span><span class=n>table_schema</span>
<span class=w>           </span><span class=k>AND</span><span class=w> </span><span class=n>a</span><span class=p>.</span><span class=k>constraint_name</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>b</span><span class=p>.</span><span class=k>constraint_name</span>

<span class=c1>--列出没有相应索引的外键</span>
<span class=w>    </span><span class=k>SELECT</span>
<span class=w>    </span><span class=n>fkeys</span><span class=p>.</span><span class=k>table_name</span><span class=p>,</span>
<span class=w>    </span><span class=n>fkeys</span><span class=p>.</span><span class=k>constraint_name</span><span class=p>,</span>
<span class=w>    </span><span class=n>fkeys</span><span class=p>.</span><span class=k>column_name</span><span class=p>,</span>
<span class=w>    </span><span class=n>ind_cols</span><span class=p>.</span><span class=n>index_name</span>
<span class=k>FROM</span>
<span class=w>    </span><span class=p>(</span>
<span class=w>    </span><span class=k>SELECT</span>
<span class=w>        </span><span class=n>a</span><span class=p>.</span><span class=n>object_id</span><span class=p>,</span>
<span class=w>        </span><span class=n>d</span><span class=p>.</span><span class=n>column_id</span><span class=p>,</span>
<span class=w>        </span><span class=n>a</span><span class=p>.</span><span class=n>NAME</span><span class=w> </span><span class=k>table_name</span><span class=p>,</span>
<span class=w>        </span><span class=n>b</span><span class=p>.</span><span class=n>NAME</span><span class=w> </span><span class=k>constraint_name</span><span class=p>,</span>
<span class=w>        </span><span class=n>d</span><span class=p>.</span><span class=n>NAME</span><span class=w> </span><span class=k>column_name</span>
<span class=w>    </span><span class=k>FROM</span>
<span class=w>        </span><span class=n>sys</span><span class=p>.</span><span class=n>TABLES</span><span class=w> </span><span class=n>a</span>
<span class=w>        </span><span class=k>JOIN</span><span class=w> </span><span class=n>sys</span><span class=p>.</span><span class=n>foreign_keys</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=k>ON</span><span class=w> </span><span class=p>(</span><span class=w> </span><span class=n>a</span><span class=p>.</span><span class=n>NAME</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s1>&#39;EMP&#39;</span><span class=w> </span><span class=k>AND</span><span class=w> </span><span class=n>a</span><span class=p>.</span><span class=n>object_id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>b</span><span class=p>.</span><span class=n>parent_object_id</span><span class=w> </span><span class=p>)</span>
<span class=w>        </span><span class=k>JOIN</span><span class=w> </span><span class=n>sys</span><span class=p>.</span><span class=n>foreign_key_columns</span><span class=w> </span><span class=k>c</span><span class=w> </span><span class=k>ON</span><span class=w> </span><span class=p>(</span><span class=w> </span><span class=n>b</span><span class=p>.</span><span class=n>object_id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>c</span><span class=p>.</span><span class=n>constraint_object_id</span><span class=w> </span><span class=p>)</span>
<span class=w>        </span><span class=k>JOIN</span><span class=w> </span><span class=n>sys</span><span class=p>.</span><span class=n>COLUMNS</span><span class=w> </span><span class=n>d</span><span class=w> </span><span class=k>ON</span><span class=w> </span><span class=p>(</span><span class=w> </span><span class=k>c</span><span class=p>.</span><span class=n>constraint_column_id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>d</span><span class=p>.</span><span class=n>column_id</span><span class=w> </span><span class=k>AND</span><span class=w> </span><span class=n>a</span><span class=p>.</span><span class=n>object_id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>d</span><span class=p>.</span><span class=n>object_id</span><span class=w> </span><span class=p>)</span>
<span class=w>    </span><span class=p>)</span><span class=w> </span><span class=n>fkeys</span>
<span class=w>    </span><span class=k>LEFT</span><span class=w> </span><span class=k>JOIN</span><span class=w> </span><span class=p>(</span>
<span class=w>    </span><span class=k>SELECT</span>
<span class=w>        </span><span class=n>a</span><span class=p>.</span><span class=n>NAME</span><span class=w> </span><span class=n>index_name</span><span class=p>,</span>
<span class=w>        </span><span class=n>b</span><span class=p>.</span><span class=n>object_id</span><span class=p>,</span>
<span class=w>        </span><span class=n>b</span><span class=p>.</span><span class=n>column_id</span>
<span class=w>    </span><span class=k>FROM</span>
<span class=w>        </span><span class=n>sys</span><span class=p>.</span><span class=n>indexes</span><span class=w> </span><span class=n>a</span><span class=p>,</span>
<span class=w>        </span><span class=n>sys</span><span class=p>.</span><span class=n>index_columns</span><span class=w> </span><span class=n>b</span>
<span class=w>    </span><span class=k>WHERE</span>
<span class=w>        </span><span class=n>a</span><span class=p>.</span><span class=n>index_id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>b</span><span class=p>.</span><span class=n>index_id</span>
<span class=w>    </span><span class=p>)</span><span class=w> </span><span class=n>ind_cols</span><span class=w> </span><span class=k>ON</span><span class=w> </span><span class=p>(</span><span class=w> </span><span class=n>fkeys</span><span class=p>.</span><span class=n>object_id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>ind_cols</span><span class=p>.</span><span class=n>object_id</span><span class=w> </span><span class=k>AND</span><span class=w> </span><span class=n>fkeys</span><span class=p>.</span><span class=n>column_id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>ind_cols</span><span class=p>.</span><span class=n>column_id</span><span class=w> </span><span class=p>)</span>
<span class=k>WHERE</span>
<span class=w>    </span><span class=n>ind_cols</span><span class=p>.</span><span class=n>index_name</span><span class=w> </span><span class=k>IS</span><span class=w> </span><span class=k>NULL</span>
</code></pre></div> <h2 id=_40>运算符<a class=headerlink href=#_40 title="Permanent link">&para;</a></h2> <p>数据库，除了数据的存取之外，还支持各种运算，主要包括 <strong>算数运算</strong> 和 <strong>逻辑运算</strong> 。</p> <table> <thead> <tr> <th style="text-align: left;">算数运算符</th> <th style="text-align: left;">作用</th> </tr> </thead> <tbody> <tr> <td style="text-align: left;">+</td> <td style="text-align: left;">加法</td> </tr> <tr> <td style="text-align: left;">-</td> <td style="text-align: left;">减法</td> </tr> <tr> <td style="text-align: left;">*</td> <td style="text-align: left;">乘法</td> </tr> <tr> <td style="text-align: left;">/ 或 DIV</td> <td style="text-align: left;">除法</td> </tr> <tr> <td style="text-align: left;">% 或 MOD</td> <td style="text-align: left;">取余</td> </tr> </tbody> </table> <table> <thead> <tr> <th>运算符</th> <th></th> <th></th> </tr> </thead> <tbody> <tr> <td>=</td> <td>等于</td> <td></td> </tr> <tr> <td>&lt;&gt;, !=</td> <td></td> <td></td> </tr> <tr> <td>&gt;</td> <td></td> <td></td> </tr> <tr> <td>&lt;</td> <td></td> <td></td> </tr> <tr> <td>&gt;=</td> <td></td> <td></td> </tr> <tr> <td>&lt;=</td> <td></td> <td></td> </tr> <tr> <td>BETWEEN</td> <td></td> <td></td> </tr> <tr> <td>NOT BETWEEN</td> <td></td> <td></td> </tr> <tr> <td>IN</td> <td>判断操作数是否为 IN 列表中的一个值</td> <td></td> </tr> <tr> <td>NOT IN</td> <td></td> <td></td> </tr> <tr> <td>&lt;=&gt;</td> <td>安全的等于</td> <td></td> </tr> <tr> <td>LIKE</td> <td></td> <td></td> </tr> <tr> <td></td> <td></td> <td></td> </tr> <tr> <td></td> <td></td> <td></td> </tr> </tbody> </table> <p>逻辑连接词</p> <p>汉语里的或、且、非</p> <table> <thead> <tr> <th>逻辑运算符</th> <th></th> <th></th> </tr> </thead> <tbody> <tr> <td>NOT 或 ！</td> <td>表示逻辑非</td> <td></td> </tr> <tr> <td>AND 或 &amp;&amp;</td> <td>表示逻辑与运算</td> <td></td> </tr> <tr> <td>OR 或 ||</td> <td></td> <td></td> </tr> <tr> <td>&lt;</td> <td></td> <td></td> </tr> <tr> <td>&gt;=</td> <td></td> <td></td> </tr> </tbody> </table> <p>运算符优先级</p> <table> <thead> <tr> <th>优先级由低到高排列</th> <th>运算符</th> <th>含义</th> </tr> </thead> <tbody> <tr> <td>1</td> <td>=(赋值运算）、:=</td> <td></td> </tr> <tr> <td>2</td> <td>II、OR</td> <td></td> </tr> <tr> <td>3</td> <td>XOR</td> <td></td> </tr> <tr> <td>4</td> <td>&amp;&amp;、AND</td> <td></td> </tr> <tr> <td>5</td> <td>NOT</td> <td></td> </tr> <tr> <td>6</td> <td>BETWEEN、CASE、WHEN、THEN、ELSE</td> <td></td> </tr> <tr> <td>7</td> <td>=(比较运算）、&lt;=&gt;、&gt;=、&gt;、&lt;=、&lt;、&lt;&gt;、!=、 IS、LIKE、REGEXP、IN</td> <td></td> </tr> <tr> <td>8</td> <td>|</td> <td></td> </tr> <tr> <td>9</td> <td>&amp;</td> <td></td> </tr> <tr> <td>10</td> <td>&lt;&lt;、&gt;&gt;</td> <td></td> </tr> <tr> <td>11</td> <td>-(减号）、+(加号)</td> <td></td> </tr> <tr> <td>12 *、/、%</td> <td>*、/、%</td> <td></td> </tr> <tr> <td>13 ^</td> <td></td> <td></td> </tr> <tr> <td>14 -(负号）、〜（位反转）</td> <td></td> <td></td> </tr> <tr> <td>15 !</td> <td></td> <td></td> </tr> <tr> <td></td> <td></td> <td></td> </tr> <tr> <td></td> <td></td> <td></td> </tr> </tbody> </table> <p>运算符的优先级决定了不同的运算符在表达式中计算的先后顺序，一般情况下，级别高的运算符优先进行计算，如果级别相同，MySQL 按表达式的顺序从左到右依次计算，在无法确定优先级的情况下，可以使用圆括号"()"来改变优先级，并且这样会使计算过程更加清晰。</p> <p><code>Select * from users where id=1 and 1=1;</code> 这条语句为什么能够选择出 id=1 的内容，and 1=1 到底起作用了没有？</p> <p>三个条件用 and 和 or 进行连接。在 sql 中，我们 and 的运算优先级大于 or 的元算优先级。</p> <p>对于 MySQL 三大数据类型，数值类型，字符，时间</p> <p>当两个不同类型的数据进行运算时，为了使得它们能够兼容，MySQL 可能会执行隐式的数据类型转换。例如，MySQL 在需要时会自动将字符串转换为数字，反之亦然。</p> <ul> <li>如果任意一个参数为 NULL，比较运算符的结果为 NULL，&lt;=&gt; 相等比较运算符除外。NULL &lt;=&gt; NULL 的运算结果为 true，不需要进行类型转换。</li> <li>如果两个参数都是字符串，执行字符串比较。</li> </ul> <h2 id=_41>函数<a class=headerlink href=#_41 title="Permanent link">&para;</a></h2> <p>SQL 主要的功能就是对数据进行处理和分析。为了提高数据处理的效率，SQL 为我们提供了许多预定义的功能模块，也就是函数（Function）。</p> <p>SQL 函数是一种具有某种数据处理功能的模块，它可以接收零个或多个输入值，并且返回一个输出值。SQL 中的函数主要分为以下两种类型：</p> <ul> <li>标量函数（Scalar Function），针对每个输入参数返回一个输出结果。例如 ABS(x)函数可以计算 x 的绝对值。</li> <li>聚合函数（Aggregate Function），基于一组输入参数进行汇总并返回一个结果。例如 AVG(x)函数可以计算一组数据的平均值。</li> </ul> <h3 id=_42>数学函数<a class=headerlink href=#_42 title="Permanent link">&para;</a></h3> <div class=highlight><pre><span></span><code><span class=k>ABS</span><span class=p>(</span><span class=n>x</span><span class=p>)</span><span class=w>                              </span><span class=c1>-- 返回x的绝对值</span>

<span class=n>BIN</span><span class=p>(</span><span class=n>x</span><span class=p>)</span><span class=w>                              </span><span class=c1>-- 进制转转：返回x的二进制（OCT返回八进制，HEX返回十六进制），其中x为正整数</span>
<span class=n>CONV</span><span class=p>(</span><span class=n>N</span><span class=p>,</span><span class=n>from_base</span><span class=p>,</span><span class=n>to_base</span><span class=p>)</span><span class=w>           </span><span class=c1>-- 进制转换：数字按照进制互转：N为要被转换的数字，原始进制，目标进制</span>

<span class=n>CEILING</span><span class=p>(</span><span class=n>x</span><span class=p>)</span><span class=w>                          </span><span class=c1>-- 向上取整:返回大于x的最小整数值</span>
<span class=n>FLOOR</span><span class=p>(</span><span class=n>x</span><span class=p>)</span><span class=w>                            </span><span class=c1>-- 向下取整：返回小于x的最大整数值</span>

<span class=n>EXP</span><span class=p>(</span><span class=n>x</span><span class=p>)</span><span class=w>                              </span><span class=c1>-- 返回值e（自然对数的底）的x次方</span>
<span class=n>LN</span><span class=p>(</span><span class=n>x</span><span class=p>)</span><span class=w>                               </span><span class=c1>-- 返回x的自然对数</span>
<span class=n>LOG</span><span class=p>(</span><span class=n>x</span><span class=p>,</span><span class=n>y</span><span class=p>)</span><span class=w>                            </span><span class=c1>-- 返回x的以y为底的对数</span>

<span class=n>GREATEST</span><span class=p>(</span><span class=n>x1</span><span class=p>,</span><span class=n>x2</span><span class=p>,...,</span><span class=n>xn</span><span class=p>)</span><span class=w>              </span><span class=c1>-- 返回集合中最大的值</span>
<span class=n>LEAST</span><span class=p>(</span><span class=n>x1</span><span class=p>,</span><span class=n>x2</span><span class=p>,...,</span><span class=n>xn</span><span class=p>)</span><span class=w>                 </span><span class=c1>-- 返回集合中最小的值</span>

<span class=k>MOD</span><span class=p>(</span><span class=n>x</span><span class=p>,</span><span class=n>y</span><span class=p>)</span><span class=w>                            </span><span class=c1>-- 返回x/y的模（余数）</span>
<span class=n>PI</span><span class=p>()</span><span class=w>                                </span><span class=c1>-- 返回pi的值（圆周率）</span>
<span class=n>RAND</span><span class=p>()</span><span class=w>                              </span><span class=c1>-- 返回0到1内的随机值,可以通过提供一个参数(种子)使RAND()随机数生成器生成一个指定的值。</span>
<span class=n>ROUND</span><span class=p>(</span><span class=n>x</span><span class=p>,</span><span class=n>y</span><span class=p>)</span><span class=w>                          </span><span class=c1>-- 返回参数x的四舍五入的有y位小数的值</span>
<span class=n>SIGN</span><span class=p>(</span><span class=n>x</span><span class=p>)</span><span class=w>                             </span><span class=c1>-- 返回代表数字x的符号的值</span>
<span class=n>SQRT</span><span class=p>(</span><span class=n>x</span><span class=p>)</span><span class=w>                             </span><span class=c1>-- 返回一个数的平方根</span>
<span class=k>TRUNCATE</span><span class=p>(</span><span class=n>x</span><span class=p>,</span><span class=n>y</span><span class=p>)</span><span class=w>                       </span><span class=c1>-- 返回数字x截短为y位小数的结果</span>

<span class=c1>-- 数学函数，因为其操作得都是数字，建议仅作用于数字类型的字段或常量上</span>
</code></pre></div> <h3 id=_43>聚合函数<a class=headerlink href=#_43 title="Permanent link">&para;</a></h3> <p><code>Aggregate Function</code>翻译成聚合函数，从多行输入计算单个结果行。返回的结果是基于行组而不是单行（与 single row funtion 单行函数的区别）。</p> <p>它可以出现在选择列表、order by 子语、having 子语中。</p> <p>通常我们见到的 select 分组字段, sum() from 表名 group by 分组字段 [having ...]形式的分组汇总 SQL，其中的 SUM 函数就是聚合函数，常用的聚合函数还有 COUNT、AVG、MAX、MIN 等。</p> <p>聚合函数有时也被称为汇总函数、分组函数。</p> <p>聚集函数是以值的一个集合为输入、返回单个值的函数，标准 SQL 提供了五个固有的聚集函数：</p> <ul> <li>平均值 avg</li> <li>最小值 min</li> <li>最大值 max</li> <li>总和 sum</li> <li>计数 count</li> </ul> <div class=highlight><pre><span></span><code><span class=c1>--查询Biology系的平均工资</span>
<span class=k>select</span><span class=w> </span><span class=k>avg</span><span class=p>(</span><span class=n>salary</span><span class=p>)</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=n>instructor</span><span class=w> </span><span class=k>where</span><span class=w> </span><span class=n>dept_name</span><span class=o>=</span><span class=s1>&#39;Biology&#39;</span>
</code></pre></div> <h3 id=_44>字符串函数<a class=headerlink href=#_44 title="Permanent link">&para;</a></h3> <p>字符函数用于字符数据的处理，例如字符串的拼接、大小写转换、子串的查找和替换等。</p> <div class=highlight><pre><span></span><code><span class=n>ASCII</span><span class=p>(</span><span class=nb>char</span><span class=p>)</span><span class=w>                             </span><span class=c1>-- 返回字符的ASCII码值      select ASCII(&quot;a&quot;) ——&gt; 97</span>

<span class=c1>-- 连接字符串</span>
<span class=n>CONCAT</span><span class=p>(</span><span class=n>s1</span><span class=p>,</span><span class=n>s2</span><span class=p>...,</span><span class=n>sn</span><span class=p>)</span><span class=w>                     </span><span class=c1>-- 将s1,s2...,s等多个字符串拼接连接成一个字符串  select CONCAT(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;); ——&gt; abc</span>
<span class=w>                                        </span><span class=c1>-- Oracle中的CONCAT函数一次只能连接两个字符 Oracle和PostgreSQL也提供了连接运算符（||），Microsoft SQL Server使用加号（+）作为连接运算符。</span>
<span class=c1>-- MySQL、Microsoft SQL Server以及PostgreSQL</span>
<span class=n>CONCAT_WS</span><span class=p>(</span><span class=n>sep</span><span class=p>,</span><span class=n>s1</span><span class=p>,</span><span class=n>s2</span><span class=p>...,</span><span class=n>sn</span><span class=p>)</span><span class=w>              </span><span class=c1>-- 将s1,s2...,sn连接成字符串，并用sep字符间隔   select CONCAT_WS(&quot;-&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;) ——&gt; a-b-c</span>

<span class=c1>-- 查找子串</span>
<span class=k>SUBSTRING</span><span class=p>(</span><span class=n>s</span><span class=p>,</span><span class=w> </span><span class=n>n</span><span class=p>,</span><span class=w> </span><span class=n>m</span><span class=p>)</span><span class=w>                      </span><span class=c1>-- 函数返回字符串s中从位置n开始的m个字符的子串。 SELECT SUBSTRING(&#39;数据库&#39;, 1, 2); ——&gt; 数据</span>
<span class=n>FIELD</span><span class=p>(</span><span class=n>str</span><span class=p>,</span><span class=n>str1</span><span class=p>,</span><span class=n>str2</span><span class=p>,</span><span class=n>str3</span><span class=p>,...)</span><span class=w>           </span><span class=c1>-- 返回str在(str1,str2,str3,...)中出现的位置， SELECT FIELD(&#39;Bb&#39;, &#39;Aa&#39;, &#39;Bb&#39;, &#39;Cc&#39;, &#39;Dd&#39;, &#39;Ff&#39;);</span>
<span class=k>POSITION</span><span class=p>(</span><span class=n>substr</span><span class=p>,</span><span class=n>str</span><span class=p>)</span><span class=w>                    </span><span class=c1>-- 返回子串substr在字符串str中第一次出现的位置</span>

<span class=c1>-- 获取子串</span>
<span class=c1>-- MySQL、Microsoft SQL Server以及PostgreSQL提供了LEFT(s, n)和RIGHT(s, n)函数，分别用于返回字符串开头和结尾的n个字符。</span>

<span class=c1>-- 子串查找与替换</span>
<span class=k>INSERT</span><span class=p>(</span><span class=n>str</span><span class=p>,</span><span class=n>x</span><span class=p>,</span><span class=n>y</span><span class=p>,</span><span class=n>instr</span><span class=p>)</span><span class=w>                   </span><span class=c1>-- 将字符串str从第x位置开始，y个字符长的子串替换为字符串instr，返回结果</span>

<span class=n>FIND_IN_SET</span><span class=p>(</span><span class=n>str</span><span class=p>,</span><span class=n>list</span><span class=p>)</span><span class=w>                   </span><span class=c1>-- 分析逗号分隔的list列表，如果发现str，返回str在list中的位置  SELECT FIND_IN_SET(&#39;b&#39;,&#39;a,b,c,d&#39;);</span>

<span class=c1>-- 大小写转换</span>
<span class=n>LCASE</span><span class=p>(</span><span class=n>str</span><span class=p>)</span><span class=err>或</span><span class=k>LOWER</span><span class=p>(</span><span class=n>str</span><span class=p>)</span><span class=w>                  </span><span class=c1>-- 返回将字符串str中所有字符改变为小写后的结果</span>
<span class=k>LEFT</span><span class=p>(</span><span class=n>str</span><span class=p>,</span><span class=n>x</span><span class=p>)</span><span class=w>                             </span><span class=c1>-- 返回字符串str中最左边的x个字符</span>



<span class=c1>-- 字符串长度</span>
<span class=c1>-- 字符串的长度可以按照两种方式进行计算：字符数量和字节数量。</span>
<span class=c1>-- CHAR_LENGTH(s)函数用于计算字符串中的字符数量</span>
<span class=c1>-- OCTET_LENGTH(s)函数用于计算字符串包含的字节数量。</span>
<span class=c1>-- 字符串“数据库”包含3个字符，在UTF-8编码中占用9个字节。MySQL和PostgreSQL实现了这两个标准函数。</span>
<span class=k>SELECT</span><span class=w> </span><span class=k>CHAR_LENGTH</span><span class=p>(</span><span class=s1>&#39;数据库&#39;</span><span class=p>),</span><span class=w> </span><span class=k>OCTET_LENGTH</span><span class=p>(</span><span class=s1>&#39;数据库&#39;</span><span class=p>);</span><span class=w>  </span><span class=c1>--3 9</span>
<span class=k>LENGTH</span><span class=p>(</span><span class=n>str</span><span class=p>)</span><span class=w>                             </span><span class=c1>-- 返回字符串str的字节数(字节数)   select length(_utf8 &#39;中&#39;); ——&gt; 3</span>
<span class=k>CHAR_LENGTH</span><span class=p>(</span><span class=n>str</span><span class=p>)</span><span class=w>                        </span><span class=c1>-- 返回字符串的字符数量(字符个数)   select  char_length(_utf8 &#39;中&#39;) ——&gt; 1</span>
<span class=k>BIT_LENGTH</span><span class=p>(</span><span class=n>str</span><span class=p>)</span><span class=w>                         </span><span class=c1>-- 返回字符串的比特长度</span>

<span class=c1>-- 截断字符串</span>

<span class=c1>-- LTRIM(s)函数可以删除字符串开头的空格，RTRIM(s)函数可以删除字符串尾部的空格，这两个函数是TRIM函数的简化版</span>
<span class=n>LTRIM</span><span class=p>(</span><span class=n>str</span><span class=p>)</span><span class=w>                              </span><span class=c1>-- 从字符串str中切掉开头的空格</span>
<span class=n>RTRIM</span><span class=p>(</span><span class=n>str</span><span class=p>)</span><span class=w>                              </span><span class=c1>-- 返回字符串str尾部的空格</span>


<span class=n>QUOTE</span><span class=p>(</span><span class=n>str</span><span class=p>)</span><span class=w>                              </span><span class=c1>-- 用反斜杠转义str中的单引号</span>
<span class=n>REPEAT</span><span class=p>(</span><span class=n>str</span><span class=p>,</span><span class=n>srchstr</span><span class=p>,</span><span class=n>rplcstr</span><span class=p>)</span><span class=w>             </span><span class=c1>-- 返回字符串str重复x次的结果</span>
<span class=n>REVERSE</span><span class=p>(</span><span class=n>str</span><span class=p>)</span><span class=w>                            </span><span class=c1>-- 返回颠倒字符串str的结果</span>
<span class=k>REPLACE</span><span class=p>(</span><span class=n>str</span><span class=p>,</span><span class=n>old_string</span><span class=p>,</span><span class=n>new_string</span><span class=p>);</span><span class=w>     </span><span class=c1>-- REPLACE()函数有三个参数，它将string中的old_string替换为new_string字符串。</span>
<span class=k>RIGHT</span><span class=p>(</span><span class=n>str</span><span class=p>,</span><span class=n>x</span><span class=p>)</span><span class=w>                            </span><span class=c1>-- 返回字符串str中最右边的x个字符</span>

<span class=n>STRCMP</span><span class=p>(</span><span class=n>s1</span><span class=p>,</span><span class=n>s2</span><span class=p>)</span><span class=w>                           </span><span class=c1>-- 比较字符串s1和s2</span>
<span class=k>TRIM</span><span class=p>(</span><span class=n>str</span><span class=p>)</span><span class=w>                               </span><span class=c1>-- 去除字符串首部和尾部的所有空格</span>
<span class=n>UCASE</span><span class=p>(</span><span class=n>str</span><span class=p>)</span><span class=err>或</span><span class=k>UPPER</span><span class=p>(</span><span class=n>str</span><span class=p>)</span><span class=w>                  </span><span class=c1>-- 返回将字符串str中所有字符转变为大写后的结果</span>


<span class=k>select</span><span class=w> </span><span class=k>length</span><span class=p>(</span><span class=n>_utf8</span><span class=w> </span><span class=s1>&#39;€&#39;</span><span class=p>),</span><span class=w> </span><span class=k>char_length</span><span class=p>(</span><span class=n>_utf8</span><span class=w> </span><span class=s1>&#39;€&#39;</span><span class=p>)</span>
<span class=c1>--&gt; 3, 1</span>



<span class=n>mysql</span><span class=o>&gt;</span><span class=w> </span><span class=k>SET</span><span class=w> </span><span class=o>@</span><span class=n>dolphin</span><span class=p>:</span><span class=o>=</span><span class=s1>&#39;海豚&#39;</span><span class=p>;</span>
<span class=n>Query</span><span class=w> </span><span class=n>OK</span><span class=p>,</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=k>rows</span><span class=w> </span><span class=n>affected</span><span class=w> </span><span class=p>(</span><span class=mi>0</span><span class=p>.</span><span class=mi>01</span><span class=w> </span><span class=n>sec</span><span class=p>)</span>

<span class=n>mysql</span><span class=o>&gt;</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=k>LENGTH</span><span class=p>(</span><span class=o>@</span><span class=n>dolphin</span><span class=p>),</span><span class=w> </span><span class=k>CHAR_LENGTH</span><span class=p>(</span><span class=o>@</span><span class=n>dolphin</span><span class=p>);</span>
<span class=o>+</span><span class=c1>------------------+-----------------------+</span>
<span class=o>|</span><span class=w> </span><span class=k>LENGTH</span><span class=p>(</span><span class=o>@</span><span class=n>dolphin</span><span class=p>)</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=k>CHAR_LENGTH</span><span class=p>(</span><span class=o>@</span><span class=n>dolphin</span><span class=p>)</span><span class=w> </span><span class=o>|</span>
<span class=o>+</span><span class=c1>------------------+-----------------------+</span>
<span class=o>|</span><span class=w>                </span><span class=mi>6</span><span class=w> </span><span class=o>|</span><span class=w>                     </span><span class=mi>2</span><span class=w> </span><span class=o>|</span>
<span class=o>+</span><span class=c1>------------------+-----------------------+</span>
<span class=mi>1</span><span class=w> </span><span class=k>row</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=k>set</span><span class=w> </span><span class=p>(</span><span class=mi>0</span><span class=p>.</span><span class=mi>00</span><span class=w> </span><span class=n>sec</span><span class=p>)</span>
</code></pre></div> <h3 id=_45>日期时间函数<a class=headerlink href=#_45 title="Permanent link">&para;</a></h3> <div class=highlight><pre><span></span><code><span class=n>NOW</span><span class=p>()</span>
<span class=c1>-- NOW()函数返回当前的日期和时间，包括年月日时分秒。例如：2024-01-05 07:31:28。</span>

<span class=k>CURRENT_TIMESTAMP</span><span class=p>()</span>
<span class=c1>-- CURRENT_TIMESTAMP()函数返回当前的日期和时间，包括年月日时分秒。例如：2024-01-05 07:31:28。</span>
<span class=c1>-- 与NOW()函数类似，但是CURRENT_TIMESTAMP()是标准SQL语法，而NOW()是MySQL特有的函数。</span>
<span class=c1>-- 也可以用变量CURRENT_TIMESTAMP表示当前日期和时间</span>

<span class=c1>-- 设置字段属性为时间戳类型，且把默认值设置成CURRENT_TIMESTAMP的情况下。如果你设置了时间随当前时间戳更新（ ON UPDATE CURRENT_TIMESTAMP），那么当你更新字段时，只有字段值发生变化了，你的时间字段才会变为UPDATE操作时的时间</span>

<span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>t1</span><span class=w> </span><span class=p>(</span>
<span class=w>  </span><span class=n>ts</span><span class=w> </span><span class=k>TIMESTAMP</span><span class=w> </span><span class=k>DEFAULT</span><span class=w> </span><span class=k>CURRENT_TIMESTAMP</span><span class=w> </span><span class=k>ON</span><span class=w> </span><span class=k>UPDATE</span><span class=w> </span><span class=k>CURRENT_TIMESTAMP</span><span class=p>,</span>
<span class=w>  </span><span class=n>dt</span><span class=w> </span><span class=n>DATETIME</span><span class=w> </span><span class=k>DEFAULT</span><span class=w> </span><span class=k>CURRENT_TIMESTAMP</span><span class=w> </span><span class=k>ON</span><span class=w> </span><span class=k>UPDATE</span><span class=w> </span><span class=k>CURRENT_TIMESTAMP</span>
<span class=p>);</span>


<span class=n>SYSDATE</span><span class=p>()</span>
<span class=c1>-- SYSDATE()函数返回当前的日期和时间，与NOW()函数类似，包括年月日时分秒。例如：2024-01-05 07:31:28。</span>
<span class=c1>-- 但是SYSDATE()函数在每次调用时会从操作系统获取当前时间，而NOW()函数在连接建立时获取一次，并在连接期间返回相同的值。</span>

<span class=k>select</span><span class=w> </span><span class=n>now</span><span class=p>(),</span><span class=w> </span><span class=n>sysdate</span><span class=p>(),</span><span class=n>sleep</span><span class=p>(</span><span class=mi>3</span><span class=p>),</span><span class=w> </span><span class=n>now</span><span class=p>(),</span><span class=n>sysdate</span><span class=p>();</span>
<span class=mi>2019</span><span class=o>-</span><span class=mi>12</span><span class=o>-</span><span class=mi>29</span><span class=w> </span><span class=mi>23</span><span class=p>:</span><span class=mi>49</span><span class=p>:</span><span class=mi>27</span><span class=w> </span><span class=mi>2019</span><span class=o>-</span><span class=mi>12</span><span class=o>-</span><span class=mi>29</span><span class=w> </span><span class=mi>23</span><span class=p>:</span><span class=mi>49</span><span class=p>:</span><span class=mi>27</span><span class=w> </span><span class=mi>0</span><span class=w>   </span><span class=mi>2019</span><span class=o>-</span><span class=mi>12</span><span class=o>-</span><span class=mi>29</span><span class=w> </span><span class=mi>23</span><span class=p>:</span><span class=mi>49</span><span class=p>:</span><span class=mi>27</span><span class=w> </span><span class=mi>2019</span><span class=o>-</span><span class=mi>12</span><span class=o>-</span><span class=mi>29</span><span class=w> </span><span class=mi>23</span><span class=p>:</span><span class=mi>49</span><span class=p>:</span><span class=mi>30</span>



<span class=n>CURDATE</span><span class=p>()</span>
<span class=c1>-- CURDATE()函数返回当前的日期，只包括年月日，不包括时间。例如：2024-01-05。</span>


<span class=k>CURRENT_DATE</span><span class=p>()</span>
<span class=c1>-- CURRENT_DATE()函数返回当前的日期，只包括年月日，不包括时间。例如：2024-01-05。</span>

<span class=err>其返回值的格式为</span><span class=w> </span><span class=err>‘</span><span class=n>YYYY</span><span class=o>-</span><span class=n>MM</span><span class=o>-</span><span class=n>DD</span><span class=err>’，其中</span><span class=w> </span><span class=err>‘</span><span class=n>YYYY</span><span class=err>’</span><span class=w> </span><span class=err>表示年份，‘</span><span class=n>MM</span><span class=err>’</span><span class=w> </span><span class=err>表示月份，‘</span><span class=n>DD</span><span class=err>’</span><span class=w> </span><span class=err>表示日期。</span>


<span class=n>CURTIME</span><span class=p>()</span>
<span class=c1>-- CURTIME()函数返回当前的时间，只包括时分秒，不包括日期。例如：07:31:28。</span>

<span class=k>CURRENT_TIME</span><span class=p>():</span>
<span class=c1>-- CURRENT_TIME()函数返回当前的时间，只包括时分秒，不包括日期。例如：07:31:28。</span>


<span class=c1>-- 当前日期：2022-05-27</span>
<span class=k>select</span><span class=w> </span><span class=nb>DATE</span><span class=p>(</span><span class=k>CURRENT_TIME</span><span class=p>)</span>

<span class=c1>-- sysdate() 日期时间函数跟 now() 类似。一般很少用到</span>
<span class=c1>-- 不同之处在于：now() 在执行开始时值就得到了， sysdate() 在函数执行时动态得到值。</span>



<span class=c1>-- 查询一天</span>
<span class=k>select</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=err>表名</span><span class=w> </span><span class=k>where</span><span class=w> </span><span class=n>to_days</span><span class=p>(</span><span class=err>时间字段名</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>to_days</span><span class=p>(</span><span class=n>now</span><span class=p>());</span>
<span class=k>select</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=err>表名</span><span class=w> </span><span class=k>where</span><span class=w> </span><span class=nb>date</span><span class=p>(</span><span class=err>时间字段名</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>curdate</span><span class=p>();</span>

<span class=c1>--昨天</span>
<span class=k>select</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=err>表名</span><span class=w> </span><span class=k>where</span><span class=w> </span><span class=n>to_days</span><span class=p>(</span><span class=w> </span><span class=n>now</span><span class=p>(</span><span class=w> </span><span class=p>)</span><span class=w> </span><span class=p>)</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>to_days</span><span class=p>(</span><span class=w> </span><span class=err>时间字段名</span><span class=p>)</span><span class=w> </span><span class=o>&lt;=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span>

<span class=c1>--7天</span>
<span class=k>select</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=err>表名</span><span class=w> </span><span class=k>where</span><span class=w> </span><span class=n>date_sub</span><span class=p>(</span><span class=n>curdate</span><span class=p>(),</span><span class=w> </span><span class=nb>interval</span><span class=w> </span><span class=mi>7</span><span class=w> </span><span class=k>day</span><span class=p>)</span><span class=w> </span><span class=o>&lt;=</span><span class=w> </span><span class=nb>date</span><span class=p>(</span><span class=err>时间字段名</span><span class=p>);</span>

<span class=c1>--本周内</span>
<span class=k>select</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=err>表名</span><span class=w> </span><span class=k>where</span><span class=w> </span><span class=err>时间字段名</span><span class=w> </span><span class=k>between</span><span class=w> </span><span class=k>current_date</span><span class=p>()</span><span class=o>-</span><span class=mi>7</span><span class=w> </span><span class=k>and</span><span class=w> </span><span class=n>sysdate</span><span class=p>();</span>

<span class=c1>--近30天</span>
<span class=k>select</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=err>表名</span><span class=w> </span><span class=k>where</span><span class=w> </span><span class=n>date_sub</span><span class=p>(</span><span class=n>curdate</span><span class=p>(),</span><span class=w> </span><span class=nb>interval</span><span class=w> </span><span class=mi>30</span><span class=w> </span><span class=k>day</span><span class=p>)</span><span class=w> </span><span class=o>&lt;=</span><span class=w> </span><span class=nb>date</span><span class=p>(</span><span class=err>时间字段名</span><span class=p>);</span>
<span class=k>select</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=n>tbl_name</span><span class=w> </span><span class=k>where</span><span class=w> </span><span class=n>to_days</span><span class=p>(</span><span class=n>now</span><span class=p>())</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>to_days</span><span class=p>(</span><span class=n>date_col</span><span class=p>)</span><span class=w> </span><span class=o>&lt;=</span><span class=w> </span><span class=mi>30</span><span class=p>;</span>

<span class=c1>--本月</span>
<span class=k>select</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=err>表名</span><span class=w> </span><span class=k>where</span><span class=w> </span><span class=n>date_format</span><span class=p>(</span><span class=w> </span><span class=err>时间字段名</span><span class=p>,</span><span class=w> </span><span class=s1>&#39;%Y%m&#39;</span><span class=w> </span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>date_format</span><span class=p>(</span><span class=n>curdate</span><span class=p>(</span><span class=w> </span><span class=p>)</span><span class=w> </span><span class=p>,</span><span class=w> </span><span class=s1>&#39;%Y%m&#39;</span><span class=w> </span><span class=p>)</span>

<span class=c1>-- 查询一个月</span>
<span class=k>select</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=k>table</span><span class=w> </span><span class=k>where</span><span class=w> </span><span class=n>date_sub</span><span class=p>(</span><span class=n>curdate</span><span class=p>(),</span><span class=w> </span><span class=nb>interval</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=k>month</span><span class=p>)</span><span class=w> </span><span class=o>&lt;=</span><span class=w> </span><span class=nb>date</span><span class=p>(</span><span class=n>column_time</span><span class=p>);</span>

<span class=c1>-- 上一月</span>
<span class=k>select</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=err>表名</span><span class=w> </span><span class=k>where</span><span class=w> </span><span class=n>period_diff</span><span class=p>(</span><span class=w> </span><span class=n>date_format</span><span class=p>(</span><span class=w> </span><span class=n>now</span><span class=p>(</span><span class=w> </span><span class=p>)</span><span class=w> </span><span class=p>,</span><span class=w> </span><span class=s1>&#39;%Y%m&#39;</span><span class=w> </span><span class=p>)</span><span class=w> </span><span class=p>,</span><span class=w> </span><span class=n>date_format</span><span class=p>(</span><span class=w> </span><span class=err>时间字段名</span><span class=p>,</span><span class=w> </span><span class=s1>&#39;%Y%m&#39;</span><span class=w> </span><span class=p>)</span><span class=w> </span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=mi>1</span>
</code></pre></div> <p><strong>其他函数</strong></p> <div class=highlight><pre><span></span><code><span class=c1>-- 当前MySQL版本  5.7.26-log</span>
<span class=k>select</span><span class=w> </span><span class=k>version</span><span class=p>()</span>

<span class=c1>-- 字符串长度： 3 ，3 ，1   length返回字节长度，char_length返回字符数量</span>
<span class=k>select</span><span class=w> </span><span class=k>length</span><span class=p>(</span><span class=ss>&quot;我&quot;</span><span class=p>)</span><span class=w> </span><span class=p>,</span><span class=w> </span><span class=k>length</span><span class=p>(</span><span class=ss>&quot;你&quot;</span><span class=p>)</span><span class=w> </span><span class=p>,</span><span class=w> </span><span class=k>char_length</span><span class=p>(</span><span class=ss>&quot;你&quot;</span><span class=p>);</span>

<span class=c1>-- 日期格式化  2019-12-27</span>
<span class=k>select</span><span class=w> </span><span class=n>date_format</span><span class=p>(</span><span class=n>now</span><span class=p>(),</span><span class=s1>&#39;%y-%m-%d&#39;</span><span class=p>);</span>



<span class=c1>-- md5加密:8a6f60827608e7f1ae29d1abcecffc3a</span>
<span class=k>select</span><span class=w> </span><span class=n>md5</span><span class=p>(</span><span class=ss>&quot;andyqian&quot;</span><span class=p>);</span>
<span class=c1>-- 字符串拼接 andyqian</span>
<span class=k>select</span><span class=w> </span><span class=n>concat</span><span class=p>(</span><span class=ss>&quot;andy&quot;</span><span class=p>,</span><span class=ss>&quot;qian&quot;</span><span class=p>);</span>

<span class=c1>-- if函数判断</span>

<span class=k>select</span><span class=w> </span><span class=n>t</span><span class=p>.</span><span class=n>name</span><span class=p>,</span><span class=k>if</span><span class=p>(</span><span class=n>t</span><span class=p>.</span><span class=n>weight</span><span class=o>&lt;</span><span class=mi>80</span><span class=p>,</span><span class=s1>&#39;正常&#39;</span><span class=p>,</span><span class=s1>&#39;肥胖&#39;</span><span class=p>)</span><span class=w> </span><span class=err>体重</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=n>t_customer</span><span class=w> </span><span class=n>t</span>
</code></pre></div> <p><a href=https://www.kancloud.cn/taobaomysql/monthly/181781>参考</a></p> <h2 id=_46>触发器<a class=headerlink href=#_46 title="Permanent link">&para;</a></h2> <p>触发器是每当发生与表相关的事件时自动调用的函数。事件可以是以下任何一种：INSERT，UPDATE，DELETE 或 TRUNCATE。</p> <p>触发器是绑定到表的特殊的用户自定义函数。<strong>触发器和用户自定义函数的不同之处在于触发事件(当表发生变化时)发生时会自动调用</strong>。</p> <p>触发器一旦由某用户定义，任何用户对触发器规定的数据进行更新操作，均自动激活相应的触发器采取应对措施。</p> <p>触发器本质上是一条 SQL 语句，当对数据库中的表做更新操作时，它自动被系统执行。</p> <p>触发器三要素：</p> <ul> <li> <p>事件：引起触发器动作的事件，通常是更新操作。</p> </li> <li> <p>条件：触发器将测试条件是否满足。如果条件满足，就执行相应的操作，否则什么也不做。</p> </li> <li> <p>动作：如果触发器测试满足预订的条件，就由 DBMS 执行这些动作。这些动作可以是一系列对数据库的操作</p> </li> </ul> <div class=highlight><pre><span></span><code><span class=c1>-- 创建触发器的语法</span>

<span class=k>CREATE</span><span class=w> </span><span class=p>[</span><span class=k>DEFINER</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>user</span><span class=p>]</span><span class=w> </span><span class=k>TRIGGER</span><span class=w> </span><span class=k>trigger_name</span><span class=w> </span><span class=n>tirgger_time</span><span class=w> </span><span class=n>trigger_event</span>
<span class=k>ON</span><span class=w> </span><span class=n>tbl_name</span><span class=w> </span><span class=k>FOR</span><span class=w> </span><span class=k>EACH</span><span class=w> </span><span class=k>ROW</span>
<span class=k>BEGIN</span>
<span class=w>    </span><span class=n>trigger_stmt</span>
<span class=k>END</span>

<span class=c1>-- trigger_name：触发器的名称</span>
<span class=c1>-- tirgger_time：触发时机，为BEFORE或者AFTER</span>
<span class=c1>-- rigger_event：触发事件，为INSERT、DELETE或者UPDATE</span>
<span class=c1>-- tb_name：表示建立触发器的表明，就是在哪张表上建立触发器</span>
<span class=c1>-- trigger_stmt：触发器的动作程序体，可以是一条SQL语句或者是用BEGIN和END包含的多条语句</span>
</code></pre></div> <h2 id=_47>存储过程<a class=headerlink href=#_47 title="Permanent link">&para;</a></h2> <h3 id=_48>流程控制语句<a class=headerlink href=#_48 title="Permanent link">&para;</a></h3> <table> <thead> <tr> <th>语句</th> <th></th> <th></th> </tr> </thead> <tbody> <tr> <td><a href=https://dev.mysql.com/doc/refman/8.0/en/flow-control-functions.html#operator_case><code>CASE</code></a></td> <td></td> <td></td> </tr> <tr> <td><a href=https://dev.mysql.com/doc/refman/8.0/en/flow-control-functions.html#function_if><code>IF()</code></a></td> <td></td> <td></td> </tr> <tr> <td><a href=https://dev.mysql.com/doc/refman/8.0/en/flow-control-functions.html#function_ifnull><code>IFNULL()</code></a></td> <td></td> <td></td> </tr> <tr> <td><a href=https://dev.mysql.com/doc/refman/8.0/en/flow-control-functions.html#function_nullif><code>NULLIF()</code></a></td> <td></td> <td></td> </tr> </tbody> </table> <h2 id=_49>窗口函数<a class=headerlink href=#_49 title="Permanent link">&para;</a></h2> <p>窗口函数（Window Function）是 <code>SQL2003</code> 标准中定义的一项新特性，并在 <code>SQL2011</code> 和 <code>SQL2016</code> 中又加以完善，添加了若干处拓展。窗口函数也被称为联机分析处理（OLAP）函数，在 <code>Oracle</code> 中也称分析函数（Analytic Function）。</p> <p>窗口函数不同于我们熟悉的普通函数和聚合函数，它为每行数据进行一次计算：<mark>输入多行（一个窗口）、返回一个值</mark>。在报表等分析型查询中，窗口函数能优雅地表达某些需求，发挥不可替代的作用。</p> <p>大部分数据库，尤其是商业数据库都支持 SQL 标准中定义的部分窗口函数，但是 MySQL 一直没有支持这个特性。窗口函数在 MySQL 社区一直呼声很高，却一直没有被实现，直到 MairaDB 10.2 和 MySQL8.0 才响应了客户的需求，实现了部分窗口函数。　 <code>Oracle 11g</code> 、 <code>SQL Server 2008</code> 、 <code>DB2 9.7</code> 、 <code>PostgreSQL 8.4</code> 都支持窗口函数。</p> <p><code>MySQL8</code> 开始支持窗口函数，包括 <code>rank()</code>、<code>lag()</code> 和 <code>ntile()</code> 等非聚合窗口函数。以及部分聚合函数现在可以用作窗口函数，例如：<code>sum()</code>和 <code>avg()</code>。</p> <p>窗口函数(Window Function)，又被叫做分析函数(Analytics Function)，通常在需要对数据进行分组汇总计算时使用，因此与聚合函数有一定的相似性。但与聚合函数不同的是，聚合函数通过对数据进行分组，仅能够输出分组汇总结果，而原始数据则无法展现在结果中。而窗口函数则可以同时将原始数据和聚集分析结果同时显示出来。</p> <p>通常情况下，SQL 操作数据是基于同行 (row) 或者同列(column)的。无论是 <code>WHERE</code> 条件还是还是函数聚合，默认都是同一行的不同列，或者是同一列的不同行进行。而现实的数据分析需求很大一部分都是要基于"前因后果"的，因此在数据整合的操作过程中，就无法避免要面对"位移"的逻辑处理，所谓位移就是参考点和观察点的偏移量。比如，我们在做留存分析时，通常会非常关注日注册用户的留存率，例如 1-7 日留存率（如下表），也就是用户注册后过 1 天、2 天....到第 7 天里，每一天还剩多少比例的活跃（即有过登录或浏览）用户量。</p> <p>窗口函数出现在 SELECT 子句的表达式列表中，它最显著的特点就是 OVER 关键字。语法定义如下：</p> <div class=highlight><pre><span></span><code><span class=c1>--DDL</span>
<span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=o>`</span><span class=n>tbl_ware</span><span class=o>`</span><span class=w> </span><span class=p>(</span>
<span class=w>  </span><span class=o>`</span><span class=n>ware_id</span><span class=o>`</span><span class=w> </span><span class=nb>BIGINT</span><span class=p>(</span><span class=mi>20</span><span class=p>)</span><span class=w> </span><span class=n>UNSIGNED</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=w> </span><span class=n>AUTO_INCREMENT</span><span class=w> </span><span class=k>COMMENT</span><span class=w> </span><span class=s1>&#39;商品id&#39;</span><span class=p>,</span>
<span class=w>  </span><span class=o>`</span><span class=n>ware_name</span><span class=o>`</span><span class=w> </span><span class=nb>VARCHAR</span><span class=p>(</span><span class=mi>100</span><span class=p>)</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=w> </span><span class=k>COMMENT</span><span class=w> </span><span class=s1>&#39;商品名称&#39;</span><span class=p>,</span>
<span class=w>  </span><span class=o>`</span><span class=n>ware_category</span><span class=o>`</span><span class=w> </span><span class=nb>VARCHAR</span><span class=p>(</span><span class=mi>100</span><span class=p>)</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=w> </span><span class=k>COMMENT</span><span class=w> </span><span class=s1>&#39;商品类别&#39;</span><span class=p>,</span>
<span class=w>    </span><span class=o>`</span><span class=n>sale_unit_price</span><span class=o>`</span><span class=w> </span><span class=nb>INT</span><span class=w> </span><span class=k>COMMENT</span><span class=w> </span><span class=s1>&#39;销售单价&#39;</span><span class=p>,</span>
<span class=w>    </span><span class=o>`</span><span class=n>purchase_unit_price</span><span class=o>`</span><span class=w> </span><span class=nb>INT</span><span class=w> </span><span class=k>COMMENT</span><span class=w> </span><span class=s1>&#39;进货单价&#39;</span><span class=p>,</span>
<span class=w>    </span><span class=o>`</span><span class=n>registration_date</span><span class=o>`</span><span class=w> </span><span class=nb>DATE</span><span class=w> </span><span class=k>COMMENT</span><span class=w> </span><span class=s1>&#39;等级日期&#39;</span><span class=p>,</span>
<span class=w>  </span><span class=k>PRIMARY</span><span class=w> </span><span class=k>KEY</span><span class=w> </span><span class=p>(</span><span class=o>`</span><span class=n>ware_id</span><span class=o>`</span><span class=p>)</span><span class=w> </span><span class=k>USING</span><span class=w> </span><span class=n>BTREE</span>
<span class=p>)</span><span class=w> </span><span class=n>ENGINE</span><span class=o>=</span><span class=n>InnoDB</span><span class=w> </span><span class=k>COMMENT</span><span class=o>=</span><span class=s1>&#39;产品&#39;</span><span class=p>;</span>

<span class=c1>-- DML</span>
<span class=k>INSERT</span><span class=w> </span><span class=k>INTO</span><span class=w> </span><span class=n>tbl_ware</span><span class=w> </span><span class=k>VALUES</span>
<span class=p>(</span><span class=mi>1</span><span class=p>,</span><span class=s1>&#39;T恤衫&#39;</span><span class=p>,</span><span class=s1>&#39;衣服&#39;</span><span class=p>,</span><span class=mi>100</span><span class=p>,</span><span class=w> </span><span class=mi>50</span><span class=p>,</span><span class=s1>&#39;2023-12-15&#39;</span><span class=p>),</span>
<span class=p>(</span><span class=mi>2</span><span class=p>,</span><span class=s1>&#39;打孔器&#39;</span><span class=p>,</span><span class=s1>&#39;办公用品&#39;</span><span class=p>,</span><span class=mi>25</span><span class=p>,</span><span class=w> </span><span class=mi>10</span><span class=p>,</span><span class=s1>&#39;2023-12-15&#39;</span><span class=p>),</span>
<span class=p>(</span><span class=mi>3</span><span class=p>,</span><span class=s1>&#39;运动T恤&#39;</span><span class=p>,</span><span class=s1>&#39;衣服&#39;</span><span class=p>,</span><span class=mi>150</span><span class=p>,</span><span class=w> </span><span class=mi>50</span><span class=p>,</span><span class=s1>&#39;2023-12-15&#39;</span><span class=p>),</span>
<span class=p>(</span><span class=mi>4</span><span class=p>,</span><span class=s1>&#39;菜刀&#39;</span><span class=p>,</span><span class=s1>&#39;厨房用具&#39;</span><span class=p>,</span><span class=mi>75</span><span class=p>,</span><span class=w> </span><span class=mi>30</span><span class=p>,</span><span class=s1>&#39;2023-12-15&#39;</span><span class=p>),</span>
<span class=p>(</span><span class=mi>5</span><span class=p>,</span><span class=s1>&#39;高压锅&#39;</span><span class=p>,</span><span class=s1>&#39;厨房用具&#39;</span><span class=p>,</span><span class=mi>600</span><span class=p>,</span><span class=w> </span><span class=mi>200</span><span class=p>,</span><span class=s1>&#39;2023-12-15&#39;</span><span class=p>),</span>
<span class=p>(</span><span class=mi>6</span><span class=p>,</span><span class=s1>&#39;叉子&#39;</span><span class=p>,</span><span class=s1>&#39;厨房用具&#39;</span><span class=p>,</span><span class=mi>7</span><span class=p>,</span><span class=w> </span><span class=mi>3</span><span class=p>,</span><span class=s1>&#39;2023-12-15&#39;</span><span class=p>),</span>
<span class=p>(</span><span class=mi>7</span><span class=p>,</span><span class=s1>&#39;菜板&#39;</span><span class=p>,</span><span class=s1>&#39;厨房用具&#39;</span><span class=p>,</span><span class=mi>98</span><span class=p>,</span><span class=w> </span><span class=mi>30</span><span class=p>,</span><span class=s1>&#39;2023-12-15&#39;</span><span class=p>),</span>
<span class=p>(</span><span class=mi>8</span><span class=p>,</span><span class=s1>&#39;圆珠笔&#39;</span><span class=p>,</span><span class=s1>&#39;办公用品&#39;</span><span class=p>,</span><span class=mi>5</span><span class=p>,</span><span class=w> </span><span class=mi>2</span><span class=p>,</span><span class=s1>&#39;2023-12-15&#39;</span><span class=p>);</span>


<span class=c1>-- 按售价从高到低进行排名：普通排序</span>
<span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>tbl_ware</span><span class=w> </span><span class=k>ORDER</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>sale_unit_price</span><span class=w> </span><span class=k>DESC</span><span class=p>;</span>

<span class=c1>-- 按售价从高到低进行排名：窗口函数</span>
<span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=p>,</span><span class=w> </span><span class=n>RANK</span><span class=p>()</span><span class=w> </span><span class=n>OVER</span><span class=p>(</span><span class=k>ORDER</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>sale_unit_price</span><span class=w> </span><span class=k>DESC</span><span class=p>)</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=n>ranking</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>tbl_ware</span><span class=p>;</span>



<span class=c1>-- 对 tbl_ware 按类别进行分组，然后组内按售价从高到低进行排名</span>
<span class=c1>-- PARTITION BY 对表的横向进行分组，类似 GROUP BY ，但不具备聚合功能： 通过 PARTITION BY 分组后的记录集合称为「窗口」，代表范围。这也是「窗口函数」名称的由来</span>
<span class=c1>-- ORDER BY 则决定了分组后的组内排序：纵向排序的规则，与 SELECT 子句末尾的 ORDER BY 子句完全相同</span>
<span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=p>,</span><span class=w> </span><span class=n>RANK</span><span class=p>()</span><span class=w> </span><span class=n>OVER</span><span class=p>(</span><span class=n>PARTITION</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>ware_category</span><span class=w> </span><span class=k>ORDER</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>sale_unit_price</span><span class=w> </span><span class=k>DESC</span><span class=p>)</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=n>ranking</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>tbl_ware</span><span class=p>;</span>





<span class=n>window_function</span><span class=w> </span><span class=p>(</span><span class=n>expression</span><span class=p>)</span><span class=w> </span><span class=p>[</span><span class=n>null_treatment</span><span class=p>]</span><span class=w>  </span><span class=n>OVER</span><span class=w> </span><span class=p>(</span>
<span class=w>   </span><span class=p>[</span><span class=w> </span><span class=n>PARTITION</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>part_list</span><span class=w> </span><span class=p>]</span>
<span class=w>   </span><span class=p>[</span><span class=w> </span><span class=k>ORDER</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>order_list</span><span class=w> </span><span class=p>]</span>
<span class=w>   </span><span class=p>[</span><span class=w> </span><span class=err>{</span><span class=w> </span><span class=k>ROWS</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=n>RANGE</span><span class=w> </span><span class=err>}</span><span class=w> </span><span class=k>BETWEEN</span><span class=w> </span><span class=n>frame_start</span><span class=w> </span><span class=k>AND</span><span class=w> </span><span class=n>frame_end</span><span class=w> </span><span class=p>]</span><span class=w> </span><span class=p>)</span>

<span class=c1>-- window_function 是窗口函数的名称</span>
<span class=c1>-- expression 是窗口函数操作的对象，可以是字段或者表达式；</span>
<span class=c1>-- OVER 子句包含三个部分：分区（PARTITION BY）、排序（ORDER BY）以及窗口大小（frame_clause）</span>


<span class=k>SELECT</span><span class=w>  </span><span class=k>SUM</span><span class=p>(</span><span class=n>amount</span><span class=p>)</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=n>sum_amount</span>
<span class=k>FROM</span><span class=w> </span><span class=n>sales_data</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>saledate</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s1>&#39;2019-01-01&#39;</span><span class=p>;</span>

<span class=k>select</span><span class=w> </span><span class=n>saledate</span><span class=p>,</span><span class=w> </span><span class=n>product</span><span class=p>,</span><span class=w> </span><span class=k>sum</span><span class=p>(</span><span class=n>amount</span><span class=p>)</span><span class=w> </span><span class=n>over</span><span class=p>()</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=n>sum_amount</span>
<span class=k>from</span><span class=w> </span><span class=n>sales_data</span>
<span class=k>where</span><span class=w> </span><span class=n>saledate</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s1>&#39;2019-01-01&#39;</span>
</code></pre></div> <p>窗口函数 window_function 可以分为以下 3 类：</p> <ul> <li> <p>聚合（Aggregate）：AVG(), COUNT(), MIN(), MAX(), SUM()...</p> </li> <li> <p>取值（Value）：FIRST_VALUE(), LAST_VALUE(), LEAD(), LAG()...</p> </li> <li> <p>排序（Ranking）：RANK(), DENSE_RANK(), ROW_NUMBER(), NTILE()...</p> </li> </ul> <p>其中包括以下可选项：</p> <ul> <li> <p>PARTITION BY 表示将数据先按 part_list 进行分区，作用类似于 GROUP BY 分组；如果指定了分区选项，窗口函数将会分别针对每个分区单独进行分析（相同的分为一个区，然后对每个分区里面的值是使用 window_function 进行计算）。</p> </li> <li> <p>ORDER BY 表示将各个分区内的数据按 order_list 进行排序</p> </li> <li> <p>FRAME ，表示当前窗口包含哪些数据。滑动窗口有两种指定范围的方式，一种是基于行，一种是基于范围。</p> </li> <li> <p>ROWS 选择前后几行，例如 ROWS BETWEEN 3 PRECEDING AND 3 FOLLOWING 表示往前 3 行到往后 3 行，一共 7 行数据（或小于 7 行，如果碰到了边界）</p> </li> <li> <p>RANGE 选择数据范围，例如 RANGE BETWEEN 3 PRECEDING AND 3 FOLLOWING 表示所有值在 [c-3,c+3] 这个范围内的行，c 为当前行的值</p> </li> <li> <p>ROWS 和 RANGE 的范围边界也可以用 CURRENT ROW</p> </li> </ul> <blockquote> <p>Frame 定义并非所有窗口函数都适用，比如 ROW_NUMBER()、RANK()、LEAD() 等。这些函数总是应用于整个分区，而非当前 Frame。</p> </blockquote> <div class=highlight><pre><span></span><code><span class=k>SELECT</span><span class=w> </span><span class=n>dealer_id</span><span class=p>,</span><span class=w> </span><span class=n>emp_name</span><span class=p>,</span><span class=w> </span><span class=n>sales</span><span class=p>,</span>
<span class=w>       </span><span class=n>ROW_NUMBER</span><span class=p>()</span><span class=w> </span><span class=n>OVER</span><span class=w> </span><span class=p>(</span><span class=n>PARTITION</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>dealer_id</span><span class=w> </span><span class=k>ORDER</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>sales</span><span class=p>)</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=n>rank</span><span class=p>,</span>
<span class=w>       </span><span class=k>AVG</span><span class=p>(</span><span class=n>sales</span><span class=p>)</span><span class=w> </span><span class=n>OVER</span><span class=w> </span><span class=p>(</span><span class=n>PARTITION</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>dealer_id</span><span class=p>)</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=n>avgsales</span>
<span class=k>FROM</span><span class=w> </span><span class=n>sales</span>
</code></pre></div> <p>窗口</p> <p>row_number() 则在排序相同时不重复，会根据顺序排序。</p> <p>rank()排序相同时会重复，总数不会变 ，意思是会出现 1、1、3 这样的排序结果；</p> <p>dense_rank() 排序相同时会重复，总数会减少，意思是会出现 1、1、2 这样的排序结果。</p> <p>想看各个 department 内部收入最多的人，这时候不能全表 order by 了</p> <p>SQL 标准支持 4 种用于排名计算的窗口函数。它们是：ROW_NUMBER、NTILE、RANK 和 DENSE_RANK。在标准中，前两者是一类，后两者是另一类。</p> <p>ROW_NUMBER 函数根据指定的顺序，从 1 开始计算连续的行号。NTILE 函数把窗口分区里的数据行分成数量大致相等的块（根据输入的块数和指定的窗口排序）。</p> <p>ROW_NUMBER</p> <ul> <li> <p>功能：用于实现分区内记录编号</p> </li> <li> <p>语法：row_number() over (partition by col1 order by col2)</p> </li> <li> <p>示例：统计每个部门薪资最高的前两名</p> </li> </ul> <div class=highlight><pre><span></span><code><span class=k>select</span>
<span class=w>  </span><span class=n>empno</span><span class=p>,</span>
<span class=w>  </span><span class=n>ename</span><span class=p>,</span>
<span class=w>  </span><span class=n>salary</span><span class=p>,</span>
<span class=w>  </span><span class=n>deptno</span><span class=p>,</span>
<span class=w>  </span><span class=n>row_number</span><span class=p>()</span><span class=w> </span><span class=n>over</span><span class=w> </span><span class=p>(</span><span class=n>partition</span><span class=w> </span><span class=k>by</span><span class=w> </span><span class=n>deptno</span><span class=w> </span><span class=k>order</span><span class=w> </span><span class=k>by</span><span class=w> </span><span class=n>salary</span><span class=w> </span><span class=k>desc</span><span class=p>)</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=n>numb</span>
<span class=k>from</span>
<span class=w>  </span><span class=n>db_emp</span><span class=p>.</span><span class=n>tb_emp</span><span class=p>;</span>

<span class=c1>--此时为排名,要求取前两名,作为临时表t再套一层查询即可</span>

<span class=k>select</span>
<span class=o>*</span>
<span class=k>from</span>
<span class=w>    </span><span class=p>(</span><span class=k>select</span>
<span class=w>          </span><span class=n>empno</span><span class=p>,</span>
<span class=w>          </span><span class=n>ename</span><span class=p>,</span>
<span class=w>          </span><span class=n>salary</span><span class=p>,</span>
<span class=w>          </span><span class=n>deptno</span><span class=p>,</span>
<span class=w>          </span><span class=n>row_number</span><span class=p>()</span><span class=w> </span><span class=n>over</span><span class=w> </span><span class=p>(</span><span class=n>partition</span><span class=w> </span><span class=k>by</span><span class=w> </span><span class=n>deptno</span><span class=w> </span><span class=k>order</span><span class=w> </span><span class=k>by</span><span class=w> </span><span class=n>salary</span><span class=w> </span><span class=k>desc</span><span class=p>)</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=n>numb</span>
<span class=w>    </span><span class=k>from</span>
<span class=w>      </span><span class=n>db_emp</span><span class=p>.</span><span class=n>tb_emp</span><span class=p>)</span><span class=w> </span><span class=n>t</span>
<span class=k>where</span><span class=w> </span><span class=n>t</span><span class=p>.</span><span class=n>numb</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=mi>3</span><span class=p>;</span>
</code></pre></div> <p>RANK</p> <ul> <li> <p>功能：用于实现分区内排名编号[会留空位]</p> </li> <li> <p>与 row_number 的区别：</p> </li> <li> <p>row_number：如果排序时数值相同，继续编号</p> </li> <li> <p>rank：如果排序时数值相同，编号相同，但留下空位</p> </li> <li> <p>语法：rank() over (partition by col1 order by col2)</p> </li> <li> <p>示例：统计每个部门薪资排名</p> </li> </ul> <div class=highlight><pre><span></span><code><span class=k>select</span>
<span class=w>  </span><span class=n>empno</span><span class=p>,</span>
<span class=w>  </span><span class=n>ename</span><span class=p>,</span>
<span class=w>  </span><span class=n>salary</span><span class=p>,</span>
<span class=w>  </span><span class=n>deptno</span><span class=p>,</span>
<span class=w>  </span><span class=n>rank</span><span class=p>()</span><span class=w> </span><span class=n>over</span><span class=w> </span><span class=p>(</span><span class=n>partition</span><span class=w> </span><span class=k>by</span><span class=w> </span><span class=n>deptno</span><span class=w> </span><span class=k>order</span><span class=w> </span><span class=k>by</span><span class=w> </span><span class=n>salary</span><span class=w> </span><span class=k>desc</span><span class=p>)</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=n>numb</span>
<span class=k>from</span>
<span class=w>  </span><span class=n>db_emp</span><span class=p>.</span><span class=n>tb_emp</span><span class=p>;</span>
</code></pre></div> <div class=highlight><pre><span></span><code><span class=n>USE</span><span class=w> </span><span class=n>db_test</span><span class=p>;</span>
<span class=k>DROP</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=k>IF</span><span class=w> </span><span class=k>EXISTS</span><span class=w>  </span><span class=n>student</span><span class=w> </span><span class=p>;</span>

<span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w>  </span><span class=n>student</span><span class=w> </span><span class=p>(</span>
<span class=w>    </span><span class=n>name</span><span class=w> </span><span class=nb>VARCHAR</span><span class=p>(</span><span class=mi>20</span><span class=p>)</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=p>,</span>
<span class=w>    </span><span class=n>subject</span><span class=w> </span><span class=nb>VARCHAR</span><span class=p>(</span><span class=mi>20</span><span class=p>)</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=p>,</span>
<span class=w>    </span><span class=n>score</span><span class=w> </span><span class=nb>INT</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span>
<span class=p>)</span><span class=w> </span><span class=n>ENGINE</span><span class=o>=</span><span class=n>InnoDB</span><span class=w> </span><span class=k>DEFAULT</span><span class=w> </span><span class=n>CHARSET</span><span class=o>=</span><span class=n>utf8mb4</span><span class=p>;</span>

<span class=k>insert</span><span class=w> </span><span class=k>into</span><span class=w> </span><span class=n>student</span><span class=p>(</span><span class=n>name</span><span class=p>,</span><span class=n>subject</span><span class=p>,</span><span class=n>score</span><span class=p>)</span>
<span class=w>    </span><span class=k>values</span>
<span class=p>(</span><span class=ss>&quot;小明&quot;</span><span class=p>,</span><span class=ss>&quot;语文&quot;</span><span class=p>,</span><span class=mi>66</span><span class=p>),</span>
<span class=p>(</span><span class=ss>&quot;小明&quot;</span><span class=p>,</span><span class=ss>&quot;数学&quot;</span><span class=p>,</span><span class=mi>67</span><span class=p>),</span>
<span class=p>(</span><span class=ss>&quot;小明&quot;</span><span class=p>,</span><span class=ss>&quot;英语&quot;</span><span class=p>,</span><span class=mi>69</span><span class=p>),</span>
<span class=p>(</span><span class=ss>&quot;小红&quot;</span><span class=p>,</span><span class=ss>&quot;语文&quot;</span><span class=p>,</span><span class=mi>65</span><span class=p>),</span>
<span class=p>(</span><span class=ss>&quot;小红&quot;</span><span class=p>,</span><span class=ss>&quot;数学&quot;</span><span class=p>,</span><span class=mi>99</span><span class=p>),</span>
<span class=p>(</span><span class=ss>&quot;小红&quot;</span><span class=p>,</span><span class=ss>&quot;英语&quot;</span><span class=p>,</span><span class=mi>88</span><span class=p>),</span>
<span class=p>(</span><span class=ss>&quot;小强&quot;</span><span class=p>,</span><span class=ss>&quot;语文&quot;</span><span class=p>,</span><span class=mi>60</span><span class=p>),</span>
<span class=p>(</span><span class=ss>&quot;小强&quot;</span><span class=p>,</span><span class=ss>&quot;数学&quot;</span><span class=p>,</span><span class=mi>72</span><span class=p>),</span>
<span class=p>(</span><span class=ss>&quot;小强&quot;</span><span class=p>,</span><span class=ss>&quot;英语&quot;</span><span class=p>,</span><span class=mi>92</span><span class=p>);</span>


<span class=c1>-- 计算每个学生自己的各科排名（组内排序）</span>
<span class=k>SELECT</span><span class=w> </span><span class=n>name</span><span class=p>,</span><span class=w> </span><span class=n>subject</span><span class=p>,</span><span class=w> </span><span class=n>score</span><span class=p>,</span>
<span class=w>      </span><span class=n>row_number</span><span class=p>()</span><span class=w> </span><span class=n>OVER</span><span class=w> </span><span class=p>(</span><span class=n>partition</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>name</span><span class=w> </span><span class=k>ORDER</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>score</span><span class=w> </span><span class=k>DESC</span><span class=p>)</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=n>n</span>
<span class=k>FROM</span><span class=w> </span><span class=n>student</span><span class=w> </span><span class=p>;</span>




<span class=c1>--每个科目最高的成绩以及对应的同学和科目</span>

<span class=k>SELECT</span><span class=w> </span><span class=n>name</span><span class=p>,</span><span class=w> </span><span class=n>subject</span><span class=p>,</span><span class=w> </span><span class=n>score</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=p>(</span>
<span class=w>    </span><span class=k>SELECT</span><span class=w> </span><span class=n>name</span><span class=p>,</span><span class=w> </span><span class=n>subject</span><span class=p>,</span><span class=w> </span><span class=n>score</span><span class=p>,</span>
<span class=w>      </span><span class=n>ROW_NUMBER</span><span class=p>()</span><span class=w> </span><span class=n>OVER</span><span class=w> </span><span class=p>(</span><span class=n>PARTITION</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>subject</span><span class=w> </span><span class=k>ORDER</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>score</span><span class=w>  </span><span class=p>)</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=n>n</span>
<span class=k>FROM</span><span class=w> </span><span class=n>student</span><span class=w> </span><span class=p>)</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=n>top</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>top</span><span class=p>.</span><span class=n>n</span><span class=w> </span><span class=o>&lt;</span><span class=mi>2</span>



<span class=c1>--思路分析，首先按照科目分组并聚合求最大值。将其结果集与原表关联，查出同学名称即可。</span>

<span class=w>    </span><span class=k>SELECT</span>
<span class=w>        </span><span class=n>b</span><span class=p>.</span><span class=n>name</span><span class=p>,</span>
<span class=w>        </span><span class=n>b</span><span class=p>.</span><span class=n>subject</span><span class=p>,</span>
<span class=w>        </span><span class=n>b</span><span class=p>.</span><span class=n>score</span>
<span class=w>    </span><span class=k>FROM</span>
<span class=w>        </span><span class=p>(</span>
<span class=w>            </span><span class=k>SELECT</span>
<span class=w>                </span><span class=n>subject</span><span class=p>,</span>
<span class=w>                </span><span class=k>MAX</span><span class=p>(</span><span class=n>score</span><span class=p>)</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=n>score</span>
<span class=w>                </span><span class=k>FROM</span>
<span class=w>                    </span><span class=n>student</span>
<span class=w>                </span><span class=k>GROUP</span><span class=w> </span><span class=k>BY</span>
<span class=w>                    </span><span class=n>subject</span>
<span class=w>        </span><span class=p>)</span><span class=w> </span><span class=n>a</span>
<span class=w>    </span><span class=k>JOIN</span><span class=w> </span><span class=n>student</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=k>ON</span><span class=w> </span><span class=n>a</span><span class=p>.</span><span class=n>subject</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>b</span><span class=p>.</span><span class=n>subject</span>
<span class=w>    </span><span class=k>AND</span><span class=w> </span><span class=n>a</span><span class=p>.</span><span class=n>score</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>b</span><span class=p>.</span><span class=n>score</span>
</code></pre></div> <h3 id=_50>窗口函数和聚合函数的区别<a class=headerlink href=#_50 title="Permanent link">&para;</a></h3> <p>窗口函数仅仅只会将结果附加到当前的结果上，它不会对已有的行或列做任何修改。</p> <p>而 Group By 的做法完全不同：对于各个 Group 它仅仅会保留一行聚合结果。</p> <p>因为 SQL 及关系代数都是以 multi-set 为基础定义的，结果集本身并没有顺序可言，ORDER BY 仅仅是最终呈现结果的顺序。</p> <p><a href=https://dev.mysql.com/doc/refman/8.0/en/window-function-descriptions.html>MySQL 官网</a></p> <p><a href=https://www.cnblogs.com/cjsblog/p/16743807.html>参考</a></p> <p><a href=https://ericfu.me/sql-window-function/ >参考</a></p> <p><a href=https://www.begtut.com/mysql/mysql-window-functions.html>参考</a></p> <p><a href=https://zhuanlan.zhihu.com/p/195729715>参考</a></p> <h1 id=sql_6>SQL 的思维方式<a class=headerlink href=#sql_6 title="Permanent link">&para;</a></h1> <p>SQL 本身是一种 DSL（领域描述语言），它由数学家（早期计算机技术大都是由领域应用中的数学专家主导的）发明用来表达数据查询的描述性语言。一般地，大学计算机课程中，都设有数据库基础、数据库原理这类课程，其中会有非常长的篇幅介绍 SQL 语言，介绍 select、update、insert、delete，都是非常标准的通用语法，只是大学老师通常不会跟你说，实际工程中使用到的 SQL 要比教程中的复杂得多。</p> <p>为什么只是 select、update、insert、delete，因为我们在使用数据时，从数据表中查询数据、修改删除表中数据、往表中添加数据等操作。</p> <p>数学家很早以前就把帮我们把数据使用的操作需求归纳好了。</p> <p>DML Data Manipulate language，数据操作语言。上面提到的都是，比较标准化。市面上的多个不同的数据库产品上运行 DML，语法都比较接近，有时还通用（mssql 的语法特殊符号比较多）。</p> <p>DDL Data Define language，数据定义语言。上面提到了数据操作语言，其中 数据 是被操作的对象。这些对象的属性（表结构、字段的数据类型、物理特性等）使用 DDL 来定义。所以，使用数据前，需要在数据库中使用 DDL ，创建相关的环境（表），然后才可能使用 DML（DML 所操作的表、视图和字段都需要实际上已经存在的）。不同的数据库还提供了不同的环境 DDL，如表空间维护等，视具体特定的数据库而定。</p> <blockquote> <p>某种定义上，SQL 与 javascript、python 等脚本语言的性质是一致的，需要运行环境把它解释并编译成更低层次的代码来执行逻辑。运行 SQL 的环境（数据库）本身就可以看成是一个带有大量数据环境变量的超级 runtime，这些数据环境变量（表）的值（表中的数据）是事先预置（从其它地方迁移过来或者不断积累更新（CRUD）所形成的状态）。</p> </blockquote> <p>关系型数据库，有一种叫<code>execute plan</code>（执行计划）的东西，有些数据库还提供了<code>select * from ... for explain</code>的语法，来直接得到它。</p> <p>它可以把一个完整的 SQL 分解多个级联嵌套的步骤，使用一个多于 2 个表或者视图关联的查询，就可以非常较明显的看到执行计划中的顺序。</p> <p>执行计划并不只是数据操作过程的可视化，它还是数据库将 SQL 编译成低层次数据访问代码的高级可视化视图。故而，这个执行计划是数据库专用的（不同的数据库，所生成的执行计划不同，即使同一个 SQL，在表数据大小不同时所产生的执行计划都可能不一样。这与数据库内部引擎的实现有关）。也因此，执行计划在 SQL 调优时非常有用，相当于一个逻辑过程的步骤化分解。通过改变这个执行计划，或者拆解 SQL 来得到其他想要的执行计划（需要非常丰富的经验积累）。如果有前端基础的同学，浏览器有 DOM inspector，执行计划就类似于 SQL 的 inspector，用来观察 SQL 最终执行的过程。</p> <p>在大数据产品，上面所说的执行计划同样存在，SQL 被直白的编译成 java 程序。可能因为 oracle 的高市占率原因，hivesql 与 oracle 的 SQL 实现兼容性非常高，如果有基于 oracle 实现的 OLAP 型分析应用，存储过程迁移成本会低很多。</p> <p><code>select ... from ... [where ...]</code> 从某数据源（这里指具体的数据集）获取目标信息（具体的属性），当然也可以添加过滤条件</p> <p><code>update ... set ... [where] ...]</code> 对目标数据进行修改。这里隐藏了一个概念，目标数据集。 经验初浅的，关注 <code>set …</code>（要如何修改） 经验丰富，一般更习惯于先关注 <code>update … [where …]</code> (要修改什么，为什么修改) 更高级别的问题。</p> <p><code>delete from ... [where ...]</code> 与 update 的逻辑类似。</p> <p><code>insert into ... (values(...) | select ... from [where ...])</code> insert into 有两个重要的但非常不同的场景。</p> <ul> <li>在功能应用系统中，最常见的是 insert into ... values(...)，实现向系统里添加业务数据（非常重要的数据生产方式）；</li> <li>在数据开发领域，通常所需要的数据已经存在系统中的某个位置，这时往往使用的是 <code>insert into ... select ... from ...[where ...]</code>。</li> </ul> <p><code>merge into</code> insert into 与 update 的结合体。除 merge 外，还有诸如 update set [where …] [delete …] 这种变种。</p> <blockquote> <p>先抛开容易搞混乱的变种，它对简化问题理解没有帮助。我们的目的是从上面的语法来提炼帮助理解、从而形成容易理解、记忆、使用的模式，这才是主要矛盾。</p> </blockquote> <p>select、update、delete、insert，可以分为 <strong>数据状态发生变化（修改、删除、插入）</strong>、**数据状态不会发生变化（查询）**两大类。</p> <p>可以进一步的抽象成下图的形式。</p> <p>查询是确定数据源、目标集的过程，增删改为对目标集的二次加工。有时可能会觉得二次加工时非常花费精力，其实查询才是重点，在这个确定数据源与目标集的过程中，往往涉及业务问题的理解、分析，加工只是附带的操作需求。本节所说的思维方式，以及后文所要谈的内容，都是围绕这个部分。</p> <p>熟悉数据开发的人，可能都会有这种经历，SQL 不管再怎么长，它的代码量其实非常少的。若业务问题的理解不准确，编写的查询缺漏条件，那么查错并编写出正确的 SQL 所花费的时间，往往比编写出原来那个为了任务而凑数的 SQL 所花时间要多很多。一些死要面子的人始终不肯承认这一点。</p> <aside class=md-source-file> <span class=md-source-file__fact> <span class=md-icon title=最后更新> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M21 13.1c-.1 0-.3.1-.4.2l-1 1 2.1 2.1 1-1c.2-.2.2-.6 0-.8l-1.3-1.3c-.1-.1-.2-.2-.4-.2m-1.9 1.8-6.1 6V23h2.1l6.1-6.1-2.1-2M12.5 7v5.2l4 2.4-1 1L11 13V7h1.5M11 21.9c-5.1-.5-9-4.8-9-9.9C2 6.5 6.5 2 12 2c5.3 0 9.6 4.1 10 9.3-.3-.1-.6-.2-1-.2s-.7.1-1 .2C19.6 7.2 16.2 4 12 4c-4.4 0-8 3.6-8 8 0 4.1 3.1 7.5 7.1 7.9l-.1.2v1.8Z"/></svg> </span> <span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-iso_datetime" title="2025年12月24日 05:56:46 UTC">2025-12-24 05:56:46</span> </span> </aside> </article> </div> <script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script> </div> <button type=button class="md-top md-icon" data-md-component=top hidden> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12Z"/></svg> 回到页面顶部 </button> </main> <footer class=md-footer> <div class="md-footer-meta md-typeset"> <div class="md-footer-meta__inner md-grid"> <div class=md-copyright> <div class=md-copyright__highlight> Copyleft &copy; 2020 - 2023 fengzhao </div> Made with <a href=https://squidfunk.github.io/mkdocs-material/ target=_blank rel=noopener> Material for MkDocs </a> </div> </div> </div> </footer> </div> <div class=md-dialog data-md-component=dialog> <div class="md-dialog__inner md-typeset"></div> </div> <script id=__config type=application/json>{"base": "../..", "features": ["navigation.tabs", "navigation.tabs.sticky", "navigation.sections", "navigation.top"], "search": "../../assets/javascripts/workers/search.b8dbb3d2.min.js", "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}}</script> <script src=../../assets/javascripts/bundle.1e8ae164.min.js></script> </body> </html>