<!doctype html><html lang=zh class=no-js> <head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="MySQL WIKI"><meta name=author content=fengzhao><link href=https://mysql.fengzhao.me/basic/11.sql-Transaction/ rel=canonical><link href=../10.MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/ rel=prev><link href=../12.MySQL%E5%86%85%E5%AD%98%E6%A6%82%E8%BF%B0/ rel=next><link rel=icon href=../../assets/images/favicon.png><meta name=generator content="mkdocs-1.5.3, mkdocs-material-9.5.17"><title>11. MySQL事务和锁 - MySQL WIKI</title><link rel=stylesheet href=../../assets/stylesheets/main.bcfcd587.min.css><link rel=stylesheet href=../../assets/stylesheets/palette.06af60db.min.css><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback"><style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style><link rel=stylesheet href=../../stylesheets/extra.css><script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script></head> <body dir=ltr data-md-color-scheme=default data-md-color-primary=indigo data-md-color-accent=indigo> <input class=md-toggle data-md-toggle=drawer type=checkbox id=__drawer autocomplete=off> <input class=md-toggle data-md-toggle=search type=checkbox id=__search autocomplete=off> <label class=md-overlay for=__drawer></label> <div data-md-component=skip> <a href=#_1 class=md-skip> 跳转至 </a> </div> <div data-md-component=announce> </div> <header class="md-header md-header--shadow md-header--lifted" data-md-component=header> <nav class="md-header__inner md-grid" aria-label=页眉> <a href=../.. title="MySQL WIKI" class="md-header__button md-logo" aria-label="MySQL WIKI" data-md-component=logo> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg> </a> <label class="md-header__button md-icon" for=__drawer> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg> </label> <div class=md-header__title data-md-component=header-title> <div class=md-header__ellipsis> <div class=md-header__topic> <span class=md-ellipsis> MySQL WIKI </span> </div> <div class=md-header__topic data-md-component=header-topic> <span class=md-ellipsis> 11. MySQL事务和锁 </span> </div> </div> </div> <form class=md-header__option data-md-component=palette> <input class=md-option data-md-color-media data-md-color-scheme=default data-md-color-primary=indigo data-md-color-accent=indigo aria-label="Switch to dark mode" type=radio name=__palette id=__palette_0> <label class="md-header__button md-icon" title="Switch to dark mode" for=__palette_1 hidden> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M17 6H7c-3.31 0-6 2.69-6 6s2.69 6 6 6h10c3.31 0 6-2.69 6-6s-2.69-6-6-6zm0 10H7c-2.21 0-4-1.79-4-4s1.79-4 4-4h10c2.21 0 4 1.79 4 4s-1.79 4-4 4zM7 9c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/></svg> </label> <input class=md-option data-md-color-media data-md-color-scheme=slate data-md-color-primary=indigo data-md-color-accent=indigo aria-label="Switch to light mode" type=radio name=__palette id=__palette_1> <label class="md-header__button md-icon" title="Switch to light mode" for=__palette_0 hidden> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M17 7H7a5 5 0 0 0-5 5 5 5 0 0 0 5 5h10a5 5 0 0 0 5-5 5 5 0 0 0-5-5m0 8a3 3 0 0 1-3-3 3 3 0 0 1 3-3 3 3 0 0 1 3 3 3 3 0 0 1-3 3Z"/></svg> </label> </form> <script>var media,input,key,value,palette=__md_get("__palette");if(palette&&palette.color){"(prefers-color-scheme)"===palette.color.media&&(media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']"),palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent"));for([key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script> <label class="md-header__button md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg> </label> <div class=md-search data-md-component=search role=dialog> <label class=md-search__overlay for=__search></label> <div class=md-search__inner role=search> <form class=md-search__form name=search> <input type=text class=md-search__input name=query aria-label=搜索 placeholder=搜索 autocapitalize=off autocorrect=off autocomplete=off spellcheck=false data-md-component=search-query required> <label class="md-search__icon md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg> </label> <nav class=md-search__options aria-label=查找> <button type=reset class="md-search__icon md-icon" title=清空当前内容 aria-label=清空当前内容 tabindex=-1> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg> </button> </nav> </form> <div class=md-search__output> <div class=md-search__scrollwrap data-md-scrollfix> <div class=md-search-result data-md-component=search-result> <div class=md-search-result__meta> 正在初始化搜索引擎 </div> <ol class=md-search-result__list role=presentation></ol> </div> </div> </div> </div> </div> <div class=md-header__source> <a href=https://github.com/fengzhao/mysql-wiki title=前往仓库 class=md-source data-md-component=source> <div class="md-source__icon md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 448 512"><!-- Font Awesome Free 6.5.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg> </div> <div class=md-source__repository> fengzhao/mysql-wiki </div> </a> </div> </nav> <nav class=md-tabs aria-label=标签 data-md-component=tabs> <div class=md-grid> <ul class=md-tabs__list> <li class=md-tabs__item> <a href=../.. class=md-tabs__link> Home </a> </li> <li class=md-tabs__item> <a href=../../resources/ class=md-tabs__link> 学习资源 </a> </li> <li class="md-tabs__item md-tabs__item--active"> <a href=../0.mysql_source/ class=md-tabs__link> MySQL入门 </a> </li> <li class=md-tabs__item> <a href=../../sql/sql2023/ class=md-tabs__link> SQL特性 </a> </li> <li class=md-tabs__item> <a href=../../foundmental/2.MySQL%E7%B4%A2%E5%BC%95/ class=md-tabs__link> MySQL基础 </a> </li> <li class=md-tabs__item> <a href=../../advanced/1.MySQL%E6%9E%B6%E6%9E%84%E5%88%B0InnoDB%E6%9E%B6%E6%9E%84/ class=md-tabs__link> MySQL高级 </a> </li> <li class=md-tabs__item> <a href=../../optimize/1.overview/ class=md-tabs__link> MySQL调优 </a> </li> <li class=md-tabs__item> <a href=../../postgresql/01.postgresql%E7%AE%80%E4%BB%8B/ class=md-tabs__link> PostgreSQL </a> </li> <li class=md-tabs__item> <a href=../../mongodb/01.%E7%AE%80%E4%BB%8B/ class=md-tabs__link> MongoDB </a> </li> <li class=md-tabs__item> <a href=../../redis/01.redis%E7%AE%80%E4%BB%8B/ class=md-tabs__link> Redis </a> </li> <li class=md-tabs__item> <a href=../../%E7%AE%97%E6%B3%95/01.%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/ class=md-tabs__link> 算法 </a> </li> <li class=md-tabs__item> <a href=../../oracle/01.Oracle%E6%A6%82%E8%BF%B0/ class=md-tabs__link> Oracle </a> </li> <li class=md-tabs__item> <a href=../../network/1.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/ class=md-tabs__link> network </a> </li> </ul> </div> </nav> </header> <div class=md-container data-md-component=container> <main class=md-main data-md-component=main> <div class="md-main__inner md-grid"> <div class="md-sidebar md-sidebar--primary" data-md-component=sidebar data-md-type=navigation> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--primary md-nav--lifted" aria-label=导航栏 data-md-level=0> <label class=md-nav__title for=__drawer> <a href=../.. title="MySQL WIKI" class="md-nav__button md-logo" aria-label="MySQL WIKI" data-md-component=logo> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg> </a> MySQL WIKI </label> <div class=md-nav__source> <a href=https://github.com/fengzhao/mysql-wiki title=前往仓库 class=md-source data-md-component=source> <div class="md-source__icon md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 448 512"><!-- Font Awesome Free 6.5.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg> </div> <div class=md-source__repository> fengzhao/mysql-wiki </div> </a> </div> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../.. class=md-nav__link> <span class=md-ellipsis> Home </span> </a> </li> <li class=md-nav__item> <a href=../../resources/ class=md-nav__link> <span class=md-ellipsis> 学习资源 </span> </a> </li> <li class="md-nav__item md-nav__item--active md-nav__item--section md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_3 checked> <label class=md-nav__link for=__nav_3 id=__nav_3_label tabindex> <span class=md-ellipsis> MySQL入门 </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=1 aria-labelledby=__nav_3_label aria-expanded=true> <label class=md-nav__title for=__nav_3> <span class="md-nav__icon md-icon"></span> MySQL入门 </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../0.mysql_source/ class=md-nav__link> <span class=md-ellipsis> 0. MySQL的起源和分支 </span> </a> </li> <li class=md-nav__item> <a href=../1.introduce_database/ class=md-nav__link> <span class=md-ellipsis> 1. 数据库概述 </span> </a> </li> <li class=md-nav__item> <a href=../2.install_mysql/ class=md-nav__link> <span class=md-ellipsis> 2. 安装 MySQL </span> </a> </li> <li class=md-nav__item> <a href=../3.mysql_execute_command/ class=md-nav__link> <span class=md-ellipsis> 3. MySQL可执行程序 </span> </a> </li> <li class=md-nav__item> <a href=../4.sql/ class=md-nav__link> <span class=md-ellipsis> 4. SQL语句和语法 </span> </a> </li> <li class=md-nav__item> <a href=../5.relation/ class=md-nav__link> <span class=md-ellipsis> 5. 关系模型和关系代数 </span> </a> </li> <li class=md-nav__item> <a href=../6.sql_practice/ class=md-nav__link> <span class=md-ellipsis> 6. SQL题目练习 </span> </a> </li> <li class=md-nav__item> <a href=../7.MySQL%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/ class=md-nav__link> <span class=md-ellipsis> 7. MySQL数据类型 </span> </a> </li> <li class=md-nav__item> <a href=../8.MySQL%E5%AD%97%E7%AC%A6%E9%9B%86%E5%92%8C%E6%8E%92%E5%BA%8F%E8%A7%84%E5%88%99/ class=md-nav__link> <span class=md-ellipsis> 8. MySQL字符集和排序规则 </span> </a> </li> <li class=md-nav__item> <a href=../9.mysql_architecture/ class=md-nav__link> <span class=md-ellipsis> 9. MySQL逻辑架构 </span> </a> </li> <li class=md-nav__item> <a href=../10.MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/ class=md-nav__link> <span class=md-ellipsis> 10. MySQL存储引擎 </span> </a> </li> <li class="md-nav__item md-nav__item--active"> <input class="md-nav__toggle md-toggle" type=checkbox id=__toc> <label class="md-nav__link md-nav__link--active" for=__toc> <span class=md-ellipsis> 11. MySQL事务和锁 </span> <span class="md-nav__icon md-icon"></span> </label> <a href=./ class="md-nav__link md-nav__link--active"> <span class=md-ellipsis> 11. MySQL事务和锁 </span> </a> <nav class="md-nav md-nav--secondary" aria-label=目录> <label class=md-nav__title for=__toc> <span class="md-nav__icon md-icon"></span> 目录 </label> <ul class=md-nav__list data-md-component=toc data-md-scrollfix> <li class=md-nav__item> <a href=#_1 class=md-nav__link> <span class=md-ellipsis> 数据库事务 </span> </a> <nav class=md-nav aria-label=数据库事务> <ul class=md-nav__list> <li class=md-nav__item> <a href=#_2 class=md-nav__link> <span class=md-ellipsis> 本地事务 </span> </a> </li> <li class=md-nav__item> <a href=#_3 class=md-nav__link> <span class=md-ellipsis> 分布式事务 </span> </a> </li> <li class=md-nav__item> <a href=#_4 class=md-nav__link> <span class=md-ellipsis> 查询会不会开事务？ </span> </a> </li> <li class=md-nav__item> <a href=#_5 class=md-nav__link> <span class=md-ellipsis> 事务开启时间 </span> </a> </li> <li class=md-nav__item> <a href=#_6 class=md-nav__link> <span class=md-ellipsis> 事务保存点 </span> </a> </li> <li class=md-nav__item> <a href=#mysql class=md-nav__link> <span class=md-ellipsis> MySQL中的事务 </span> </a> <nav class=md-nav aria-label=MySQL中的事务> <ul class=md-nav__list> <li class=md-nav__item> <a href=#_7 class=md-nav__link> <span class=md-ellipsis> 事务对象和事务池 </span> </a> </li> <li class=md-nav__item> <a href=#_8 class=md-nav__link> <span class=md-ellipsis> 用户事务和内部事务 </span> </a> </li> </ul> </nav> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#_9 class=md-nav__link> <span class=md-ellipsis> 并发控制 </span> </a> <nav class=md-nav aria-label=并发控制> <ul class=md-nav__list> <li class=md-nav__item> <a href=#_10 class=md-nav__link> <span class=md-ellipsis> 脏读现象 </span> </a> </li> <li class=md-nav__item> <a href=#_11 class=md-nav__link> <span class=md-ellipsis> 不可重复读 </span> </a> </li> <li class=md-nav__item> <a href=#_12 class=md-nav__link> <span class=md-ellipsis> 幻读 </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#_13 class=md-nav__link> <span class=md-ellipsis> 数据库隔离级别 </span> </a> </li> <li class=md-nav__item> <a href=#mvcc class=md-nav__link> <span class=md-ellipsis> MVCC 机制 </span> </a> </li> <li class=md-nav__item> <a href=#_14 class=md-nav__link> <span class=md-ellipsis> 数据库锁 </span> </a> <nav class=md-nav aria-label=数据库锁> <ul class=md-nav__list> <li class=md-nav__item> <a href=#_15 class=md-nav__link> <span class=md-ellipsis> 操作系统中的锁 </span> </a> </li> <li class=md-nav__item> <a href=#_16 class=md-nav__link> <span class=md-ellipsis> 乐观锁与悲观锁 </span> </a> <nav class=md-nav aria-label=乐观锁与悲观锁> <ul class=md-nav__list> <li class=md-nav__item> <a href=#_17 class=md-nav__link> <span class=md-ellipsis> 乐观锁 </span> </a> </li> <li class=md-nav__item> <a href=#_18 class=md-nav__link> <span class=md-ellipsis> 悲观锁 </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#_19 class=md-nav__link> <span class=md-ellipsis> 读锁写锁 </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#_20 class=md-nav__link> <span class=md-ellipsis> 锁的粒度 </span> </a> <nav class=md-nav aria-label=锁的粒度> <ul class=md-nav__list> <li class=md-nav__item> <a href=#_21 class=md-nav__link> <span class=md-ellipsis> 全局锁 </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#_22 class=md-nav__link> <span class=md-ellipsis> 共享锁/排它锁 </span> </a> <nav class=md-nav aria-label=共享锁/排它锁> <ul class=md-nav__list> <li class=md-nav__item> <a href=#_23 class=md-nav__link> <span class=md-ellipsis> 读锁 </span> </a> </li> <li class=md-nav__item> <a href=#_24 class=md-nav__link> <span class=md-ellipsis> 写锁 </span> </a> </li> <li class=md-nav__item> <a href=#_25 class=md-nav__link> <span class=md-ellipsis> 锁的释放 </span> </a> </li> <li class=md-nav__item> <a href=#_26 class=md-nav__link> <span class=md-ellipsis> 意向锁 </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#_27 class=md-nav__link> <span class=md-ellipsis> 间隙锁 </span> </a> <nav class=md-nav aria-label=间隙锁> <ul class=md-nav__list> <li class=md-nav__item> <a href=#_28 class=md-nav__link> <span class=md-ellipsis> 锁定区间 </span> </a> </li> <li class=md-nav__item> <a href=#_29 class=md-nav__link> <span class=md-ellipsis> 加锁规则 </span> </a> </li> <li class=md-nav__item> <a href=#_30 class=md-nav__link> <span class=md-ellipsis> 实战 </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#_31 class=md-nav__link> <span class=md-ellipsis> 临键锁 </span> </a> </li> <li class=md-nav__item> <a href=#mdl class=md-nav__link> <span class=md-ellipsis> MDL 锁 </span> </a> <nav class=md-nav aria-label="MDL 锁"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#_32 class=md-nav__link> <span class=md-ellipsis> 踩坑实战一 </span> </a> <nav class=md-nav aria-label=踩坑实战一> <ul class=md-nav__list> <li class=md-nav__item> <a href=#_33 class=md-nav__link> <span class=md-ellipsis> 排查思路 </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#_34 class=md-nav__link> <span class=md-ellipsis> 踩坑实战二 </span> </a> <nav class=md-nav aria-label=踩坑实战二> <ul class=md-nav__list> <li class=md-nav__item> <a href=#_35 class=md-nav__link> <span class=md-ellipsis> 排查思路 </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#online-ddl class=md-nav__link> <span class=md-ellipsis> Online DDL </span> </a> </li> <li class=md-nav__item> <a href=#mysql-ddl class=md-nav__link> <span class=md-ellipsis> MySQL 原子 DDL </span> </a> <nav class=md-nav aria-label="MySQL 原子 DDL"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#ddl class=md-nav__link> <span class=md-ellipsis> 支持的 DDL 语句 </span> </a> </li> <li class=md-nav__item> <a href=#ddl_1 class=md-nav__link> <span class=md-ellipsis> 原子 DDL 的特性 </span> </a> </li> </ul> </nav> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#mysql_1 class=md-nav__link> <span class=md-ellipsis> MySQL锁问题排查 </span> </a> <nav class=md-nav aria-label=MySQL锁问题排查> <ul class=md-nav__list> <li class=md-nav__item> <a href=#_36 class=md-nav__link> <span class=md-ellipsis> 基础检查 </span> </a> </li> <li class=md-nav__item> <a href=#_37 class=md-nav__link> <span class=md-ellipsis> 必要时调整采集粒度 </span> </a> </li> <li class=md-nav__item> <a href=#_38 class=md-nav__link> <span class=md-ellipsis> 核心视图 </span> </a> </li> <li class=md-nav__item> <a href=#_39 class=md-nav__link> <span class=md-ellipsis> 锁排查实战 </span> </a> </li> <li class=md-nav__item> <a href=#_40 class=md-nav__link> <span class=md-ellipsis> 关键注意事项与最佳实践 </span> </a> </li> </ul> </nav> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=../12.MySQL%E5%86%85%E5%AD%98%E6%A6%82%E8%BF%B0/ class=md-nav__link> <span class=md-ellipsis> 12. MySQL内存概述 </span> </a> </li> <li class=md-nav__item> <a href=../13.MySQL%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%93%E5%BC%80%E5%92%8C%E5%85%B3%E9%97%AD%E8%A1%A8/ class=md-nav__link> <span class=md-ellipsis> 13. MySQL是如何打开和关闭表 </span> </a> </li> <li class=md-nav__item> <a href=../14.MySQL%E6%95%B0%E6%8D%AE%E5%AD%97%E5%85%B8/ class=md-nav__link> <span class=md-ellipsis> 14. MySQL数据字典 </span> </a> </li> <li class=md-nav__item> <a href=../15.%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/ class=md-nav__link> <span class=md-ellipsis> 15. MySQL数据文件格式 </span> </a> </li> <li class=md-nav__item> <a href=../16.MySQL%E5%88%86%E5%8C%BA%E8%A1%A8/ class=md-nav__link> <span class=md-ellipsis> 16. MySQL分区表 </span> </a> </li> <li class=md-nav__item> <a href=../17.MySQL%E5%BF%AB%E9%80%9F%E5%AF%BC%E5%85%A5%E6%95%B0%E6%8D%AE/ class=md-nav__link> <span class=md-ellipsis> 17. MySQL快速导入数据 </span> </a> </li> <li class=md-nav__item> <a href=../18.MySQL%E4%B8%B4%E6%97%B6%E8%A1%A8/ class=md-nav__link> <span class=md-ellipsis> 18. MySQL临时表 </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_4> <label class=md-nav__link for=__nav_4 id=__nav_4_label tabindex=0> <span class=md-ellipsis> SQL特性 </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=1 aria-labelledby=__nav_4_label aria-expanded=false> <label class=md-nav__title for=__nav_4> <span class="md-nav__icon md-icon"></span> SQL特性 </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../sql/sql2023/ class=md-nav__link> <span class=md-ellipsis> 1.SQL2023新特性 </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_5> <label class=md-nav__link for=__nav_5 id=__nav_5_label tabindex=0> <span class=md-ellipsis> MySQL基础 </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=1 aria-labelledby=__nav_5_label aria-expanded=false> <label class=md-nav__title for=__nav_5> <span class="md-nav__icon md-icon"></span> MySQL基础 </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../foundmental/2.MySQL%E7%B4%A2%E5%BC%95/ class=md-nav__link> <span class=md-ellipsis> 1.索引相关 </span> </a> </li> <li class=md-nav__item> <a href=../../dev/02.%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/ class=md-nav__link> <span class=md-ellipsis> 2.数据库设计 </span> </a> </li> <li class=md-nav__item> <a href=../../dev/03.%E5%9C%A8%E7%BA%BFDDL/ class=md-nav__link> <span class=md-ellipsis> 3.在线DDL </span> </a> </li> <li class=md-nav__item> <a href=../../dev/04.MySQL%E8%BF%9E%E8%A1%A8%E6%9F%A5%E8%AF%A2%E7%AE%97%E6%B3%95/ class=md-nav__link> <span class=md-ellipsis> 4.联表算法 </span> </a> </li> <li class=md-nav__item> <a href=../../dev/05.MySQL-insert%E8%AF%AD%E6%B3%95/ class=md-nav__link> <span class=md-ellipsis> 5.insert语法 </span> </a> </li> <li class=md-nav__item> <a href=../../dev/06.MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/ class=md-nav__link> <span class=md-ellipsis> 6.MySQL主从复制 </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_6> <label class=md-nav__link for=__nav_6 id=__nav_6_label tabindex=0> <span class=md-ellipsis> MySQL高级 </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=1 aria-labelledby=__nav_6_label aria-expanded=false> <label class=md-nav__title for=__nav_6> <span class="md-nav__icon md-icon"></span> MySQL高级 </label> <ul class=md-nav__list data-md-scrollfix> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_6_1> <label class=md-nav__link for=__nav_6_1 id=__nav_6_1_label tabindex=0> <span class=md-ellipsis> 深入理解innoDB存储引擎 </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=2 aria-labelledby=__nav_6_1_label aria-expanded=false> <label class=md-nav__title for=__nav_6_1> <span class="md-nav__icon md-icon"></span> 深入理解innoDB存储引擎 </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../advanced/1.MySQL%E6%9E%B6%E6%9E%84%E5%88%B0InnoDB%E6%9E%B6%E6%9E%84/ class=md-nav__link> <span class=md-ellipsis> 1.MySQL架构到innoDB架构 </span> </a> </li> <li class=md-nav__item> <a href=../../advanced/2.InnoDB%E2%80%94%E2%80%94%E7%AE%80%E4%BB%8B/ class=md-nav__link> <span class=md-ellipsis> 2.InnoDB——简介 </span> </a> </li> <li class=md-nav__item> <a href=../../advanced/3.InnoDB%E2%80%94%E2%80%94%E5%85%B3%E9%94%AE%E7%89%B9%E6%80%A7/ class=md-nav__link> <span class=md-ellipsis> 3.InnoDB关键特性 </span> </a> </li> <li class=md-nav__item> <a href=../../advanced/4.InnoDB%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E7%BC%93%E5%86%B2%E6%B1%A0/ class=md-nav__link> <span class=md-ellipsis> 4.InnoDB内存结构——缓冲池 </span> </a> </li> <li class=md-nav__item> <a href=../../advanced/5.MySQL%E6%BA%90%E4%BB%A3%E7%A0%81%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83/ class=md-nav__link> <span class=md-ellipsis> 5.搭建MySQL源代码调试debug环境 </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_6_2> <label class=md-nav__link for=__nav_6_2 id=__nav_6_2_label tabindex=0> <span class=md-ellipsis> OLAP </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=2 aria-labelledby=__nav_6_2_label aria-expanded=false> <label class=md-nav__title for=__nav_6_2> <span class="md-nav__icon md-icon"></span> OLAP </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../olap/01.OLAP%E6%A6%82%E8%BF%B0/ class=md-nav__link> <span class=md-ellipsis> 1.0.OLAP概述 </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_6_3> <label class=md-nav__link for=__nav_6_3 id=__nav_6_3_label tabindex=0> <span class=md-ellipsis> MySQL协议分析 </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=2 aria-labelledby=__nav_6_3_label aria-expanded=false> <label class=md-nav__title for=__nav_6_3> <span class="md-nav__icon md-icon"></span> MySQL协议分析 </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../foundmental/1.MySQL%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8A%93%E5%8C%85%E6%A6%82%E8%BF%B0/ class=md-nav__link> <span class=md-ellipsis> 1.协议分析概述 </span> </a> </li> </ul> </nav> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_7> <label class=md-nav__link for=__nav_7 id=__nav_7_label tabindex=0> <span class=md-ellipsis> MySQL调优 </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=1 aria-labelledby=__nav_7_label aria-expanded=false> <label class=md-nav__title for=__nav_7> <span class="md-nav__icon md-icon"></span> MySQL调优 </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../optimize/1.overview/ class=md-nav__link> <span class=md-ellipsis> 调优概述 </span> </a> </li> <li class=md-nav__item> <a href=../../optimize/many_tables/ class=md-nav__link> <span class=md-ellipsis> 数据大小 </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_8> <label class=md-nav__link for=__nav_8 id=__nav_8_label tabindex=0> <span class=md-ellipsis> PostgreSQL </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=1 aria-labelledby=__nav_8_label aria-expanded=false> <label class=md-nav__title for=__nav_8> <span class="md-nav__icon md-icon"></span> PostgreSQL </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../postgresql/01.postgresql%E7%AE%80%E4%BB%8B/ class=md-nav__link> <span class=md-ellipsis> 1. PostgreSQL简介 </span> </a> </li> <li class=md-nav__item> <a href=../../postgresql/02.postgresql%E5%AE%89%E8%A3%85/ class=md-nav__link> <span class=md-ellipsis> 2. PogreSQL安装 </span> </a> </li> <li class=md-nav__item> <a href=../../postgresql/03.%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/ class=md-nav__link> <span class=md-ellipsis> 3. PogreSQL体系架构 </span> </a> </li> <li class=md-nav__item> <a href=../../postgresql/04.postgresql%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/ class=md-nav__link> <span class=md-ellipsis> 4. PogreSQL访问控制 </span> </a> </li> <li class=md-nav__item> <a href=../../postgresql/05.%E5%B8%B8%E7%94%A8SQL/ class=md-nav__link> <span class=md-ellipsis> 5. 常用SQL </span> </a> </li> <li class=md-nav__item> <a href=../../postgresql/06.%E7%BB%A7%E6%89%BF%E8%A1%A8/ class=md-nav__link> <span class=md-ellipsis> 6. 继承 </span> </a> </li> <li class=md-nav__item> <a href=../../postgresql/07.%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0/ class=md-nav__link> <span class=md-ellipsis> 7. 用户自定义函数UDF </span> </a> </li> <li class=md-nav__item> <a href=../../postgresql/08.%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/ class=md-nav__link> <span class=md-ellipsis> 8. 基本数据类型 </span> </a> </li> <li class=md-nav__item> <a href=../../postgresql/09.%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F/ class=md-nav__link> <span class=md-ellipsis> 9. 可执行程序 </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_9> <label class=md-nav__link for=__nav_9 id=__nav_9_label tabindex=0> <span class=md-ellipsis> MongoDB </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=1 aria-labelledby=__nav_9_label aria-expanded=false> <label class=md-nav__title for=__nav_9> <span class="md-nav__icon md-icon"></span> MongoDB </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../mongodb/01.%E7%AE%80%E4%BB%8B/ class=md-nav__link> <span class=md-ellipsis> 0. MongoDB概述 </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_10> <label class=md-nav__link for=__nav_10 id=__nav_10_label tabindex=0> <span class=md-ellipsis> Redis </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=1 aria-labelledby=__nav_10_label aria-expanded=false> <label class=md-nav__title for=__nav_10> <span class="md-nav__icon md-icon"></span> Redis </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../redis/01.redis%E7%AE%80%E4%BB%8B/ class=md-nav__link> <span class=md-ellipsis> 0. redis概述 </span> </a> </li> <li class=md-nav__item> <a href=../../redis/02.redis%E5%AE%A2%E6%88%B7%E7%AB%AF/ class=md-nav__link> <span class=md-ellipsis> 2. redis客户端 </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_11> <label class=md-nav__link for=__nav_11 id=__nav_11_label tabindex=0> <span class=md-ellipsis> 算法 </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=1 aria-labelledby=__nav_11_label aria-expanded=false> <label class=md-nav__title for=__nav_11> <span class="md-nav__icon md-icon"></span> 算法 </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../%E7%AE%97%E6%B3%95/01.%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/ class=md-nav__link> <span class=md-ellipsis> 0. 算法概述 </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_12> <label class=md-nav__link for=__nav_12 id=__nav_12_label tabindex=0> <span class=md-ellipsis> Oracle </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=1 aria-labelledby=__nav_12_label aria-expanded=false> <label class=md-nav__title for=__nav_12> <span class="md-nav__icon md-icon"></span> Oracle </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../oracle/01.Oracle%E6%A6%82%E8%BF%B0/ class=md-nav__link> <span class=md-ellipsis> 1.Oracle概述 </span> </a> </li> <li class=md-nav__item> <a href=../../oracle/02.oracle安装.md class=md-nav__link> <span class=md-ellipsis> 2.Oracle安装 </span> </a> </li> <li class=md-nav__item> <a href=../../oracle/03.Oracle体系架构.md class=md-nav__link> <span class=md-ellipsis> 3.Oracle体系架构 </span> </a> </li> <li class=md-nav__item> <a href=../../oracle/04.oracle访问控制.md class=md-nav__link> <span class=md-ellipsis> 4.Oracle访问控制 </span> </a> </li> <li class=md-nav__item> <a href=../../oracle/05.常用SQL.md class=md-nav__link> <span class=md-ellipsis> 5.常用SQL </span> </a> </li> <li class=md-nav__item> <a href=../../oracle/06.%E8%BE%BE%E6%A2%A6%E4%BC%98%E5%8C%96/ class=md-nav__link> <span class=md-ellipsis> 6.达梦优化 </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_13> <label class=md-nav__link for=__nav_13 id=__nav_13_label tabindex=0> <span class=md-ellipsis> network </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=1 aria-labelledby=__nav_13_label aria-expanded=false> <label class=md-nav__title for=__nav_13> <span class="md-nav__icon md-icon"></span> network </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../network/1.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/ class=md-nav__link> <span class=md-ellipsis> 1.计算机网络概述 </span> </a> </li> </ul> </nav> </li> </ul> </nav> </div> </div> </div> <div class="md-sidebar md-sidebar--secondary" data-md-component=sidebar data-md-type=toc> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--secondary" aria-label=目录> <label class=md-nav__title for=__toc> <span class="md-nav__icon md-icon"></span> 目录 </label> <ul class=md-nav__list data-md-component=toc data-md-scrollfix> <li class=md-nav__item> <a href=#_1 class=md-nav__link> <span class=md-ellipsis> 数据库事务 </span> </a> <nav class=md-nav aria-label=数据库事务> <ul class=md-nav__list> <li class=md-nav__item> <a href=#_2 class=md-nav__link> <span class=md-ellipsis> 本地事务 </span> </a> </li> <li class=md-nav__item> <a href=#_3 class=md-nav__link> <span class=md-ellipsis> 分布式事务 </span> </a> </li> <li class=md-nav__item> <a href=#_4 class=md-nav__link> <span class=md-ellipsis> 查询会不会开事务？ </span> </a> </li> <li class=md-nav__item> <a href=#_5 class=md-nav__link> <span class=md-ellipsis> 事务开启时间 </span> </a> </li> <li class=md-nav__item> <a href=#_6 class=md-nav__link> <span class=md-ellipsis> 事务保存点 </span> </a> </li> <li class=md-nav__item> <a href=#mysql class=md-nav__link> <span class=md-ellipsis> MySQL中的事务 </span> </a> <nav class=md-nav aria-label=MySQL中的事务> <ul class=md-nav__list> <li class=md-nav__item> <a href=#_7 class=md-nav__link> <span class=md-ellipsis> 事务对象和事务池 </span> </a> </li> <li class=md-nav__item> <a href=#_8 class=md-nav__link> <span class=md-ellipsis> 用户事务和内部事务 </span> </a> </li> </ul> </nav> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#_9 class=md-nav__link> <span class=md-ellipsis> 并发控制 </span> </a> <nav class=md-nav aria-label=并发控制> <ul class=md-nav__list> <li class=md-nav__item> <a href=#_10 class=md-nav__link> <span class=md-ellipsis> 脏读现象 </span> </a> </li> <li class=md-nav__item> <a href=#_11 class=md-nav__link> <span class=md-ellipsis> 不可重复读 </span> </a> </li> <li class=md-nav__item> <a href=#_12 class=md-nav__link> <span class=md-ellipsis> 幻读 </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#_13 class=md-nav__link> <span class=md-ellipsis> 数据库隔离级别 </span> </a> </li> <li class=md-nav__item> <a href=#mvcc class=md-nav__link> <span class=md-ellipsis> MVCC 机制 </span> </a> </li> <li class=md-nav__item> <a href=#_14 class=md-nav__link> <span class=md-ellipsis> 数据库锁 </span> </a> <nav class=md-nav aria-label=数据库锁> <ul class=md-nav__list> <li class=md-nav__item> <a href=#_15 class=md-nav__link> <span class=md-ellipsis> 操作系统中的锁 </span> </a> </li> <li class=md-nav__item> <a href=#_16 class=md-nav__link> <span class=md-ellipsis> 乐观锁与悲观锁 </span> </a> <nav class=md-nav aria-label=乐观锁与悲观锁> <ul class=md-nav__list> <li class=md-nav__item> <a href=#_17 class=md-nav__link> <span class=md-ellipsis> 乐观锁 </span> </a> </li> <li class=md-nav__item> <a href=#_18 class=md-nav__link> <span class=md-ellipsis> 悲观锁 </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#_19 class=md-nav__link> <span class=md-ellipsis> 读锁写锁 </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#_20 class=md-nav__link> <span class=md-ellipsis> 锁的粒度 </span> </a> <nav class=md-nav aria-label=锁的粒度> <ul class=md-nav__list> <li class=md-nav__item> <a href=#_21 class=md-nav__link> <span class=md-ellipsis> 全局锁 </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#_22 class=md-nav__link> <span class=md-ellipsis> 共享锁/排它锁 </span> </a> <nav class=md-nav aria-label=共享锁/排它锁> <ul class=md-nav__list> <li class=md-nav__item> <a href=#_23 class=md-nav__link> <span class=md-ellipsis> 读锁 </span> </a> </li> <li class=md-nav__item> <a href=#_24 class=md-nav__link> <span class=md-ellipsis> 写锁 </span> </a> </li> <li class=md-nav__item> <a href=#_25 class=md-nav__link> <span class=md-ellipsis> 锁的释放 </span> </a> </li> <li class=md-nav__item> <a href=#_26 class=md-nav__link> <span class=md-ellipsis> 意向锁 </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#_27 class=md-nav__link> <span class=md-ellipsis> 间隙锁 </span> </a> <nav class=md-nav aria-label=间隙锁> <ul class=md-nav__list> <li class=md-nav__item> <a href=#_28 class=md-nav__link> <span class=md-ellipsis> 锁定区间 </span> </a> </li> <li class=md-nav__item> <a href=#_29 class=md-nav__link> <span class=md-ellipsis> 加锁规则 </span> </a> </li> <li class=md-nav__item> <a href=#_30 class=md-nav__link> <span class=md-ellipsis> 实战 </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#_31 class=md-nav__link> <span class=md-ellipsis> 临键锁 </span> </a> </li> <li class=md-nav__item> <a href=#mdl class=md-nav__link> <span class=md-ellipsis> MDL 锁 </span> </a> <nav class=md-nav aria-label="MDL 锁"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#_32 class=md-nav__link> <span class=md-ellipsis> 踩坑实战一 </span> </a> <nav class=md-nav aria-label=踩坑实战一> <ul class=md-nav__list> <li class=md-nav__item> <a href=#_33 class=md-nav__link> <span class=md-ellipsis> 排查思路 </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#_34 class=md-nav__link> <span class=md-ellipsis> 踩坑实战二 </span> </a> <nav class=md-nav aria-label=踩坑实战二> <ul class=md-nav__list> <li class=md-nav__item> <a href=#_35 class=md-nav__link> <span class=md-ellipsis> 排查思路 </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#online-ddl class=md-nav__link> <span class=md-ellipsis> Online DDL </span> </a> </li> <li class=md-nav__item> <a href=#mysql-ddl class=md-nav__link> <span class=md-ellipsis> MySQL 原子 DDL </span> </a> <nav class=md-nav aria-label="MySQL 原子 DDL"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#ddl class=md-nav__link> <span class=md-ellipsis> 支持的 DDL 语句 </span> </a> </li> <li class=md-nav__item> <a href=#ddl_1 class=md-nav__link> <span class=md-ellipsis> 原子 DDL 的特性 </span> </a> </li> </ul> </nav> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#mysql_1 class=md-nav__link> <span class=md-ellipsis> MySQL锁问题排查 </span> </a> <nav class=md-nav aria-label=MySQL锁问题排查> <ul class=md-nav__list> <li class=md-nav__item> <a href=#_36 class=md-nav__link> <span class=md-ellipsis> 基础检查 </span> </a> </li> <li class=md-nav__item> <a href=#_37 class=md-nav__link> <span class=md-ellipsis> 必要时调整采集粒度 </span> </a> </li> <li class=md-nav__item> <a href=#_38 class=md-nav__link> <span class=md-ellipsis> 核心视图 </span> </a> </li> <li class=md-nav__item> <a href=#_39 class=md-nav__link> <span class=md-ellipsis> 锁排查实战 </span> </a> </li> <li class=md-nav__item> <a href=#_40 class=md-nav__link> <span class=md-ellipsis> 关键注意事项与最佳实践 </span> </a> </li> </ul> </nav> </li> </ul> </nav> </div> </div> </div> <div class=md-content data-md-component=content> <article class="md-content__inner md-typeset"> <h1>11. MySQL事务和锁</h1> <h2 id=_1>数据库事务<a class=headerlink href=#_1 title="Permanent link">&para;</a></h2> <p>数据库事务(Database Transaction)，一般是指要做的或所做的事情。在计算机术语中是指访问并可能更新数据库中各种数据项的一个程序执行单元(unit)。</p> <p><mark><strong>一个数据库事务通常包含对数据库进行读或写的一个操作序列</strong></mark>。它的存在有以下两个目的：</p> <ul> <li>为数据库操作序列提供了一个从失败中恢复到正常状态的方法，同时提供了数据库即使在异常状态下仍能保持一致性的方法。</li> <li>当多个应用程序在并发访问数据库时，可以在这些应用程序之间提供一个隔离方法，以防止彼此的操作互相干扰。</li> </ul> <p>传统关系型数据库 <strong>事务</strong> 是访问并可能更新各种数据项的一个程序执行 <strong>单元</strong> (unit)。</p> <p>事务由一个或多个步骤组成，一般使用形如 <code>begin transaction</code> 和 <code>end transaction</code> 语句或者函数调用作为事务界限。</p> <p><strong>事务内的所有步骤必须作为一个单一的、不可分割的单元去执行。</strong></p> <p>因此事务的结果只有两种：<strong>1. 全部步骤都执行完成，2. 任一步骤执行失败则整个事务回滚。</strong></p> <p>事务是应用程序中一系列严密的操作，所有操作必须成功完成，否则在每个操作中所作的所有更改都会被撤消。也就是说事务需要具有原子性，一个事务中的一系列的操作要么全部成功，要么一个都不做。</p> <h3 id=_2>本地事务<a class=headerlink href=#_2 title="Permanent link">&para;</a></h3> <p>事务仅限于对单一数据库资源的访问控制，架构服务化以后，事务的概念延伸到了服务中。倘若将一个单一的服务操作作为一个事务，那么整个服务操作只能涉及一个单一的数据库资源,这类基于单个服务单一数据库资源访问的事务，被称为 <strong>本地事务(Local Transaction)</strong>。</p> <p>一个事务被提交给了DBMS（数据库管理系统），则 DBMS 需要确保该事务中的所有操作都成功完成且其结果被永久保存在数据库中，如果事务中有的操作没有成功完成，则事务中的所有操作都需要被回滚，回到事务执行前的状态（要么全执行，要么全都不执行）;</p> <p>同时，该事务对数据库或者其他事务的执行无影响，所有的事务都好像在独立的运行一样。</p> <p>但在现实情况下，失败的风险很高。在一个数据库事务的执行过程中，有可能会遇上事务操作失败、数据库系统/操作系统失败，甚至是存储介质失败等情况。</p> <p>这便需要 DBMS 对一个执行失败的事务执行恢复操作，将其数据库状态恢复到一致状态（数据的一致性得到保证的状态）。</p> <p>为了实现将数据库状态恢复到一致状态的功能，DBMS 通常需要维护事务日志以追踪事务中所有影响数据库数据的操作。</p> <p>事务应该具有 4 个属性：原子性、一致性、隔离性、持久性。这四个属性通常称为 ACID 特性。</p> <ul> <li>原子性(Atomicity)：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。</li> <li>一致性(Consistency)：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态的含义是数据库中的数据应满足完整性约束。</li> <li>隔离性(Isolation)：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。（取决于 RDBMS 的隔离级别）</li> <li>持久性(Durability)： 一个事务一旦提交，他对数据库的修改应该永久保存在数据库中。</li> </ul> <p>在同一个 RDBMS 中，用一个常用的 <strong>A 账户向 B 账号汇钱</strong> 的例子来说明如何通过数据库事务保证数据的准确性和完整性。熟悉关系型数据库事务的都知道从帐号 A 到帐号 B 需要 6 个操作：</p> <div class=codehilite><pre><span></span><code>1. 从A账号中把余额读出来（500）。

2. 对A账号做减法操作（500-100）。

3. 把结果写回A账号中（400）。

4. 从B账号中把余额读出来（500）。

5. 对B账号做加法操作（500+100）。

6. 把结果写回B账号中（600）。
</code></pre></div> <details class=数据库事务 open=open> <summary>数据库事务</summary> <ul> <li> <p>原子性：一个事务必须被视为一个不可分割的最小工作单位，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，不能只执行一部分操作。</p> <p>保证1-6所有过程要么都执行，要么都不执行。一旦在执行某一步骤的过程中发生问题，就需要执行回滚操作。 假如执行到第五步的时候，B账户突然不可用（比如被注销），那么之前的所有操作都应该回滚到执行事务之前的状态。</p> </li> <li> <p>一致性：一致性要求数据库总是从一个一致性的状态转换为另外一个一致性的状态</p> <p>在转账之前，A和B的账户中共有500+500=1000元钱。在转账之后，A和B的账户中共有400+600=1000元。也就是说，数据的状态在执行该事务操作之后从一个状态改变到了另外一个状态。同时一致性还能保证账户余额不会变成负数等。</p> </li> <li> <p>隔离性：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。（取决于RDBMS的事务隔离级别）</p> <p>在A向B转账的整个过程中，只要事务还没有提交（commit），查询A账户和B账户的时候，两个账户里面的钱的数量都不会有变化。 如果在A给B转账的同时，有另外一个事务执行了C给B转账的操作，那么当两个事务都结束的时候，B账户里面的钱应该是A转给B的钱加上C转给B的钱再加上自己原有的钱。</p> </li> <li> <p>持久性：事务一旦提交，所做的状态就会永久保存在数据库中，即使系统奔溃，修改的数据也不会丢。</p> <p>一旦转账成功（事务提交），两个账户的里面的钱就会真的发生变化（会把数据写入数据库做持久化保存）。</p> </li> </ul> </details> <h3 id=_3>分布式事务<a class=headerlink href=#_3 title="Permanent link">&para;</a></h3> <h3 id=_4><strong>查询会不会开事务？</strong><a class=headerlink href=#_4 title="Permanent link">&para;</a></h3> <p>MySQL 中事务默认是隐式事务（即自动提交<code>autocommit=1</code>），在执行 <code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code> 等具体数据操作的时候，数据库自动开启事务、提交或回滚事务。也就是如果不是显式开启一个事务，则每条 SQL 语句都形成独立事务。如果该语句执行后没有返回错误，MySQL 会自动执行 COMMIT。但如果该语句返回错误，则根据错误情况执行 COMMIT 或 ROLLBACK。</p> <p>如果想开启事务，先设置 <code>autocommit=0</code>，然后用 <code>START TRANSACTION</code>、 <code>COMMIT</code>、 <code>ROLLBACK</code> 这些事务控制语句来使用具体的事务。</p> <p>通过如下方式，可以关闭 autocommit；需要注意的是，autocommit 参数是针对连接的，在一个连接中修改了参数，不会对其他连接产生影响。如果你新开一个命令窗口，会恢复到默认值。</p> <div class=highlight><pre><span></span><code><span class=n>mysql</span><span class=o>&gt;</span><span class=w> </span><span class=k>set</span><span class=w> </span><span class=n>autocommit</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>0</span><span class=p>;</span>
<span class=n>Query</span><span class=w> </span><span class=n>OK</span><span class=p>,</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=k>rows</span><span class=w> </span><span class=n>affected</span>

<span class=n>mysql</span><span class=o>&gt;</span><span class=w> </span><span class=k>show</span><span class=w> </span><span class=n>variables</span><span class=w> </span><span class=k>like</span><span class=w> </span><span class=s1>&#39;autocommit&#39;</span><span class=p>;</span>
<span class=o>+</span><span class=c1>---------------+-------+</span>
<span class=o>|</span><span class=w> </span><span class=n>Variable_name</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=n>Value</span><span class=w> </span><span class=o>|</span>
<span class=o>+</span><span class=c1>---------------+-------+</span>
<span class=o>|</span><span class=w> </span><span class=n>autocommit</span><span class=w>    </span><span class=o>|</span><span class=w> </span><span class=k>OFF</span><span class=w>   </span><span class=o>|</span>
<span class=o>+</span><span class=c1>---------------+-------+</span>
<span class=mi>1</span><span class=w> </span><span class=k>row</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=k>set</span>
</code></pre></div> <p>如果关闭了 autocommit，则一个会话中所有的 sql 语句都在一个事务中，直到执行了 commit 或 rollback，该事务结束，同时马上开始下一个事务。</p> <div class=highlight><pre><span></span><code><span class=c1>--窗口一：显式开启事务，加锁执行查询。并未提交事务，锁一直维持</span>
<span class=k>start</span><span class=w>  </span><span class=k>TRANSACTION</span><span class=p>;</span>
<span class=k>select</span><span class=w> </span><span class=o>*</span><span class=w>  </span><span class=k>from</span><span class=w> </span><span class=n>test1</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=k>share</span><span class=w> </span><span class=p>;</span>

<span class=c1>--窗口二：变更表结构，要获取写锁，一直在等待，Waiting for table metadata lock</span>
<span class=k>alter</span><span class=w> </span><span class=k>table</span><span class=w> </span><span class=n>test1</span><span class=w> </span><span class=k>add</span><span class=w> </span><span class=k>COLUMN</span><span class=w> </span><span class=n>test4</span><span class=w> </span><span class=nb>VARCHAR</span><span class=p>(</span><span class=mi>20</span><span class=p>)</span><span class=w> </span><span class=p>;</span>

<span class=c1>--窗口三：查看未提交的事务，有一条记录，正在执行的sql为空</span>
<span class=k>select</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=n>INFORMATION_SCHEMA</span><span class=p>.</span><span class=n>INNODB_TRX</span><span class=p>;</span>
</code></pre></div> <p>事务的一些关键语句</p> <div class=highlight><pre><span></span><code><span class=c1>-- 开始一个新的读写事务:四种写法</span>

<span class=c1>-- BEGIN 语句。这个语句本质上应该是辞旧迎新（提交老事务，准备新事务）。</span>
<span class=c1>-- 在一个会话中，如果前面的一个事务还没提交就遇到BEGIN语句时，这个BEGIN就会提交老事务，准备新事务。</span>
<span class=c1>-- 原因是MySQL不支持嵌套事务。前面的事务没有提交的情况下，又要BEGIN开始一个新事务，前面的事务无处安放，只能被动提交了。  </span>
<span class=k>BEGIN</span><span class=w> </span><span class=p>;</span><span class=w>       </span>
<span class=k>BEGIN</span><span class=w> </span><span class=k>WORK</span><span class=w> </span><span class=p>;</span><span class=w> </span>
<span class=k>START</span><span class=w> </span><span class=k>TRANSACTION</span><span class=w> </span><span class=p>;</span>
<span class=k>START</span><span class=w> </span><span class=k>TRANSACTION</span><span class=w> </span><span class=k>READ</span><span class=w> </span><span class=k>WRITE</span><span class=w> </span><span class=p>;</span>

<span class=c1>-- 开始一个新的只读事务</span>
<span class=k>START</span><span class=w> </span><span class=k>TRANSACTION</span><span class=w> </span><span class=k>READ</span><span class=w> </span><span class=k>ONLY</span>

<span class=c1>-- 这两类语句都不需立即创建一致性读视图，事务的启动将延迟至实际需要时。</span>



<span class=c1>-- 开启一个新的读写事务：两种写法</span>
<span class=k>START</span><span class=w> </span><span class=k>TRANSACTION</span><span class=w> </span><span class=k>WITH</span><span class=w> </span><span class=n>CONSISTENT</span><span class=w> </span><span class=n>SNAPSHOT</span>
<span class=k>START</span><span class=w> </span><span class=k>TRANSACTION</span><span class=w> </span><span class=k>WITH</span><span class=w> </span><span class=n>CONSISTENT</span><span class=w> </span><span class=n>SNAPSHOT</span><span class=p>,</span><span class=w> </span><span class=k>READ</span><span class=w> </span><span class=k>WRITE</span>

<span class=c1>-- 开启一个新的只读事务</span>
<span class=k>START</span><span class=w> </span><span class=k>TRANSACTION</span><span class=w> </span><span class=k>WITH</span><span class=w> </span><span class=n>CONSISTENT</span><span class=w> </span><span class=n>SNAPSHOT</span><span class=p>,</span><span class=w> </span><span class=k>READ</span><span class=w> </span><span class=k>ONLY</span>

<span class=c1>-- 这两类语句都会先启动事务，随后立即创建一致性读视图。</span>
</code></pre></div> <h3 id=_5>事务开启时间<a class=headerlink href=#_5 title="Permanent link">&para;</a></h3> <p>一般我们会认为 begin/start transaction 是事务开始的时间点，也就是一旦我们执行了 start transaction，就认为事务已经开始了，其实这是错误的。</p> <p>上面的实验也说明了这一点。事务开始的真正的时间点(LSN)，是 start transaction 之后执行的第一条语句，不管是什么语句，不管成功与否。</p> <p><a href=https://www.cnblogs.com/digdeep/p/4947694.html>MySQL 一致性读深入研究</a></p> <p><strong>注意，事务是否提交和是否有 sql 在执行，并不是一回事</strong></p> <h3 id=_6>事务保存点<a class=headerlink href=#_6 title="Permanent link">&para;</a></h3> <p>扁平事务（Flat Transaction）是事务类型中最简单的一种，在实际生产环境中，这可能是使用最为频繁的事务。在扁平事务中，所有操作都处于同一层次，其由<code>BEGIN</code>开始，由<code>COMMIT</code>或<code>ROLLBACK</code>结束，其间的操作是原子的，要么都执行，要么都回滚</p> <p>因此扁平事务是应用程序成为原子操作的基本组成模块</p> <p>事务是访问并更新数据库中各种数据项的一个程序执行单元，事务会把数据库从一种一致状态转换为另一种一致状态，这就是事务的目的，也是事务模型区别与文件系统的重要特性之一。</p> <p>我们之前理解的事务操作是原子的，要么都执行，要么都回滚，也就是通常意义上我们理解的事务概念。</p> <p>扁平事务虽然简单，但在实际生产环境中使用最为频繁，故每个数据库系统都实现了对扁平事务的支持扁平事务的主要限制是不能提交或者回滚事务的某一部分，或分几个步骤提交。</p> <p>例如用户在旅行网站上进行自己的旅行度假计划。用户设想从杭州到意大利的佛罗伦萨，这两个城市之间没有直达的班机，需要用户预订并转乘航班，或者需要搭火车等待。用户预订旅行度假的事务为：</p> <div class=highlight><pre><span></span><code><span class=k>BEGIN</span><span class=w> </span><span class=k>WORK</span>
<span class=c1>-- S1：预订杭州到上海的高铁</span>
<span class=c1>-- S2：上海浦东国际机场坐飞机，预订去米兰的航班</span>
<span class=c1>-- S3：在米兰转火车前往佛罗伦萨，预订去佛罗伦萨的火车</span>
</code></pre></div> <p>但是当用户执行到 S3 时，发现由于飞机到达米兰的时间太晚，已经没有当天的火车。这时用户希望在米兰当地住一晚，第二天出发去佛罗伦萨。这时如果事务为扁平事务，则需要回滚之前 S1、S2、S3 的三个操作，这个代价就显得有点大。因为当再次进行该事务时，S1、S2 的执行计划是不变的</p> <p>从限制中看出，如果支持有计划的回滚操作，那么就不需要终止整个事务。因此就出现了带有保存点的扁平事务。</p> <p>带有保存点的扁平事务，除了支持扁平事务支持的操作外，允许在事务执行过程中回滚到同一事务中较早的一个状态。这是因为某些事务可能在执行过程中出现的错误并不会导致所有的操作都无效，放弃整个事务不合乎要求，开销也太大</p> <p>在标准 SQL 中，SQL 语言国际标准中，<code>SAVEPOINT name</code>语句声明一个 savepoint。<code>ROLLBACK TO SAVEPOINT name</code>语句回滚到 savepoint。<code>RELEASE SAVEPOINT name</code>将使得命名的 savepoint 被放弃，但不影响其他 savepoint。<code>ROLLBACK</code>或<code>COMMIT</code>导致所有<code>savepoint</code>被放弃。</p> <p>对于一个事务中有多个语句操作序列，如果支持有计划的回滚操作，那么就不需要终止整个事务。因此就出现了带有**保存点的事务**</p> <p>事务保存点（savepoint），指的是对事务执行过程中做位置保存（类似我们打游戏时的存盘点），如果你写了一大堆的语句，但是有部分是你不想回滚的，想保留修改的状态，但是部分是你想回滚的。</p> <div class=highlight><pre><span></span><code><span class=n>mysql</span><span class=o>&gt;</span><span class=w> </span><span class=k>start</span><span class=w> </span><span class=k>transaction</span><span class=p>;</span><span class=w> </span><span class=c1>--开启事务</span>
<span class=n>Query</span><span class=w> </span><span class=n>OK</span><span class=p>,</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=k>rows</span><span class=w> </span><span class=n>affected</span>

<span class=n>mysql</span><span class=o>&gt;</span><span class=w> </span><span class=k>insert</span><span class=w> </span><span class=k>into</span><span class=w> </span><span class=n>classes</span><span class=w> </span><span class=k>values</span><span class=p>(</span><span class=mi>7</span><span class=p>,</span><span class=s1>&#39;初三七班&#39;</span><span class=p>);</span>
<span class=n>Query</span><span class=w> </span><span class=n>OK</span><span class=p>,</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=k>row</span><span class=w> </span><span class=n>affected</span>

<span class=n>mysql</span><span class=o>&gt;</span><span class=w> </span><span class=n>savepoint</span><span class=w> </span><span class=n>point1</span><span class=p>;</span><span class=w> </span><span class=c1>--注意：这边设置了一个存盘点</span>
<span class=n>Query</span><span class=w> </span><span class=n>OK</span><span class=p>,</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=k>rows</span><span class=w> </span><span class=n>affected</span>

<span class=n>mysql</span><span class=o>&gt;</span><span class=w> </span><span class=k>insert</span><span class=w> </span><span class=k>into</span><span class=w> </span><span class=n>classes</span><span class=w> </span><span class=k>values</span><span class=p>(</span><span class=mi>8</span><span class=p>,</span><span class=s1>&#39;初三八班&#39;</span><span class=p>);</span>
<span class=n>Query</span><span class=w> </span><span class=n>OK</span><span class=p>,</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=k>row</span><span class=w> </span><span class=n>affected</span>

<span class=n>mysql</span><span class=o>&gt;</span><span class=w> </span><span class=k>rollback</span><span class=w> </span><span class=k>to</span><span class=w> </span><span class=n>point1</span><span class=p>;</span><span class=w> </span><span class=c1>--记住这个语法，回滚到存盘点，存盘点之后的语句就丢弃了</span>
<span class=n>Query</span><span class=w> </span><span class=n>OK</span><span class=p>,</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=k>rows</span><span class=w> </span><span class=n>affected</span>

<span class=n>mysql</span><span class=o>&gt;</span><span class=w> </span><span class=k>commit</span><span class=p>;</span>
<span class=n>Query</span><span class=w> </span><span class=n>OK</span><span class=p>,</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=k>rows</span><span class=w> </span><span class=n>affected</span>

<span class=n>mysql</span><span class=o>&gt;</span><span class=w> </span><span class=k>select</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>from</span><span class=w>  </span><span class=n>classes</span><span class=p>;</span><span class=w> </span><span class=c1>--最后输出，确实只有存盘点之前的成功了</span>
<span class=o>+</span><span class=c1>---------+-----------+</span>
<span class=o>|</span><span class=w> </span><span class=n>classid</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=n>classname</span><span class=w> </span><span class=o>|</span>
<span class=o>+</span><span class=c1>---------+-----------+</span>
<span class=o>|</span><span class=w>       </span><span class=mi>1</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=err>初三一班</span><span class=w>  </span><span class=o>|</span>
<span class=o>|</span><span class=w>       </span><span class=mi>2</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=err>初三二班</span><span class=w>  </span><span class=o>|</span>
<span class=o>|</span><span class=w>       </span><span class=mi>3</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=err>初三三班</span><span class=w>  </span><span class=o>|</span>
<span class=o>|</span><span class=w>       </span><span class=mi>4</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=err>初三四班</span><span class=w>  </span><span class=o>|</span>
<span class=o>|</span><span class=w>       </span><span class=mi>5</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=err>初三五班</span><span class=w>  </span><span class=o>|</span>
<span class=o>|</span><span class=w>       </span><span class=mi>6</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=err>初三六班</span><span class=w>  </span><span class=o>|</span>
<span class=o>|</span><span class=w>       </span><span class=mi>7</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=err>初三七班</span><span class=w>  </span><span class=o>|</span>
<span class=o>+</span><span class=c1>---------+-----------+</span>
<span class=mi>7</span><span class=w> </span><span class=k>rows</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=k>set</span>
</code></pre></div> <h3 id=mysql>MySQL中的事务<a class=headerlink href=#mysql title="Permanent link">&para;</a></h3> <p>事务不是<code>MySQL</code>的原生支持，而是<code>InnoDB</code>存储引擎带来的 Feature。旧版本MySQL的默认存储引擎 MyISAM 就不支持事务能力。正因为事务能力，MySQL 的功能越发强大，也是因为事务，MySQL经常存在和索引无关的很多慢查询。</p> <p>前面铺垫了很多数据基础知识，作为<code>MySQL</code>中支持事务的默认存储引擎，InnoDB对表中数据的读写操作都在事务中执行。</p> <p><code>MySQL</code>被设计为支持高并发，支持很多客户端同时连接到数据库，这些连接可以同时执行 <code>SQL</code>。如果这些 <code>SQL</code> 都要读写 InnoDB 表，<code>InnoDB</code> 会为每个连接启动一个事务，这意味着需要同时启动很多事务。</p> <p>对于 <code>OLTP</code> 场景，通常情况下，事务都会很快执行完成。启动事务、执行 SQL、提交事务的整个流程只会持续很短的时间。</p> <p>以这样一个场景为例：</p> <ul> <li>客户端连接到 MySQL;</li> <li>客户端执行 begin 语句;</li> <li>客户端执行一条 update 语句，按主键 ID 更新一条记录;</li> <li>这个步骤中，InnoDB 会在执行 update 语句之前，真正启动一个事务;</li> <li>客户端执行 commit 语句;</li> <li>客户端关闭数据库连接。InnoDB 会在这一步释放事务。</li> </ul> <p>在这个场景下，InnoDB 事务从启动到释放的整个生命周期，有可能只持续 1 ~ 2 毫秒（甚至更短）。</p> <h4 id=_7>事务对象和事务池<a class=headerlink href=#_7 title="Permanent link">&para;</a></h4> <p>由于要存放**事务 ID**、<strong>事务状态</strong>、<strong>Undo日志编号</strong>、<strong>事务所属的用户线程**等信息，每个事务都有一个与之对应的对象，我们称之为**事务对象</strong>。</p> <p>每个事务对象都要占用内存，如果每启动一个事务都要为事务对象分配内存，释放事务时又要释放内存，会降低数据库性能。为了避免频繁分配、释放内存对数据库性能产生影响，InnoDB 引入了事务池（Pool），用于管理事务。</p> <p>顾名思义，事务池中放的是事务对象。事务池也一样有大小限制，不能无限制的存放事务对象。数据库繁忙的时候，有很多很多事务对象，需要多个事务池来管理。事务池多了之后就有如下问题：</p> <ul> <li>事务池的管理分配：怎么创建新的事务池？</li> <li>客户端创建了一个新的数据库连接，要获取一个新的事务对象，从哪个事务池获取？</li> <li>多个</li> </ul> <p>为了解决这些问题，InnoDB 又引入了**事务池管理器（PoolManager）**，用于管理事务池：事务池的创建与初始化。</p> <p>InnoDB 整个生命周期中，事务池管理器只有一个，它有个很重要的属性（m_size），用于指定每个事务池能用多大内存来存放事务对象。这个属性值来源于一个硬编码的常量值。</p> <p><div class=highlight><pre><span></span><code><span class=c1>// https://github.com/mysql/mysql-server/blob/trunk/storage/innobase/trx/trx0trx.cc#L429</span>
<span class=cm>/** Size of on trx_t pool in bytes. */</span>
<span class=k>static</span><span class=w> </span><span class=k>const</span><span class=w> </span><span class=n>ulint</span><span class=w> </span><span class=n>MAX_TRX_BLOCK_SIZE</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>1024</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=mi>1024</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=mi>4</span><span class=p>;</span>
</code></pre></div> 这意味着每个事务池能用来存放事务对象的内存是 4194304 字节，也就是 4 M</p> <p>MySQL 启动过程中，事务池管理器只会创建并初始化一个事务池。这个事务池会放入事务池管理器的 m_pools 属性。这个属性是个数组（vector），用于管理所有事务池。</p> <p>事务的核心数据结构</p> <p><a href=https://github.com/mysql/mysql-server/blob/trunk/storage/innobase/include/trx0trx.h#L675>https://github.com/mysql/mysql-server/blob/trunk/storage/innobase/include/trx0trx.h#L675</a></p> <p><code>trx_t</code>: 整个结构体在每个连接都会持有一个，也就是在创建连接后执行第一个事务开始，整个结构体就被初始化了，后续这个连接的所有事务一直复用里面的数据结构，直到这个连接断开。<strong>可以说这个结构体贯穿连接的整个生命周期，一直被连接内的事务使用。</strong></p> <p><code>trx_lock_t</code>: 在 8.0 中，将 lock 单独从 trx_t 中解耦出来。观察 trx_lock_t 的定义。每个事务都会维护执行过程中加的所有锁（ trx_locks，双向链表），以及发生锁等待时等待的锁（ wait_lock ）</p> <p>同时，事务启动后，就会把这个<code>trx_t</code>结构体加入到全局事务链表中(trx_sys-&gt;mysql_trx_list)，如果是读写事务，还会加入到全局读写事务链表中(trx_sys-&gt;rw_trx_list)。在事务提交的时候，还会加入到全局提交事务链表中(trx_sys-&gt;trx_serial_list)。</p> <div class=highlight><pre><span></span><code>
</code></pre></div> <p>state字段记录了事务四种状态:TRX_STATE_NOT_STARTED, TRX_STATE_ACTIVE, TRX_STATE_PREPARED, TRX_STATE_COMMITTED_IN_MEMORY。</p> <p>从并发控制的角度来看，事务在其生命周期内可能存在如下状态：</p> <ul> <li>TRX_STATE_NOT_STARTED</li> <li>TRX_STATE_FORCED_ROLLBACK</li> <li>TRX_STATE_ACTIVE</li> <li>TRX_STATE_PREPARED</li> <li>TRX_STATE_COMMITTED_IN_MEMORY (alias below COMMITTED)</li> </ul> <p>正常的事务生命周期状态变化： NOT_STARTED -&gt; ACTIVE -&gt; COMMITTED -&gt; NOT_STARTED</p> <h4 id=_8>用户事务和内部事务<a class=headerlink href=#_8 title="Permanent link">&para;</a></h4> <p>InnoDB 读写表中数据的操作都在事务中执行，开始一个事务的方式有两种：</p> <ul> <li>手动：通过 <code>BEGIN</code>、<code>START TRANSACTION</code> 语句以及它们的扩展形式开始一个事务。</li> <li>自动：直接执行一条 SQL 语句，InnoDB 会自动开始一个事务，SQL 语句执行完成之后，又会自动提交这个事务。</li> </ul> <p>这两种方式开始的事务，都用来执行用户 SQL 语句，属于 <strong>用户事务</strong>。正常情况下，用户事务与连接会话都是一对一的。<mark>在 <strong>当前数据库连接</strong> 的操作时序上，事务和事务之间的执行是线性排开依次执行的。</mark></p> <p>（there is a 1:1 relationship between a transaction handle (trx) and a session (client connection). One session is associated with exactly one user transaction）</p> <p>当建立了 java.sql.Connection 连接后，可以不限次数执行事务SQL请求 ，由于Connection对象的通信值基于TCP/IP协议的，当初始化后在手动关闭之前和数据库保持心跳存活连接。所以，可以使用Connection对象执行不限次数的SQL语句请求，包括事务请求。<strong>这个看似比较简单的表述，在实际使用过程中非常重要，数据库连接池就是基于此特性建立的</strong></p> <p>InnoDB 有时候也需要自己执行一些 SQL 语句，为了和用户 SQL 做区分，我们把这些 SQL 称为内部 SQL。内部 SQL 也需要在事务中执行，执行这些 SQL 的事务就是**内部事务**。<strong>内部事务的最大特点就是不跟用户连接相关联</strong>（these transactions would no longer be associated with a session）</p> <p>InnoDB 有几种场景会使用内部事务，以下是其中主要的三种:<a href=https://github.com/mysql/mysql-server/blob/trunk/storage/innobase/include/trx0trx.h#L588>参考</a></p> <ul> <li> <p>如果上次关闭 MySQL 时有未提交，或者正在提交但未提交完成的事务( ACTIVE or PREPARED)，在启动过程中（执行崩溃恢复），InnoDB 会把这些事务恢复为内部事务，然后提交或者回滚。</p> </li> <li> <p>后台线程(比如 purge system )执行一些操作时，需要在内部事务中执行内部 SQL。以 ib_dict_stats 线程为例，它计算各表、索引的统计信息之后，会使用内部事务执行内部 SQL，更新 mysql.innodb_table_stats、mysql.innodb_index_stats 表中的统计信息。</p> </li> <li> <p>为了实现原子操作，DDL 语句执行过程中，InnoDB 会使用**内部事务（）**执行内部 SQL，插入一些数据到 mysql.innodb_ddl_log 表中</p> </li> </ul> <p>事务对象分配</p> <p>InnoDB 用事务池来管理事务对象，用事务池管理器来管理事务池。</p> <p>不管是用户事务，还是内部事务，真正启动事务之前，都需要通过事务池管理器从某个事务池的事务队列中分配一个事务对象。</p> <p>分配事务对象之后，InnoDB 还会对事务对象的几个属性再做一次初始化工作，把这几个属性再一次设置为初始值，其实就是对这些属性做了重复的赋值操作。</p> <p>这些属性中，有必要提一下的是事务状态（trx-&gt;state）。出厂设置的事务对象，事务状态是 TRX_STATE_NOT_STARTED，表示事务还没有开始。</p> <p>事务的启动</p> <h2 id=_9>并发控制<a class=headerlink href=#_9 title="Permanent link">&para;</a></h2> <blockquote> <p>在计算机科学，特别是程序设计、操作系统、多处理机和数据库等领域，并发控制（Concurrency control）是确保及时纠正由并发操作导致的错误的一种机制。</p> </blockquote> <p>我们都知道事务的几种性质，数据库为了维护这些性质，尤其是 <strong>一致性</strong> 和 <strong>隔离性</strong> ，一般使用 <strong>加锁</strong> 这种方式。</p> <p>同时数据库又是个高并发的应用，同一时间会有大量的并发访问，如果加锁过度，会极大的降低并发处理能力。</p> <p><strong>所以对于加锁的处理，可以说就是数据库对于事务处理的精髓所在。</strong></p> <p>数据库管理系统（DBMS）中的并发控制的任务是 <strong>确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和一致性以及数据库的统一性。</strong></p> <h3 id=_10>脏读现象<a class=headerlink href=#_10 title="Permanent link">&para;</a></h3> <p>一句话概况：一个事务读取到了另外事务中未提交的数据。</p> <p>脏读是指在数据库访问中，当一个事务 A 正在访问数据，并且对数据进行了修改，而这种修改事务还没有提交到数据库中，这时另外一个事务 B 也访问这个数据，然后使用了这个数据。</p> <p>然后 A 又进行回滚操作，则事务 B 访问的数据是无效的。即上述转账例子中，转账事务进行到一半的时候，此时另外一个事务去读了 A 账号的余额，然后以前的转账事务回滚，A 的余额变回以前的值。</p> <p>此时后面读余额的事务即为脏读。在高并发情况下和对数据准确性要求较高的情况下，这个现象几乎是不能容忍的。</p> <p>举一个实际场景中的例子：两个火车票代售点，同时读取 12306 数据库中的某趟列车的车票余票数量为 X，然后同时卖出一张票，然后同时提交了 X-1 到数据库中，这样就造成了卖了两张票，而库中记录只减了一张。生这种情况的原因是因为两个事务读入同一数据并同时修改，其中一个事务提交的结果破坏了另一个事务提交的结果，导致其数据的修改被丢失，破坏了事务的隔离性。并发控制要解决的就是这类问题。</p> <h3 id=_11>不可重复读<a class=headerlink href=#_11 title="Permanent link">&para;</a></h3> <p>一句话概括：同一事务内前后多次读取，数据内容不一致（第二次读到了其他事务更新提交的数据）</p> <p>事务 A 在执行读取操作，由整个事务 A 比较大，前后读取同一条数据需要经历很长的时间 。而在事务 A 第一次读取数据，比如此时读取了小明的年龄为 20 岁，事务 B 执行更改操作，将小明的年龄更改为 30 岁，此时事务 A 第二次读取到小明的年龄时，发现其年龄是 30 岁，和之前的数据不一样了，也就是数据不重复了，系统不可以读取到重复的数据，成为不可重复读。</p> <h3 id=_12>幻读<a class=headerlink href=#_12 title="Permanent link">&para;</a></h3> <p>事务 T1 读取一组满足某些 &lt;搜索条件&gt; 的数据。事务 T2 创建了满足 T1 的 &lt;搜索条件&gt; 的数据项并提交。如果 T1 用相同的&lt;搜索条件&gt;再次读取，得到一组不同于第一次读取的数据。这就叫幻读。</p> <p>当同一个查询在不同的时间产生不同的结果集时，事务中就会出现所谓的幻象问题。例如，如果 SELECT 执行了两次，但第二次返回了第一次没有返回的行，则该行是“幻像”行。</p> <p>不可重复读和幻读有什么不同？</p> <p>注意和幻读定义的两个不同</p> <ul> <li>幻读定义中有 &lt; search condition &gt;</li> <li>幻读定义中 T2 是“创建数据”，不可重复读的定义中 T2 是修改或者删除数据</li> </ul> <p>在满足 &lt; search condition &gt; 的范围内，修改和删除数据必定是对已经存在的数据行操作，而创建数据则意味着创建之前这个数据项是不存在的。</p> <p>"创建数据"不仅是<code>insert</code>，还包括<code>update</code>, <code>update</code> 把本来不满足谓词范围的数据项更新成满足谓词范围的数据项，比如：谓词范围是 <code>a&gt;1 and a&lt;5</code>，<code>update a=4 where a=6</code> 就是这样的情况。</p> <h2 id=_13>数据库隔离级别<a class=headerlink href=#_13 title="Permanent link">&para;</a></h2> <p>ANSI/ISO SQL 定义的 SQL 标准中描述了四种隔离级别，从高到底依次为：</p> <ul> <li>序列化(Serializable)</li> <li>可重复读(Repeatable reads)</li> <li>读已提交(Read committed)</li> <li>读未提交读(Read uncommitted)</li> </ul> <p>对应的隔离级别如下：</p> <table> <thead> <tr> <th>隔离级别</th> <th>脏读现象</th> <th>不可重复读现象</th> <th>幻读现象</th> </tr> </thead> <tbody> <tr> <td>读未提交读</td> <td>可能</td> <td>可能</td> <td>可能</td> </tr> <tr> <td>读已提交</td> <td>不可能</td> <td>可能</td> <td>可能</td> </tr> <tr> <td>可重复读</td> <td>不可能</td> <td>不可能</td> <td>可能</td> </tr> <tr> <td>序列化</td> <td>不可能</td> <td>不可能</td> <td>不可能</td> </tr> </tbody> </table> <blockquote> <p>注意，不同的数据库厂商对 SQL 标准中规定的这四种隔离级别的支持不一样，有的 RDBMS 数据库只实现了其中几种隔离级别，我们讨论的 MySQL 虽然支持 4 种隔离级别，但是与 SQL 标准中规定的各级隔离级别允许发生的现象却有些出入。</p> </blockquote> <p>四个隔离级别从上到下对事务执行的并发程度进行了不同程度的限制，更加严格的限制在带来更好的数据一致性的同时，也会损失更多并发带来的高性能。</p> <p>实际使用中，隔离级别并不是越高就越好，大多数情况下应用并不需要很高的数据一致性。相反的，在多用户环境下，更强调的是并发度。所以综合考虑选取一个折中的办法往往能达到最优的效果。</p> <p>在大多数 <code>RDBMS</code> 中，设置的隔离级别可能都是读已经提交。</p> <ul> <li> <p>MySQL 默认隔离级别是 REPEATABLE-READ，实际上 MySQL 内部通过 MVCC 和间隙锁解决了幻读的问题。</p> </li> <li> <p>PostgreSQL 内部实际上只支持提交读、可重复读、序列化三种级别，PostgreSQL 内部会将 <code>Read uncommitted</code> 视同为 <code>Read commit</code> 处理。默认是 <code>Read commit</code></p> </li> </ul> <h2 id=mvcc>MVCC 机制<a class=headerlink href=#mvcc title="Permanent link">&para;</a></h2> <p>MVCC 的核心思想是为每个数据行保存其在不同时间点的版本，并通过版本号或时间戳来标识这些版本。当一个事务开始时，MySQL 会为该事务创建一个独立的事务 ID，并利用这个 ID 去获取数据的一致性快照。</p> <p>为了实现<code>READ COMMITTED</code>以及<code>REPEATABLE READ</code>，<strong>我们需要保证不同的事务在某一时刻只能看到一部分历史数据或者自己所修改的数据</strong>，而多版本并发控制（Multiversion concurrency control）通过 undo log 组成的版本链以及 ReadView 帮我们实现了这一点。</p> <p>对于使用 InnoDB 存储引擎的表来说，每行记录后面会有三个隐藏字段：</p> <ul> <li> <p>DB_TRX_ID：表示最后一次修改本记录的事务 ID，占用 6 字节</p> </li> <li> <p>DB_ROLL_PTR：回滚指针，指向 undo log 中本记录的上一个版本，可以通过回滚指针将所有记录串成了一个版本链</p> </li> <li> <p>DB_ROW_ID：自增 ID，如果表没有定义主键或者没有列是唯一非空的，就会生成这个隐藏列，对于我们的 tbl_user 表不存在这个隐藏列</p> </li> </ul> <p>为了实现原子性，每当事务修改一条记录（INSERT、UPDATE 或者 DELETE）时，都会在类型为 FIL_PAGE_UNDO_LOG 的页中添加一条 undo log，之后可以通过遍历日志实现回滚操作。</p> <p>可重复读隔离级是由 <code>MVCC</code> 实现的，实现的方式是启动事务后，在执行第一个查询语句后，会创建一个 <code>Read View</code>，后续的查询语句利用这个 <code>Read View</code>，通过这个 <code>Read View</code> 就可以在 <code>undo log</code> 版本链找到事务开始时的数据，所以事务过程中每次查询的数据都是一样的，即使中途有其他事务插入了新纪录，是查询不出来这条数据的，所以就很好了避免幻读问题。</p> <p>MySQL 里除了普通查询是快照读，其他都是当前读，比如 update、insert、delete，这些语句执行前都会查询最新版本的数据，然后再做进一步的操作。</p> <p>这很好理解，假设你要 <code>update</code> 一个记录，另一个事务已经 <code>delete</code> 这条记录并且提交事务了，这样不是会产生冲突吗，所以 <code>update</code> 的时候肯定要知道最新的数据。</p> <p><a href=https://cloud.tencent.com/developer/article/2136022>https://cloud.tencent.com/developer/article/2136022</a></p> <h2 id=_14>数据库锁<a class=headerlink href=#_14 title="Permanent link">&para;</a></h2> <p>在 <code>DBMS</code> 中，当并发事务同时访问一个资源时，有可能导致在不同事务内部看到的数据不一致。</p> <p>因此需要一种机制来将数据访问顺序化，以保证数据库数据的一致性。<strong>锁就是其中的一种机制。</strong></p> <p><strong>加锁的目的就是保证共享资源在任意时间里，只有一个线程访问，这样就可以避免多线程导致共享数据错乱的问题。</strong></p> <h3 id=_15>操作系统中的锁<a class=headerlink href=#_15 title="Permanent link">&para;</a></h3> <p>多线程访问共享资源的时候，避免不了资源竞争而导致数据错乱的问题，所以我们通常为了解决这一问题，都会在访问共享资源之前加锁。</p> <p>最底层的两种就是会「互斥锁和自旋锁」，有很多高级的锁都是基于它们实现的，你可以认为它们是各种锁的地基，所以我们必须清楚它俩之间的区别和应用。</p> <p>互斥锁是一种「独占锁」，比如当线程 A 加锁成功后，此时互斥锁已经被线程 A 独占了，只要线程 A 没有释放手中的锁，线程 B 加锁就会失败，于是就会释放 CPU 让给其他线程，既然线程 B 释放掉了 CPU，自然线程 B 加锁的代码就会被阻塞。</p> <p><strong>对于互斥锁加锁失败而阻塞的现象，是由操作系统内核实现的。</strong></p> <p>当加锁失败时，内核会将线程置为「睡眠」状态，等到锁被释放后，内核会在合适的时机唤醒线程，当这个线程成功获取到锁后，于是就可以继续执行。</p> <p>可以简单理解为当某个事务在操作开始时，锁定某一个资源对象（比如某个表，比如某一行），在这个事务操作结束之前，不允许其他事务操作这个对象。</p> <ul> <li> <p>基于锁的属性分类：共享锁、排他锁。</p> </li> <li> <p>基于锁的粒度分类：表锁、行锁、记录锁、间隙锁、临键锁。</p> </li> <li> <p>基于锁的状态分类：意向共享锁、意向排它锁。</p> </li> <li> <p>还有死锁...</p> </li> </ul> <h3 id=_16>乐观锁与悲观锁<a class=headerlink href=#_16 title="Permanent link">&para;</a></h3> <p>乐观锁和悲观锁是两种思想，用于解决并发场景下的数据竞争问题。</p> <h4 id=_17>乐观锁<a class=headerlink href=#_17 title="Permanent link">&para;</a></h4> <p>乐观锁不是数据库自带的，需要我们自己去实现。</p> <p>乐观锁是指操作数据库时(更新操作)想法很乐观，认为这次的操作不会导致冲突。在操作数据时，并不进行任何其他的特殊处理（也就是不加锁），而在进行更新后，再去判断是否有冲突了。</p> <p>通常实现是这样的：在表中的数据进行操作时(更新)，先给数据表加一个版本(version)字段，每操作一次，将那条记录的版本号加 1。也就是先查询出那条记录，获取出 version 字段，如果要对那条记录进行操作(更新)，则先判断此刻 version 的值是否与刚刚查询出来时的 version 的值相等，如果相等，则说明这段期间，没有其他程序对其进行操作，则可以执行更新，将 version 字段的值加 1；如果更新时发现此刻的 version 值与刚刚获取出来的 version 的值不相等，则说明这段期间已经有其他程序对其进行操作了，则不进行更新操作。</p> <p>乐观锁认为一般情况下数据不会造成冲突（所以叫"乐观"），所以在数据进行提交更新时才会对数据的冲突与否进行检测。</p> <p><strong>它本身是种程序设计思想，通过一种标识来决定数据是否可以操作。</strong></p> <h4 id=_18>悲观锁<a class=headerlink href=#_18 title="Permanent link">&para;</a></h4> <p>与乐观锁相对应的就是悲观锁了。悲观锁就是在操作数据时，认为此操作会出现数据冲突，所以在进行每次操作时都要通过获取锁才能进行对相同数据的操作，这点跟 java 中的 synchronized 很相似，所以悲观锁需要耗费较多的时间。另外与乐观锁相对应的，悲观锁是由数据库自己实现了的，要用的时候，我们直接调用数据库的相关语句就可以了。</p> <h3 id=_19>读锁写锁<a class=headerlink href=#_19 title="Permanent link">&para;</a></h3> <p>读锁是共享的，是互相不阻塞的，多个数据库事务在同一时间读取同一资源，互不干扰。（读与读之间不互斥）</p> <p>写锁是排他的，会阻塞其他的写锁和读锁，写锁有更高的优先级。（即我在写资源的时候，其他用户无法读写）</p> <p><strong>一种提高共享资源并发性的方式就是让锁定对象更有选择性。尽量只锁定需要修改的部分数据，而不是所有的资源，锁定的资源越少，系统的并发性更好。</strong></p> <p><strong>任何时候，让锁定的数据量最小化，理论上就能保证在给定资源上同时进行更改操作，只要被修改的数据彼此不冲突即可。</strong></p> <p>锁定策略是锁开销和数据安全性之间的平衡，这种平衡会影响性能。大多数商业数据库系统没有提供太多的选择，一般都是在表中施加行级锁（row level lock）， 为了在锁比较多的情况下尽可能地提供更好的性能，的实现方式非常复杂。 锁是数据库实现一致性保证的方法。数据库操作专家必须深入源代码，才能确定合适的配置， 以优化速度与数据安全之间的平衡。</p> <h2 id=_20>锁的粒度<a class=headerlink href=#_20 title="Permanent link">&para;</a></h2> <p>根据锁定对象的粒度和锁定范围，可以大致分为：</p> <ul> <li> <p>全局锁（整个实例）</p> </li> <li> <p>表锁（table lock）（被锁定的资源的粒度是表）</p> </li> <li> <p>行锁 （row lock）（被锁定资源的粒度是行）</p> </li> </ul> <div class=highlight><pre><span></span><code><span class=c1>-- InnoDB 行级锁是通过给索引上的索引项加锁来实现的，InnoDB行级锁只有通过索引条件检索数据，才使用行级锁;</span>
<span class=c1>-- 否则，InnoDB使用表锁，在不通过索引(主键)条件查询的时候，InnoDB是表锁而不是行锁。</span>

<span class=c1>-- 如果没有使用索引或索引失效，行锁就会变成表锁</span>
<span class=k>SELECT</span><span class=w> </span><span class=n>c1</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>t</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>c1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>10</span><span class=w> </span><span class=k>FOR</span><span class=w> </span><span class=k>UPDATE</span><span class=p>;</span>
</code></pre></div> <p><a href=https://www.jianshu.com/p/1f4940c134b3>https://www.jianshu.com/p/1f4940c134b3</a></p> <h3 id=_21>全局锁<a class=headerlink href=#_21 title="Permanent link">&para;</a></h3> <p>FTWRL 是 FLUSH TABLES WITH READ LOCK 的简称(FTWRL)，该命令主要用于保证备份一致性备份。</p> <div class=highlight><pre><span></span><code><span class=c1>-- 执行后，整个数据库就处于只读状态了，所有写线程都会被阻塞</span>
<span class=n>flush</span><span class=w> </span><span class=n>tables</span><span class=w> </span><span class=k>with</span><span class=w> </span><span class=k>read</span><span class=w> </span><span class=k>lock</span><span class=p>;</span>
</code></pre></div> <p>为了达到这个目的，它需要关闭所有表对象，因此这个命令的杀伤性很大，执行命令时容易导致库 hang 住。</p> <p>如果它在主库执行，则业务无法正常访问；如果在备库，则会导致 SQL 线程卡住，主备延迟。</p> <p>全局锁主要应用于做全库逻辑备份，这样在备份数据库期间，不会因为数据或表结构的更新，而出现备份文件的数据与预期的不一样。</p> <h2 id=_22>共享锁/排它锁<a class=headerlink href=#_22 title="Permanent link">&para;</a></h2> <p>读锁写锁也被称为共享锁和排他锁</p> <p><strong>InnoDB 实现了行级别的共享锁和排它锁。</strong></p> <ul> <li><strong>读锁是共享的，是互相不阻塞的，多个客户端(严格说应该是不同事务)在同一时间读取同一资源，互不干扰。（即我在读资源的时候，其他人只能读不能写）</strong></li> <li><strong>写锁是排他的，会阻塞其他的写锁和读锁，写锁有更高的优先级。（即我在写资源的时候，其他用户无法读写）</strong></li> <li>允许不同事务之间共享加锁读取，但不允许其它事务修改或者加入排他锁。</li> </ul> <p><strong>隐式加锁</strong>：InnoDB，在执行事务过程中会自动加锁，当事务 COMMIT 完成或 ROLLBACK 时锁会自动释放。</p> <p><strong>显式加锁</strong>：</p> <div class=highlight><pre><span></span><code><span class=c1>-- 全局加锁，对整个数据库实例加锁，这个语句通常也叫FTWRL</span>
<span class=c1>-- 整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞</span>
<span class=c1>-- 数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。DDL和DML都会被阻塞</span>
<span class=n>Flush</span><span class=w> </span><span class=n>tables</span><span class=w> </span><span class=k>with</span><span class=w> </span><span class=k>read</span><span class=w> </span><span class=k>lock</span><span class=w> </span><span class=p>;</span>

<span class=c1>-- 全局锁的使用场景：一般是数据库逻辑备份，或某种特殊业务需求要让整个库临时只读。</span>


<span class=c1>-- 对某个对象（一般是行锁）显式加读锁，如果这行对某些行加锁的时候，其他事务还在写入，那么这行select会一直等到其他事务提交才会读到最新的数据。</span>
<span class=k>SELECT</span><span class=w> </span><span class=p>...</span><span class=w> </span><span class=k>FOR</span><span class=w> </span><span class=k>SHARE</span>
<span class=c1>-- 等价于 SELECT...LOCK IN SHARE MODE，后面这种写法可以兼容老版本，FOR SHARE这种写法可以支持更多特性。</span>
<span class=c1>-- 在 MySQL8.0.22之前， SELECT ... FOR SHARE需要SELECT权限外，还需要 DELETE, LOCK TABLES, or UPDATE 三个之一</span>
<span class=c1>-- 在 MySQL8.0.22之后， SELECT ... FOR SHARE只需要select权限</span>



<span class=c1>-- 显式加写锁</span>
<span class=k>SELECT</span><span class=p>...</span><span class=k>FOR</span><span class=w> </span><span class=k>UPDATE</span>

<span class=c1>-- 显示加读锁或写锁</span>
<span class=c1>-- 如果在某个线程A中执行lock tables t1 read, t2 write; 这个语句，</span>
<span class=c1>-- 那么其他线程写t1、读写t2的语句都会被阻塞。同时，线程A在执行unlock tables之前，也只能执行读t1、读写t2的操作。连写t1都不允许，自然也不能访问其他表。</span>
<span class=k>lock</span><span class=w> </span><span class=n>tables</span><span class=w> </span><span class=err>…</span><span class=w> </span><span class=k>read</span><span class=o>/</span><span class=k>write</span>
<span class=c1>-- 释放锁 unlock tables</span>
</code></pre></div> <h3 id=_23>读锁<a class=headerlink href=#_23 title="Permanent link">&para;</a></h3> <div class=highlight><pre><span></span><code><span class=c1>-- 注意：这里都是显示开启事务，故意执行事务不提交。</span>
<span class=c1>-- session1</span>
<span class=k>start</span><span class=w> </span><span class=k>transaction</span><span class=p>;</span>
<span class=k>select</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=n>test</span><span class=w> </span><span class=k>where</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=k>lock</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=k>share</span><span class=w> </span><span class=k>mode</span><span class=p>;</span>
<span class=c1>-- 在session1线程里面，它自己也无法获得写锁</span>
<span class=k>update</span><span class=w> </span><span class=n>emp</span><span class=w> </span><span class=k>set</span><span class=w> </span><span class=n>ename</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s1>&#39;ALLEN1111&#39;</span><span class=w> </span><span class=k>where</span><span class=w> </span><span class=n>ename</span><span class=o>=</span><span class=s1>&#39;ALLEN&#39;</span><span class=w> </span><span class=p>;</span>

<span class=c1>-- session2</span>
<span class=k>start</span><span class=w> </span><span class=k>transaction</span><span class=p>;</span>
<span class=k>select</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=n>test</span><span class=w> </span><span class=k>where</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=k>lock</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=k>share</span><span class=w> </span><span class=k>mode</span><span class=p>;</span>

<span class=c1>-- 此时 session1 和 session2 都可以正常获取结果，那么再加入 session3 排他锁读取尝试</span>

<span class=c1>-- session3:</span>
<span class=k>start</span><span class=w> </span><span class=k>transaction</span><span class=p>;</span>
<span class=c1>-- session3的SQL可以换成任意的写语句（update,insert,delete,alter效果都是一样）</span>
<span class=k>select</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=n>test</span><span class=w> </span><span class=k>where</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=k>update</span><span class=p>;</span>
<span class=c1>-- Lock wait timeout exceeded; try restarting transaction -- 在 session3 中则无法获取数据，直到超时或其它事物 commit</span>



<span class=c1>-- 通过 information_schema.INNODB_TRX 表里的 trx_mysql_thread_id 可以找到锁表的线程ID</span>
<span class=c1>-- 再回 information_schema.`PROCESSLIST` 表里面去查，就可以找到相应的连接。</span>
<span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>information_schema</span><span class=p>.</span><span class=n>INNODB_TRX</span>
</code></pre></div> <h3 id=_24>写锁<a class=headerlink href=#_24 title="Permanent link">&para;</a></h3> <p>当一个事务加入排他锁后，不允许其他事务加共享锁或者排它锁读取，更加不允许其他事务修改加锁的行。</p> <div class=highlight><pre><span></span><code><span class=c1>-- session1:</span>
<span class=c1>-- session对资源添加写锁</span>
<span class=k>start</span><span class=w> </span><span class=k>transaction</span><span class=p>;</span>
<span class=k>select</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=n>test</span><span class=w> </span><span class=k>where</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=k>update</span><span class=p>;</span>

<span class=c1>-- session2(session2对test的增删改查任何访问都会被阻塞)</span>
<span class=c1>-- 如果session1的事务一直不提交或回滚，那么session2超时</span>
<span class=k>start</span><span class=w> </span><span class=k>transaction</span><span class=p>;</span>
<span class=k>select</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=n>test</span><span class=w> </span><span class=k>where</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=k>update</span><span class=p>;</span>
</code></pre></div> <h3 id=_25>锁的释放<a class=headerlink href=#_25 title="Permanent link">&para;</a></h3> <p>MySQL 中释放锁的动作都是隐式的，对于锁的释放工作，MySQL 自己来干，就类似于 JVM 中的 GC 机制一样，把内存释放的工作留给了自己完成。</p> <p>对于锁的释放时机，在不同的隔离级别中也并不相同，比如在“读未提交”级别中，是 SQL 执行完成后就立马释放锁；而在“可重复读”级别中，是在事务结束后才会释放。</p> <p>如果完全按照数据库规范来实现 RC 隔离级别，为了保证其他事务可以读到未提交的数据，那就必须得在 SQL 执行完成后，立马释放掉锁，这时另一个事务才能读到 SQL 对应写的数据，但在 InnoDB 引擎中，它基于 MVCC 机制实现了该效果，为此，InnoDB 的 RC 级别中，SQL 执行结束后并不会释放锁。</p> <h3 id=_26><strong>意向锁</strong><a class=headerlink href=#_26 title="Permanent link">&para;</a></h3> <p>MySQL 支持多种粒度的锁（表锁，行锁）。它允许<code>行级锁</code>与<code>表级锁</code>共存，为了实现多粒度级别的锁定，InnoDB 使用了**意向锁**，它其实就是其中的一种<code>表锁</code>。</p> <p>假设一张表中有一千万条数据，现在事务 T1 对 ID=8888888 的这条数据加了一个行锁，此时来了一个事务 T2，想要获取这张表的表级别写锁。</p> <p>写锁必须为排他锁，也就是在同一时刻内，只允许当前事务操作，如果表中存在其他事务已经获取了锁，目前事务就无法满足“独占性”，因此不能获取锁。</p> <div class=highlight><pre><span></span><code><span class=c1>-- 表级别的锁</span>

<span class=c1>-- 用读锁锁表，会阻塞其他事务修改表数据。</span>
<span class=k>LOCK</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>my_tabl_name</span><span class=w> </span><span class=k>READ</span><span class=p>;</span>
<span class=c1>-- 用写锁锁表，会阻塞其他事务读和写。</span>
<span class=k>LOCK</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>my_table_name</span><span class=w> </span><span class=k>WRITE</span><span class=p>;</span>


<span class=c1>-- 行级别的锁（查询走索引）</span>

<span class=c1>-- 读锁</span>
<span class=k>SELECT</span><span class=w> </span><span class=p>...</span><span class=w> </span><span class=k>FOR</span><span class=w> </span><span class=k>SHARE</span>
<span class=c1>-- 写锁</span>
<span class=k>SELECT</span><span class=w> </span><span class=p>...</span><span class=w> </span><span class=k>FOR</span><span class=w> </span><span class=k>UPDATE</span>


<span class=c1>-- 考虑这样的一个例子：</span>

<span class=c1>-- 事务A锁住了表中的一行，让这一行只能读，不能写。（对某行加读锁）</span>

<span class=c1>-- 事务B申请整个表的写锁。（如果事务B申请成功，那么理论上它就能修改表中的任意一行，这与A持有的行锁是冲突的。）</span>

<span class=c1>-- 数据库需要避免这种冲突，就是说要让B的申请被阻塞，直到A释放了行锁。</span>

<span class=c1>-- 数据库内部要怎么判断这个冲突呢？（即B事务准备对全表加写锁之前的检测）</span>

<span class=c1>-- step1：判断表是否已被其他事务用表锁锁表。</span>
<span class=c1>-- step2：遍历表中的每一行是否已被行锁锁住。（由于这样的效率很低，需要遍历整个表。）</span>

<span class=c1>-- 于是意向锁出现了，在意向锁存在的情况下，事务A必须先申请表的意向共享锁，成功后再申请一行的行锁。</span>

<span class=c1>-- 在意向锁存在的情况下，上面的判断可以改成</span>

<span class=c1>-- step1：不变</span>
<span class=c1>-- step2：发现表上有意向共享锁，说明表中有些行被共享行锁锁住了，因此，事务B申请表的写锁会被阻塞。</span>


<span class=c1>-- 所以准确来讲，SELECT ... FOR SHARE 持有的是 IS lock（意向读锁）</span>
<span class=c1>-- 所以准确来讲，SELECT ... FOR UPDATE 持有的是 IX lock（意向写锁）</span>

<span class=c1>-- 意向锁实现的背景是多粒度锁的并存场景。</span>

<span class=c1>-- 注意：申请意向锁的动作是数据库内部完成的，就是说，事务A申请一行的行锁的时候，数据库内部会自动先开始申请表的意向锁，不需要我们自己实现。</span>
<span class=c1>-- 意向锁是表级锁的一种，它是由数据库引擎自行维护的，用户自己无需也无法操作意向锁。</span>
</code></pre></div> <h2 id=_27>间隙锁<a class=headerlink href=#_27 title="Permanent link">&para;</a></h2> <p><strong><mark>间隙锁（Gap Lock）</mark>**是 InnoDB 存储引擎为了实现</strong><mark>可重复读隔离级别</mark>**而引入的一种锁机制。</p> <p><mark><strong>它锁住的是索引记录之间的间隙（而不是索引记录本身），防止其他事务在这个间隙中插入新的数据。</strong></mark></p> <p>为什么需要间隙锁？</p> <p>防止幻读: 幻读是指在一个事务中，两次读取同一条数据，却得到了不同的结果。间隙锁通过锁定索引记录之间的间隙，防止其他事务在该间隙中插入新的数据，从而避免幻读的发生。</p> <p>间隙锁的特性</p> <ul> <li>锁定范围: 间隙锁锁定的是索引记录之间的间隙，而不是索引记录本身。</li> <li>锁类型: 间隙锁是排它锁，其他事务不能在锁定的间隙中插入新的数据。</li> <li>触发条件: 当事务执行范围查询时，InnoDB 会自动为符合条件的索引记录之间的间隙加上间隙锁。</li> <li>锁的释放: 事务提交或回滚时，间隙锁会自动释放。</li> </ul> <h3 id=_28><strong>锁定区间</strong><a class=headerlink href=#_28 title="Permanent link">&para;</a></h3> <p>间隙锁会向左找第一个比当前索引值小的值，向右找第一个比当前索引值大的值（没有则为正无穷），将此区间锁住，从而阻止其他事务在此区间插入数据</p> <p>间隙锁（Gap Lock），左右都是开区间，间隙锁 + 行锁组合成 Next-key lock，左开右闭区间。</p> <h3 id=_29>加锁规则<a class=headerlink href=#_29 title="Permanent link">&para;</a></h3> <ul> <li>加锁的基本单位是 <code>next-key lock</code>，它是左开右闭区间</li> <li>查找过程中访问到的对象才会加锁</li> <li><strong><mark>唯一索引上的等值查询</mark></strong>，并且记录存在，<code>next-key lock</code> 退化为行锁</li> <li>唯一索引上的范围查询会访问到不满足条件的第一个值为止</li> <li>索引上的等值查询，将距离最近的左边界和右边界作为锁定范围</li> </ul> <p><mark><strong>如果把事务的隔离级别降级为读已提交(Read Committed, RC)，对，就是互联网行业最常用的隔离级别，间隙锁则会自动失效。</strong></mark></p> <h3 id=_30>实战<a class=headerlink href=#_30 title="Permanent link">&para;</a></h3> <div class=highlight><pre><span></span><code><span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>t</span><span class=w> </span><span class=p>(</span>
<span class=w>   </span><span class=n>id</span><span class=w> </span><span class=nb>int</span><span class=p>(</span><span class=mi>11</span><span class=p>)</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=p>,</span>
<span class=w>   </span><span class=k>c</span><span class=w> </span><span class=nb>int</span><span class=p>(</span><span class=mi>11</span><span class=p>)</span><span class=w> </span><span class=k>DEFAULT</span><span class=w> </span><span class=k>NULL</span><span class=p>,</span>
<span class=w>   </span><span class=n>d</span><span class=w> </span><span class=nb>int</span><span class=p>(</span><span class=mi>11</span><span class=p>)</span><span class=w> </span><span class=k>DEFAULT</span><span class=w> </span><span class=k>NULL</span><span class=p>,</span>
<span class=w>   </span><span class=k>PRIMARY</span><span class=w> </span><span class=k>KEY</span><span class=w> </span><span class=p>(</span><span class=n>id</span><span class=p>),</span>
<span class=w>   </span><span class=k>KEY</span><span class=w> </span><span class=k>c</span><span class=w> </span><span class=p>(</span><span class=k>c</span><span class=p>)</span>
<span class=w> </span><span class=p>)</span><span class=w> </span><span class=n>ENGINE</span><span class=o>=</span><span class=n>InnoDB</span><span class=p>;</span>

<span class=w> </span><span class=k>INSERT</span><span class=w> </span><span class=k>INTO</span><span class=w> </span><span class=n>t</span><span class=w> </span><span class=k>VALUES</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span><span class=mi>0</span><span class=p>,</span><span class=mi>0</span><span class=p>),(</span><span class=mi>5</span><span class=p>,</span><span class=mi>5</span><span class=p>,</span><span class=mi>5</span><span class=p>),(</span><span class=mi>10</span><span class=p>,</span><span class=mi>10</span><span class=p>,</span><span class=mi>10</span><span class=p>),(</span><span class=mi>15</span><span class=p>,</span><span class=mi>15</span><span class=p>,</span><span class=mi>15</span><span class=p>),(</span><span class=mi>20</span><span class=p>,</span><span class=mi>20</span><span class=p>,</span><span class=mi>20</span><span class=p>);</span>
</code></pre></div> <p>辅助索引c也是非唯一索引，其 <code>Next-Key Lock</code> 逻辑稍复杂，因为它除了锁 <code>c</code> 的值，还要隐式包含主键值来定位。</p> <table> <thead> <tr> <th><strong>索引记录 (c, id)</strong></th> <th><strong>对应的 Next-Key Lock 区间</strong></th> <th><strong>实际拦截的插入范围示例</strong></th> </tr> </thead> <tbody> <tr> <td><strong>(0, 0)</strong></td> <td><span class=arithmatex><span class=MathJax_Preview>(-\infty, (0, 0)]</span><script type=math/tex>(-\infty, (0, 0)]</script></span></td> <td>插入 <code>c &lt; 0</code> 的数据会被拦截</td> </tr> <tr> <td><strong>(5, 5)</strong></td> <td><span class=arithmatex><span class=MathJax_Preview>((0, 0), (5, 5)]</span><script type=math/tex>((0, 0), (5, 5)]</script></span></td> <td>插入 <code>c=3</code> 或 <code>(c=5, id=2)</code> 会被拦截</td> </tr> <tr> <td><strong>(10, 10)</strong></td> <td><span class=arithmatex><span class=MathJax_Preview>((5, 5), (10, 10)]</span><script type=math/tex>((5, 5), (10, 10)]</script></span></td> <td>插入 <code>c=7</code> 或 <code>(c=10, id=8)</code> 会被拦截</td> </tr> <tr> <td><strong>(15, 15)</strong></td> <td><span class=arithmatex><span class=MathJax_Preview>((10, 10), (15, 15)]</span><script type=math/tex>((10, 10), (15, 15)]</script></span></td> <td>插入 <code>c=12</code> 会被拦截</td> </tr> <tr> <td><strong>(20, 20)</strong></td> <td><span class=arithmatex><span class=MathJax_Preview>((15, 15), (20, 20)]</span><script type=math/tex>((15, 15), (20, 20)]</script></span></td> <td>插入 <code>c=18</code> 会被拦截</td> </tr> <tr> <td><strong>supremum</strong></td> <td><span class=arithmatex><span class=MathJax_Preview>((20, 20), +\infty)</span><script type=math/tex>((20, 20), +\infty)</script></span></td> <td>插入 <code>c &gt; 20</code> 的数据会被拦截</td> </tr> </tbody> </table> <p><strong>唯一索引等值锁定存在的数据</strong></p> <table> <thead> <tr> <th>时刻</th> <th>事务 1</th> <th>事务 2</th> </tr> </thead> <tbody> <tr> <td>t1</td> <td>BEGIN; <br>SELECT * FROM t WHERE id = 5 FOR UPDATE;</td> <td></td> </tr> <tr> <td>t2</td> <td></td> <td>BEGIN; <br>INSERT INTO t VALUE(4,4,4); --- success</td> </tr> <tr> <td></td> <td></td> <td>INSERT INTO t VALUE(6,6,6); --- success</td> </tr> </tbody> </table> <p>事务 1 中执行的 <code>SELECT</code> 语句，会退化成行锁，只会锁定 5 这一行记录</p> <p><strong>索引等值锁定</strong></p> <table> <thead> <tr> <th>时刻</th> <th>事务 1</th> <th>事务 2</th> </tr> </thead> <tbody> <tr> <td>t1</td> <td>BEGIN; <br>SELECT * FROM t WHERE id = 3 FOR UPDATE; --- 不存在的数据</td> <td></td> </tr> <tr> <td>t2</td> <td></td> <td>BEGIN; <br>INSERT INTO t VALUE(6,6,6); --- success</td> </tr> <tr> <td>t3</td> <td></td> <td>INSERT INTO t VALUE(4,4,4); --- block</td> </tr> </tbody> </table> <p>加锁范围是（0,5]，由于向右遍历最后一个值 5 不满足等值条件，退化为间隙锁(0,5)</p> <p>插入 数据6 不在间隙锁的范围内可以插入成功，而数据 4 是间隙锁锁定范围进入阻塞状态</p> <p><strong>唯一索引范围锁定</strong></p> <table> <thead> <tr> <th>时刻</th> <th>事务 1</th> <th>事务 2</th> </tr> </thead> <tbody> <tr> <td>t1</td> <td>begin; <br>select * from t where id &gt;= 5 and id &lt; 6 for update;</td> <td></td> </tr> <tr> <td>t2</td> <td></td> <td>begin; <br>insert into t value(7,7,7); --- block</td> </tr> </tbody> </table> <h2 id=_31>临键锁<a class=headerlink href=#_31 title="Permanent link">&para;</a></h2> <p><code>Next-Key Lock</code> 称为临键锁，是 <code>Record Lock</code> + <code>Gap Lock</code> 的组合，锁定一个范围，并且锁定记录本身。 </p> <ul> <li> <p>锁定对象：它不仅锁住索引记录本身（Record Lock），还锁住这些记录之间的间隙（Gap Lock）</p> </li> <li> <p><strong>触发前提</strong>：InnoDB 所有的行锁本质上都是**索引记录锁**。当 InnoDB 扫描索引时，它会给遇到的索引记录加锁。</p> </li> </ul> <p>当索引记录中存在 <strong>10, 11, 13, 20</strong> 这四个值时，InnoDB 实际上将整个索引空间划分为 5 个不同的“势力范围”。</p> <table> <thead> <tr> <th><strong>索引记录</strong></th> <th><strong>Next-Key Lock 区间</strong></th> <th><strong>含义</strong></th> </tr> </thead> <tbody> <tr> <td><strong>10</strong></td> <td><span class=arithmatex><span class=MathJax_Preview>(-\infty, 10]</span><script type=math/tex>(-\infty, 10]</script></span></td> <td>锁住 10 本身，以及 10 之前的所有空隙。</td> </tr> <tr> <td><strong>11</strong></td> <td><span class=arithmatex><span class=MathJax_Preview>(10, 11]</span><script type=math/tex>(10, 11]</script></span></td> <td>锁住 11 本身，以及 10 到 11 之间的空隙。</td> </tr> <tr> <td><strong>13</strong></td> <td><span class=arithmatex><span class=MathJax_Preview>(11, 13]</span><script type=math/tex>(11, 13]</script></span></td> <td>锁住 13 本身，以及 11 到 13 之间的空隙。</td> </tr> <tr> <td><strong>20</strong></td> <td><span class=arithmatex><span class=MathJax_Preview>(13, 20]</span><script type=math/tex>(13, 20]</script></span></td> <td>锁住 20 本身，以及 13 到 20 之间的空隙。</td> </tr> <tr> <td><strong>Supremum</strong></td> <td><span class=arithmatex><span class=MathJax_Preview>(20, +\infty)</span><script type=math/tex>(20, +\infty)</script></span></td> <td><strong>特殊情况</strong>：锁住 20 之后到正无穷的所有空间。</td> </tr> </tbody> </table> <p>假设你在 <strong>Transaction A</strong> 中执行以下不同的查询（RR 级别）：</p> <p><strong>场景 1：精准查询不存在的值</strong></p> <ul> <li><strong>SQL</strong>: <code>SELECT * FROM t WHERE id = 12 FOR UPDATE;</code></li> <li><strong>命中范围</strong>: 12 落在区间 <span class=arithmatex><span class=MathJax_Preview>(11, 13)</span><script type=math/tex>(11, 13)</script></span> 之间。</li> <li><strong>加锁结果</strong>: InnoDB 会在记录 13 上加一个 <strong>Gap Lock</strong>，锁定范围是 <strong><span class=arithmatex><span class=MathJax_Preview>(11, 13)</span><script type=math/tex>(11, 13)</script></span></strong>。</li> <li><strong>影响</strong>: 此时你无法插入 <code>id=12</code>，但别人可以修改 <code>id=11</code> 或 <code>id=13</code>（因为 Gap Lock 不锁记录本身）。</li> </ul> <p><strong>场景 2：范围查询</strong></p> <ul> <li><strong>SQL</strong>: <code>SELECT * FROM t WHERE id &gt; 12 AND id &lt; 15 FOR UPDATE;</code></li> <li><strong>命中范围</strong>: 这个范围扫描到了记录 13 和记录 20。</li> <li><strong>加锁结果</strong>:</li> <li>对记录 13 加 <strong>Next-Key Lock</strong>，范围：<span class=arithmatex><span class=MathJax_Preview>(11, 13]</span><script type=math/tex>(11, 13]</script></span>。</li> <li>对记录 20 加 <strong>Next-Key Lock</strong>，范围：<span class=arithmatex><span class=MathJax_Preview>(13, 20]</span><script type=math/tex>(13, 20]</script></span>。</li> <li><strong>最终封锁</strong>: 整个 <strong><span class=arithmatex><span class=MathJax_Preview>(11, 20]</span><script type=math/tex>(11, 20]</script></span></strong> 区域被锁死。</li> </ul> <p><strong>场景 3：锁住“未来”的结尾</strong></p> <ul> <li><strong>SQL</strong>: <code>SELECT * FROM t WHERE id &gt; 25 FOR UPDATE;</code></li> <li><strong>命中范围</strong>: 25 大于最大值 20。</li> <li><strong>加锁结果</strong>: InnoDB 会找到 <code>supremum</code> 记录并加锁。</li> <li><strong>封锁区间</strong>: <strong><span class=arithmatex><span class=MathJax_Preview>(20, +\infty)</span><script type=math/tex>(20, +\infty)</script></span></strong>。</li> <li><strong>影响</strong>: 在事务提交前，任何 <code>id &gt; 20</code> 的插入操作都会被挂起。</li> </ul> <h2 id=mdl>MDL 锁<a class=headerlink href=#mdl title="Permanent link">&para;</a></h2> <p>在 MySQL 使用过程中，不免有对表进行更改的<code>DDL</code>操作(alter/drop table)。</p> <p>有的时候我们会发现，一条简单的对表增加字段的操作，会执行很长时间，严重时甚至导致整个数据库挂掉。</p> <p>在出现问题时查看 show processlist 的时候，可以看到简单的所谓的<code>Waiting for table metadata lock</code>之类的状态，有些情况很难排查。</p> <p>元数据锁是 server 层的表级锁。主要用于隔离 DML 和 DDL 操作之间的干扰。MDL 锁不仅仅是作用在 table 上，也作用在 schemas/</p> <p>每执行一条 DML、DDL 语句时都会申请 MDL 锁，DML 操作需要 MDL 读锁，DDL 操作需要 MDL 写锁（MDL 加锁过程是系统自动控制，无法直接干预，读读共享，读写互斥，写写互斥）</p> <p>申请 MDL 锁的操作会形成一个队列，队列中写锁获取优先级高于读锁。一旦出现写锁等待，不但当前操作会被阻塞，同时还会阻塞后续该表的所有操作。事务一旦申请到 MDL 锁后，直到事务执行完才会将锁释放。</p> <p>其实 MDL Lock 是 MySQL 上层一个非常复杂的子系统，有自己的死锁检测机制。</p> <p>考虑如下两个 session:</p> <table> <thead> <tr> <th style="text-align: center;">session1</th> <th style="text-align: center;">session2</th> </tr> </thead> <tbody> <tr> <td style="text-align: center;">BEGIN</td> <td style="text-align: center;"></td> </tr> <tr> <td style="text-align: center;">SELECT * FROM XXX;</td> <td style="text-align: center;"></td> </tr> <tr> <td style="text-align: center;">sleep(60);</td> <td style="text-align: center;"></td> </tr> <tr> <td style="text-align: center;"></td> <td style="text-align: center;">DROP TABLE XXX</td> </tr> <tr> <td style="text-align: center;">SELECT * FROM XXX</td> <td style="text-align: center;"></td> </tr> </tbody> </table> <ul> <li>session1 显示开启事务，两次查询间隔<code>60</code>秒。</li> <li>session2 在这两次查询之间执行删表语句。</li> </ul> <p>如果 DROP TABLE 成功执行了，那会话 1 的第二个 select 会出错，这明显不是我们想要的结果。</p> <p>所以为了避免此类问题，MySQL5.5 版本加入了 MDL(Metadata Lock)：</p> <ul> <li><strong>当对一个表做 CRUD 操作的时候，加 MDL 读锁（MDL_SHARED_READ）；</strong></li> <li> <p><strong>当要对表做结构变更操作（DDL）（alter, drop）的时候，加 MDL 写锁（MDL_EXCLUSIVE）。</strong></p> </li> <li> <p><strong>读锁之间不互斥，因此可以有多个线程同时对一张表增删改查。</strong></p> </li> <li><strong>读写锁之间、写锁之间互斥，用来保证变更结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。</strong></li> </ul> <p>在这个例子中，<code>show processlist</code> 可以看到， session2 的 DROP 语句一直在等待 <code>Waiting for table metadata lock</code></p> <h4 id=_32>踩坑实战一<a class=headerlink href=#_32 title="Permanent link">&para;</a></h4> <table> <thead> <tr> <th style="text-align: center;">session1</th> <th style="text-align: center;">session2</th> <th style="text-align: center;">session3</th> <th style="text-align: center;">session4</th> </tr> </thead> <tbody> <tr> <td style="text-align: center;">begin</td> <td style="text-align: center;"></td> <td style="text-align: center;"></td> <td style="text-align: center;"></td> </tr> <tr> <td style="text-align: center;">select * from user limit 1</td> <td style="text-align: center;"></td> <td style="text-align: center;"></td> <td style="text-align: center;"></td> </tr> <tr> <td style="text-align: center;"></td> <td style="text-align: center;">select * from user limit 1</td> <td style="text-align: center;"></td> <td style="text-align: center;"></td> </tr> <tr> <td style="text-align: center;"></td> <td style="text-align: center;"></td> <td style="text-align: center;">alter table user add address varchar(32)</td> <td style="text-align: center;"></td> </tr> <tr> <td style="text-align: center;"></td> <td style="text-align: center;"></td> <td style="text-align: center;"></td> <td style="text-align: center;">select * from user limit 1</td> </tr> </tbody> </table> <ul> <li>session1 执行 select ，持有 MDL 读锁（由于显示开启事务，事务并未结束，所以一直持有 MDL 读锁）。</li> <li>session2 执行 select，也要持有 MDL 读锁，由于 MDL 读锁不互斥，所以也可以拿到，正常执行事务完成，释放 MDL 读锁</li> <li>session3 要持有 MDL 写锁，由于 session1 的 MDL 读锁并未释放，所以 session3 被阻塞，状态是<code>Waiting for table metadata lock</code></li> <li> <p>session4 也会被阻塞（如果有 MDL 写锁被阻塞，后续对这个表的所有请求都会被阻塞）</p> </li> <li> <p><strong>原因剖析：应该是 MySQL 内部维护了一个 MDL 队列，避免 MDL 写锁一直请求不到。</strong></p> </li> <li><strong>（如果没有先来后到的话，后面的读写请求不停的过来进行查询，这个 DDL 会一直被阻塞）</strong></li> <li><strong>问题注意：如果某个表上的查询语句频繁，而且客户端有重试机制，也就是说超时后会再起一个新 session 再请求的话，这个库的线程很快就会爆满。</strong></li> </ul> <p>申请 MDL 锁的操作会形成一个队列，队列中写锁获取优先级高于读锁。一旦出现写锁等待，不但当前操作会被阻塞，同时还会阻塞后续该表的所有操作。事务一旦申请到 MDL 锁后，直到事务执行完才会将锁释放。</p> <p>（这里有种特殊情况如果事务中包含 DDL 操作，mysql 会在 DDL 操作语句执行前，隐式提交 commit，以保证该 DDL 语句操作作为一个单独的事务存在，同时也保证元数据排他锁的释放，例如 id 44 的语句改为<begin;alter table testok add z varchar(10) not null;select \* from testok;>，此时一旦 alter 语句执行完成会马上提交事务（autocommit=1），后面的 select 就在本次事务之外，其执行完成后不会持有读锁）</p> <h5 id=_33>排查思路<a class=headerlink href=#_33 title="Permanent link">&para;</a></h5> <p>对于这种情况，排查思路就是最简单的查看关于这个表上操作的所有进程和事务；</p> <div class=highlight><pre><span></span><code><span class=c1>-- 查事务</span>
<span class=k>select</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=n>information_schema</span><span class=p>.</span><span class=n>innodb_trx</span><span class=w>  </span><span class=k>where</span><span class=w> </span><span class=n>trx_query</span><span class=w> </span><span class=k>like</span><span class=w> </span><span class=s1>&#39;%table_name%&#39;</span><span class=p>;</span>

<span class=c1>-- 查进程</span>
<span class=k>select</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=n>information_schema</span><span class=p>.</span><span class=n>PROCESSLIST</span><span class=w> </span><span class=k>where</span><span class=w> </span><span class=n>info</span><span class=w> </span><span class=k>like</span><span class=w> </span><span class=s1>&#39;%table_name%&#39;</span><span class=p>;</span>
</code></pre></div> <h4 id=_34>踩坑实战二<a class=headerlink href=#_34 title="Permanent link">&para;</a></h4> <p>我们知道，如果一个事务没有提交，会阻塞后面的 DDL 操作。</p> <p>那么，是不是我们执行 <code>select * from information_schema.innodb_trx</code> 查询不到正在执行的事务，就不会出现 MDL 阻塞的情况了呢?</p> <p>显然不是。来看一个例子（查询一个不存在的列）：</p> <table> <thead> <tr> <th style="text-align: center;">session1</th> <th style="text-align: center;">session2</th> </tr> </thead> <tbody> <tr> <td style="text-align: center;">begin;</td> <td style="text-align: center;"></td> </tr> <tr> <td style="text-align: center;">select unknown from user;</td> <td style="text-align: center;"></td> </tr> <tr> <td style="text-align: center;"></td> <td style="text-align: center;">alter table user add column address varchar(20)</td> </tr> </tbody> </table> <p>我们发现，session2 阻塞，等待获取 MDL 写锁。查看正在运行的事务，发现并没有事务在运行。</p> <div class=highlight><pre><span></span><code><span class=n>mysql</span><span class=o>&gt;</span><span class=w> </span><span class=n>mysql</span><span class=o>&gt;</span><span class=w> </span><span class=k>select</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=n>information_schema</span><span class=p>.</span><span class=n>innodb_trx</span><span class=err>\</span><span class=k>G</span><span class=p>;</span>
<span class=n>Empty</span><span class=w> </span><span class=k>set</span><span class=w> </span><span class=p>(</span><span class=mi>0</span><span class=p>.</span><span class=mi>00</span><span class=w> </span><span class=n>sec</span><span class=p>)</span>
</code></pre></div> <p><strong>因为<code>information_schema.innodb_trx</code>中不会记录执行失败的事务(查询不存在的列，语句未提交等)，但是在这个执行失败的事务回滚前，这个事务它依然持有 MDL，所以 DDL 操作依然会被阻塞。</strong></p> <h5 id=_35>排查思路<a class=headerlink href=#_35 title="Permanent link">&para;</a></h5> <p>这个时候我们可以通过查找<code>performance_schema.events_statements_current</code>表来找到相关的语句和会话信息，然后 kill 掉</p> <div class=highlight><pre><span></span><code><span class=c1>-- 使用 sys.schema_table_lock_waits 排查的时候一定要注意认真看</span>
<span class=k>select</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=n>sys</span><span class=p>.</span><span class=n>schema_table_lock_waits</span><span class=w> </span><span class=p>;</span>

<span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>PERFORMANCE_SCHEMA</span><span class=p>.</span><span class=n>events_statements_current</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>SQL_TEXT</span><span class=w> </span><span class=k>LIKE</span><span class=w> </span><span class=s1>&#39;%dim_admin_area%&#39;</span><span class=w> </span><span class=p>;</span>



<span class=k>SELECT</span>
<span class=w>    </span><span class=o>*</span>
<span class=k>FROM</span>
<span class=w>    </span><span class=n>information_schema</span><span class=p>.</span><span class=o>`</span><span class=n>PROCESSLIST</span><span class=o>`</span>
<span class=k>WHERE</span>
<span class=w>    </span><span class=n>id</span><span class=w> </span><span class=k>IN</span><span class=w> </span><span class=p>(</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=n>PROCESSLIST_id</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>PERFORMANCE_SCHEMA</span><span class=p>.</span><span class=n>threads</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>thread_id</span><span class=w> </span><span class=k>IN</span><span class=w> </span><span class=p>(</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=n>thread_id</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>PERFORMANCE_SCHEMA</span><span class=p>.</span><span class=n>events_statements_current</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>SQL_TEXT</span><span class=w> </span><span class=k>LIKE</span><span class=w> </span><span class=s1>&#39;%dim_admin_area%&#39;</span><span class=w> </span><span class=p>)</span><span class=w> </span><span class=p>)</span>
</code></pre></div> <details class=note> <summary>总结</summary> </details> <p>MySQL 在进行一些 alter table 等 DDL 操作时，如果该表上有未提交的事务（无论正常事务还是失败事务）都会出现 Waiting for table metadata lock ，而一旦出现 metadata lock，该表上的后续操作都会被阻塞。</p> <h3 id=online-ddl>Online DDL<a class=headerlink href=#online-ddl title="Permanent link">&para;</a></h3> <p><strong>在 MySQL 使用过程中，根据业务的需求对表结构进行变更是个普遍的运维操作，这些称为 DDL 操作。常见的 DDL 操作有在表上增加新列，或给某个列添加索引。</strong></p> <p>给一个表加字段，或者修改字段，或者加索引，都需要扫描全表的数据。对大表操作的时候，你肯定会特别小心，以免对线上服务造成影响。因为大表 DDL 往往会耗时很久。</p> <p>从前面的描述可以得到一个结论：<strong>事务中的 MDL 锁，在语句执行开始时申请，但是语句结束后并不会马上释放，而会等到整个事务提交后再释放。</strong></p> <p><strong>如何安全的给一个表进行 DDL 呢？</strong></p> <p>首先要解决的是长事务：事务不提交，就会一直占着 MDL 锁。在 information_schema.innodb_trx 中，可以查到当前执行中的事务。</p> <p>如果你要做 DDL 变更的表刚好有长事务在执行，要考虑先暂停 DDL，或者 kill 掉这个长事务。</p> <p>在 MySQL 5.6 之前，MySQL 的 DDL 操作会按照原来的表复制一份，并做相应的修改。</p> <p>例如，对表 A 进行 DDL 的内部实现具体过程如下：</p> <ul> <li>按照表 A 的定义新建一个表 B</li> <li>对表 A 加写锁</li> <li>在表 B 上执行 DDL 指定的操作</li> <li>将 A 中的数据拷贝到 B</li> <li>释放 A 的写锁</li> <li>删除表 A</li> <li>将表 B 重命名为 A</li> </ul> <p>在 2-4 的过程中，如果表 A 数据量比较大，拷贝到表 B 的过程会消耗大量时间，并占用额外的存储空间。</p> <p>此外，由于 DDL 操作占用了表 A 的写锁，所以表 A 上的 DDL 和 DML 都将阻塞无法提供服务。</p> <p>MySQL 5.6 版本引入了 <strong>Online DDL 特性</strong>。</p> <p>在 MySQL 5.6 之前，执行 DDL 的唯一方法是逐行复制行。INPLACE DDL 主要由 InnoDB 处理，而逐行 COPY 在服务器层处理。</p> <p>这种情况，往往需要对整个表加锁，这会导致长时间的阻塞，影响业务的正常运行。</p> <p>在 MySQL 5.7，Online DDL 在性能和稳定性上不断得到优化，比如通过 bulk load 方式来去除表重建时的 redo 日志等。</p> <p>到了 MySQL 8.0，Online DDL 已经支持秒级加列特性，该特性来源于国内的腾讯互娱 DBA 团队。</p> <p>查阅官方文档得知，快速加列即 Instant Add Column ，该功能自 MySQL 8.0.12 版本引入，是由腾讯游戏 DBA 团队贡献。注意一下，此功能只适用于 InnoDB 表。</p> <p><strong>基本上，在 MySQL8.0 上，不需要再用 pt-osc 和 gh-ost 等工具，大多数情况都可以直接 online DDL 了。</strong></p> <p>概括来说，在 MySQL 8.0 上，Online DDL 有 2 种划分维度（其实就是两种参数）：</p> <ul> <li>一是 DDL 期间运行的并发程度</li> <li>二是 DDL 的执行算法</li> </ul> <p>先说 DDL 时的**业务 DML 操作运行程度**（Permits Concurrent DML），可以通过 LOCK 关键字来指定 DDL 期间加锁程度，可选：</p> <ul> <li>LOCK=NONE 允许查询和 DML 操作；以避免在冗长的 DDL 操作期间使表不可用。</li> <li>LOCK=SHARED 允许查询，不允许 DML 操作；</li> <li>LOCK=DEFAULT 由系统决定，选择最宽松的模式（默认是这种）；</li> <li>LOCK=EXCLUSIVE 阻止并发查询和 DML。在尽可能短的时间内完成 DDL 操作，并且不需要并发查询和 DML 访问，则使用此子句。</li> </ul> <p>另一种划分方式为是否拷贝数据，可分为如下几种：</p> <ul> <li>仅修改元数据：包括修改表名，字段名等；</li> <li>ALGORITHM=COPY：采用拷表方式进行表变更，与 pt-osc/gh-ost 类似；</li> <li>ALGORITHM=INPLACE：仅需要进行引擎层数据改动，不涉及 Server 层；</li> <li>ALGORITHM=INSTANT：与第一种方式类似，仅修改元数据。目前仅支持在表最后增加新列；</li> <li>ALGORITHM=DEFAULT：由系统决定，选择最优的算法执行 DDL。 用户可以选用上述算法来执行，但本身受到 DDL 类型限制，如果指定的算法无法执行 DDL，则 ALTER 操作会报错。</li> </ul> <div class=highlight><pre><span></span><code><span class=c1>-- 索引的增删改查（只能新增和删除，不能直接改）</span>
<span class=c1>-- 在线加索引：操作期间，可以正常读写。</span>
<span class=k>CREATE</span><span class=w> </span><span class=k>INDEX</span><span class=w> </span><span class=n>name</span><span class=w> </span><span class=k>ON</span><span class=w> </span><span class=k>table</span><span class=w> </span><span class=p>(</span><span class=n>col_list</span><span class=p>)</span><span class=w> </span><span class=p>;</span>

<span class=k>ALTER</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>tbl_name</span><span class=w> </span><span class=k>ADD</span><span class=w> </span><span class=k>INDEX</span><span class=w> </span><span class=n>name</span><span class=w> </span><span class=p>(</span><span class=n>col_list</span><span class=p>)</span><span class=w> </span><span class=p>;</span>
<span class=c1>-- 创建普通索引</span>
<span class=k>ALTER</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=k>table_name</span><span class=w> </span><span class=k>ADD</span><span class=w> </span><span class=k>INDEX</span><span class=w> </span><span class=n>index_name</span><span class=w> </span><span class=p>(</span><span class=n>column_list</span><span class=p>);</span>
<span class=c1>-- 创建唯一索引</span>
<span class=k>ALTER</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=k>table_name</span><span class=w> </span><span class=k>ADD</span><span class=w> </span><span class=k>UNIQUE</span><span class=w> </span><span class=p>(</span><span class=n>column_list</span><span class=p>);</span>

<span class=k>CREATE</span><span class=w> </span><span class=k>INDEX</span><span class=w> </span><span class=n>index_name</span><span class=w> </span><span class=k>ON</span><span class=w> </span><span class=k>table_name</span><span class=w> </span><span class=p>(</span><span class=n>column_list</span><span class=p>);</span>
<span class=k>CREATE</span><span class=w> </span><span class=k>UNIQUE</span><span class=w> </span><span class=k>INDEX</span><span class=w> </span><span class=n>index_name</span><span class=w> </span><span class=k>ON</span><span class=w> </span><span class=k>table_name</span><span class=w> </span><span class=p>(</span><span class=n>column_list</span><span class=p>);</span>






<span class=c1>-- 修改字段数据类型（修改字段长度）</span>
<span class=c1>-- ALTER  TABLE 表名 MODIFY [COLUMN] 字段名 新数据类型 新类型长度  新默认值  新注释;</span>
<span class=k>alter</span><span class=w> </span><span class=k>table</span><span class=w> </span><span class=n>db_qhdata_policy</span><span class=p>.</span><span class=n>temp_policy_org_base</span><span class=w>  </span><span class=k>MODIFY</span><span class=w>   </span><span class=n>apprdate</span><span class=w>   </span><span class=nb>varchar</span><span class=p>(</span><span class=mi>50</span><span class=p>)</span><span class=w> </span><span class=p>;</span>
<span class=c1>-- 即使是大表，alter线程持续 copy to tmp table 状态很长时间， alter并没有阻塞其他线程的读请求</span>






<span class=c1>-- 字段重命名</span>
<span class=k>ALTER</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>tbl</span><span class=w> </span><span class=n>CHANGE</span><span class=w> </span><span class=n>old_col_name</span><span class=w> </span><span class=n>new_col_name</span><span class=w> </span><span class=n>data_type</span><span class=p>,</span><span class=w> </span><span class=n>ALGORITHM</span><span class=o>=</span><span class=n>INPLACE</span><span class=p>,</span><span class=w> </span><span class=k>LOCK</span><span class=o>=</span><span class=k>NONE</span><span class=p>;</span>
</code></pre></div> <p>从流程上看，Online DDL 可分为 3 个阶段：</p> <ul> <li>初始化阶段，确定 DDL 操作支持的最优 LOCK 和 ALGORITHM 设置，并与用户指定的设置相比，若无法办到则报错；</li> <li>执行阶段，如果需要拷表或修改引擎层数据，则该阶段是最耗时的阶段；</li> <li>提交阶段，该阶段会加锁进行新旧表切换；</li> </ul> <p>目前可用的 DDL 操作工具包括</p> <ul> <li>Percona 开源的 <a href=https://www.percona.com/doc/percona-toolkit/LATEST/pt-online-schema-change.html>pt-osc</a></li> <li>github 开源的 <a href=https://github.com/github/gh-ost>gh-ost</a>，</li> <li>MySQL 原生提供的在线修改表结构命令 Online DDL。</li> </ul> <p>pt-osc 和 gh-ost 均采用拷表方式实现，即创建个空的新表，通过 select+inser t 将旧表中的记录逐次读取并插入到新表中。</p> <p>不同之处在于处理 DDL 期间业务对表的 DML 操作（增删改）。</p> <p>从 <code>MySQL 8.0.28</code> 开始, InnoDB 支持 <code>ALTER TABLE ... RENAME COLUMN</code> 操作使用 <code>ALGORITHM=INSTANT</code>。</p> <p>从 <code>MySQL 8.0.29</code> 开始, InnoDB 支持 <code>ALTER TABLE ... DROP COLUMN</code> 操作使用 <code>ALGORITHM=INSTANT</code>。</p> <p>在 <code>8.0.29</code> 之前， instant 添加列，只能是加在表的最后一列，从 <code>8.0.29</code> 开始，可以在表的任意位置添加。</p> <p>在 8.0.29 之后，2 千万的表在任一位置即时添加列在秒级内完成。</p> <div class=highlight><pre><span></span><code><span class=k>ALTER</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>sbtest1</span><span class=w> </span><span class=k>ADD</span><span class=w> </span><span class=k>COLUMN</span><span class=w> </span><span class=n>k2</span><span class=w> </span><span class=nb>int</span><span class=p>(</span><span class=mi>10</span><span class=p>)</span><span class=w> </span><span class=k>AFTER</span><span class=w> </span><span class=n>k</span><span class=p>,</span><span class=n>ALGORITHM</span><span class=o>=</span><span class=n>INSTANT</span><span class=p>;</span>
</code></pre></div> <p>MySQL 8.0.29 开始，<code>ALTER TABLE … ALGORITHM=INSTANT</code> 支持删除某列。</p> <p>为了支持 <code>ALTER TABLE … ALGORITHM=INSTANT</code> 的新特性，<code>InnoDB redo log</code> 格式对于所有 DML 操作都发生了变化。</p> <p>新的 redo 日志格式引入了一个设计缺陷，会导致 <code>instant add/drop columns</code> 的表数据损坏。</p> <p><a href=https://opensource.actionsky.com/20220809-mysql/ >https://opensource.actionsky.com/20220809-mysql/</a></p> <p><a href=https://zhuanlan.zhihu.com/p/115277009>https://zhuanlan.zhihu.com/p/115277009</a></p> <p><a href=https://blog.csdn.net/weixin_45238761/article/details/125343029>https://blog.csdn.net/weixin_45238761/article/details/125343029</a></p> <p><a href=https://cloud.tencent.cn/developer/article/2407101>https://cloud.tencent.cn/developer/article/2407101</a></p> <h3 id=mysql-ddl>MySQL 原子 DDL<a class=headerlink href=#mysql-ddl title="Permanent link">&para;</a></h3> <p>在 MySQL8.0 之前的版本中，这些元数据被存放在许多不同的文件中（.FRM，.PAR，.OPT，.TRN，.TRG 文件等），这就导致了一系列弊端，包括数据可能不一致、API 接口的复杂性等等，在之前的月报中也有详细描述。元数据被放在许多不同的文件中，导致数据可能不一致的具体表现为：</p> <ul> <li> <p><code>Server</code> 层的 <code>metadata</code> 和 <code>Storage Engine</code> 层的 <code>metadata</code> 数据不一致</p> </li> <li> <p>InnoDB 中的 metadata 和数据不一致</p> </li> <li> <p>Binlog 和数据不一致</p> </li> </ul> <p>MySQL 5.6/5.7 的用户可能会发现，create 一张表过程中发生 crash，重启后创建一张同名新表时，会发现创建失败。这是因为过去 MySQL 5.6/5.7 的 DDL 操作不是原子的，一张表创建失败后会遗留下 ibd 文件。</p> <p>对于复合的 DDL，比如 DROP TABLE t1, t2;执行过程中如果遇到 server crash，有可能出现表 t1 被 DROP 掉了，但是 t2 没有被 DROP 掉的情况。</p> <p>即便是一条 DDL，比如 CREATE TABLE t1(a int);也可能在 server crash 的情况下导致建表不完整，有可能在建表失败的情况下遗留.frm 或者.ibd 文件。</p> <p>MySQL 8.0 对 DDL 的实现重新进行了设计，最大的改进是 DDL 操作支持原子特性。由于 MySQL 是一个多引擎数据库，在 engine 层（SE）和 server 层（SL）都维护了自己的数据字典对象。</p> <p>MySQL 8.0 之前的版本 DDL 是非原子性的，对于多条 sql 构成的 ddl 语句比如</p> <div class=highlight><pre><span></span><code><span class=k>rename</span><span class=w> </span><span class=k>table</span><span class=w> </span><span class=n>t1</span><span class=w> </span><span class=k>to</span><span class=w> </span><span class=n>t1_bak</span><span class=p>,</span><span class=n>t2</span><span class=w> </span><span class=k>to</span><span class=w> </span><span class=n>t2_bak</span><span class=p>;</span>
</code></pre></div> <p>执行过程中如果遇到系统异常 crash，有可能出现表 t1 被 rename，但是 t2 没有被 rename 的情况。出现该情况的原因就是 MySQL 不支持原子的 DDL。</p> <p>为了实现 DDL 原子性，MySQL 8.0 使用 Innodb 表存储相关的数据字典信息，这些数据字典表默认不可见，查看方法参照<a href=https://dev.mysql.com/doc/refman/8.0/en/data-dictionary-schema.html>文档</a></p> <p>什么是原子 DDL?</p> <p>当执行 DDL 时，数据字典更新、存储引擎操作和二进制日志中的写操作被合并到一个原子事务中，该事务要么完全执行，要么完全不执行。</p> <p>这提供了更好的可靠性，未完成的 ddl 不会留下任何不完整的数据。</p> <p>原子 DDL 不是事务 DDL。DDL 语句，无论是原子语句还是其他语句，都会隐式地结束当前会话中活动的任何事务，就像在执行语句之前执行了 COMMIT 一样。这意味着 DDL 语句不能在另一个事务、事务控制语句（如 START TRANSACTION ... COMMIT ）中执行，也不能与同一事务中的其他语句结合执行。</p> <div class=highlight><pre><span></span><code><span class=c1>-- MySQL5.7</span>
<span class=k>START</span><span class=w> </span><span class=k>TRANSACTION</span><span class=p>;</span>
<span class=w>    </span><span class=k>select</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=n>mytest</span><span class=p>.</span><span class=n>t2_34</span><span class=p>;</span>
<span class=w>    </span><span class=k>alter</span><span class=w> </span><span class=k>table</span><span class=w> </span><span class=n>mytest</span><span class=p>.</span><span class=n>t2_34</span><span class=w>  </span><span class=k>ADD</span><span class=w> </span><span class=k>INDEX</span><span class=w> </span><span class=n>idx_b</span><span class=p>(</span><span class=n>b</span><span class=p>)</span><span class=w> </span><span class=k>USING</span><span class=w> </span><span class=n>BTREE</span><span class=p>;</span>
<span class=w>    </span><span class=c1>-- 对于MySQL5.7，如果事务中包含DDL操作，mysql会在DDL操作语句执行后，隐式提交commit。以保证该DDL语句操作作为一个单独的事务存在，同时也保证元数据排他锁的释放</span>
<span class=w>    </span><span class=k>select</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=n>mytest</span><span class=p>.</span><span class=n>t2_34</span><span class=p>;</span>
<span class=k>ROLLBACK</span><span class=p>;</span><span class=w> </span><span class=c1>--这里的rollback语句其实已经不能回滚上面的DDL了，因为已经提交了。</span>


<span class=c1>--对于MySQL8.0，执行上述语句。发现会出现MDL阻塞</span>

<span class=c1>--然后查询会话和事务，发现是被一个sleep阻塞</span>
<span class=w> </span><span class=k>select</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=n>information_schema</span><span class=p>.</span><span class=n>processlist</span><span class=p>;</span>
<span class=w> </span><span class=k>select</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=n>information_schema</span><span class=p>.</span><span class=n>innodb_trx</span><span class=p>;</span>
</code></pre></div> <div class=highlight><pre><span></span><code><span class=c1>-- 对于这个  5.7和8.0的表现是一致的</span>
<span class=k>START</span><span class=w> </span><span class=k>TRANSACTION</span><span class=p>;</span>
<span class=w>    </span><span class=k>select</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=n>db_test</span><span class=p>.</span><span class=n>test</span><span class=p>;</span>
<span class=w>    </span><span class=k>create</span><span class=w>  </span><span class=k>table</span><span class=w> </span><span class=n>db_test</span><span class=p>.</span><span class=n>test1</span><span class=w>  </span><span class=k>like</span><span class=w> </span><span class=n>db_test</span><span class=p>.</span><span class=n>test</span><span class=p>;</span>
<span class=w>    </span><span class=k>create</span><span class=w>  </span><span class=k>table</span><span class=w> </span><span class=n>db_test</span><span class=p>.</span><span class=n>test1</span><span class=w>  </span><span class=k>like</span><span class=w> </span><span class=n>db_test</span><span class=p>.</span><span class=n>test</span><span class=p>;</span>
<span class=w>    </span><span class=k>select</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=n>db_test</span><span class=p>.</span><span class=n>test1</span><span class=p>;</span>
<span class=k>ROLLBACK</span><span class=p>;</span>
</code></pre></div> <p><a href=https://www.cnblogs.com/radondb/p/16688994.html>https://www.cnblogs.com/radondb/p/16688994.html</a></p> <h4 id=ddl>支持的 DDL 语句<a class=headerlink href=#ddl title="Permanent link">&para;</a></h4> <p>原子 DDL 支持与表相关的 DDL 语句和与表无关的 DDL 语句。</p> <p>与表相关的 DDL 操作需要存储引擎的支持，而与表无关的 DDL 操作不需要存储引擎的支持。目前，只有 InnoDB 存储引擎支持原子 DDL。</p> <p>与表相关的原子 DDL 包括数据库、表空间、表、索引的 CREATE、ALTER 以及 DROP 语句，以及 TRUNCATE TABLE 语句。</p> <p>与表无关的原子 DDL 包括：</p> <p>存储过程、触发器、视图以及用户定义函数（UDF）的 CREATE 和 DROP 语句，以及适用的 ALTER 语句。</p> <p>帐户管理语句：用户和角色的 CREATE、ALTER、DROP 语句，以及适用的 RENAME 语句，以及 GRANT 和 REVOKE 语句。</p> <p>以下语句不支持原子 DDL 操作：</p> <div class=codehilite><pre><span></span><code>非 InnoDB 存储引擎上的表相关 DDL 语句。
</code></pre></div> <p>INSTALL PLUGIN 和 UNINSTALL PLUGIN 语句。 INSTALL COMPONENT 和 UNINSTALL COMPONENT 语句。 CREATE SERVER、ALTER SERVER 以及 DROP SERVER 语句。</p> <h4 id=ddl_1>原子 DDL 的特性<a class=headerlink href=#ddl_1 title="Permanent link">&para;</a></h4> <p>原子 DDL 语句具有以下特性：</p> <ul> <li>与 DDL 操作相关的数据字典更新、存储引擎操作和二进制日志写入合并为一个单一的原子操作。</li> </ul> <p>即使服务器在操作过程中停止，该操作也会提交，并将适用的更改持久化到数据字典、存储引擎和二进制日志中，或者回滚。</p> <p>将可能存在的元数据更新、二进制日志写入以及存储引擎操作组合成单个事务。</p> <p>DDL 操作过程中不存在 SQL 层的中间提交操作。</p> <p>如果存在的话： 数据字典、过程、事件以及用户定义函数的缓存状态与 DDL 操作的状态一致，意味着 DDL 操作成功或者回滚时，缓存都会进行相应更新。 DDL 操作涉及的存储引擎相关修改不会执行中间的提交操作，而是作为 DDL 事务的一部分进行处理。 存储引擎支持 DDL 操作的重做和回滚，这些操作发生在 DDL 操作的 Post-DDL 阶段。</p> <p>从 MySQL 8.0.21 开始，在支持原子 DDL 的存储引擎上，当使用基于行的复制时， CREATE TABLE ... SELECT 语句将作为一个事务记录在二进制日志中。以前，它被记录为两个事务，一个用于创建表，另一个用于插入数据。</p> <p>如果服务器在两个事务之间或插入数据时发生故障，就会导致复制出一个空表。随着原子 DDL 支持的引入， CREATE TABLE ... SELECT 语句现在可以安全地用于基于行的复制，并允许用于基于 GTID 的复制。</p> <h2 id=mysql_1>MySQL锁问题排查<a class=headerlink href=#mysql_1 title="Permanent link">&para;</a></h2> <p>在 MySQL 5.7 之前，数据库管理员们主要依赖 <code>SHOW ENGINE INNODB STATUS</code> 和 <code>information_schema</code> 来排查棘手的锁问题。</p> <p>这些工具如同 <strong>“尸检报告”</strong> ，能详细告诉你系统 <strong>“曾经发生了什么”</strong>，比如最后一次死锁的细节，但对于 <strong>“正在发生什么”</strong> 却常常无能为力——当业务系统突然卡顿，页面加载超时，你却无法实时看到是哪个具体的事务阻塞了关键更新。</p> <p><strong>传统工具的局限性</strong>：</p> <ul> <li><code>SHOW ENGINE INNODB STATUS</code>：仅显示最近一次死锁信息，且输出为半结构化文本，难以程序化分析。</li> <li><code>information_schema.INNODB_LOCKS/INNODB_LOCK_WAITS</code>：在 MySQL 8.0 中已被标记为废弃，提供的是 <strong>静态快照视图</strong>，无法反映瞬时状态。</li> <li>无法完整追踪 <strong>“谁在等谁 → 等什么锁 → 持锁者在做什么”</strong> 的完整证据链。</li> </ul> <p><strong>performance_schema 的革命性突破</strong></p> <p>作为 MySQL 内置的性能监控引擎，performance_schema 提供了 <strong>动态、低开销</strong> 的插桩框架。对于锁等待场景，它的核心价值在于：<strong>实时记录锁的“获取-等待-释放”全过程，而非最终状态</strong>。</p> <p>这种能力让 performance_schema 成为线上实时故障排查的 <strong>“动态心电图”</strong> ，尤其适合以下场景：</p> <ul> <li><strong>突发性业务卡顿</strong>，但未形成死锁</li> <li><strong>间歇性慢查询</strong>，怀疑是锁竞争导致</li> <li><strong>需要定位“锁源头”</strong> 而非仅仅“锁现象”</li> </ul> <p>监控框架的三层架构</p> <div class=highlight><pre><span></span><code>Instrumentation → Consumer → SQL Interface
    (采集点)     → (消费者表) → (用户查询)
</code></pre></div> <ol> <li> <p><strong>采集点（Instrument）</strong>：在 MySQL 服务器代码的关键路径插入的钩子函数，如 <code>wait/lock/table/sql/handler</code>。</p> </li> <li> <p><strong>消费者表（Consumer）</strong>：如 <code>data_locks</code>、<code>data_lock_waits</code>、<code>metadata_locks</code> 等，用于存储采集到的原始数据。</p> </li> <li> <p><strong>SQL接口</strong>：通过标准的 <code>SELECT</code> 查询将数据暴露给用户和监控系统。</p> </li> </ol> <div class=highlight><pre><span></span><code>data_lock_waits               data_locks                  threads
┌─────────────────────┐      ┌─────────────────┐      ┌─────────────┐
│ waiting_lock_id   ──┼─────►│ lock_id         │      │ thread_id   │
│ blocking_lock_id  ──┼─────►│ lock_id         │◄─────┤ processlist │
│                     │      │ thread_id       │      │  id         │
└─────────────────────┘      └─────────────────┘      └─────────────┘
         │                                                    ▲
         │                                                    │
         ▼                                                    │
 events_statements_current                                    │
┌──────────────────────┐                                     │
│ thread_id          ──┼─────────────────────────────────────┘
│ sql_text            │
└──────────────────────┘
</code></pre></div> <p><strong>关键设计</strong>：<code>data_lock_waits</code> 表通过外键关系明确记录了等待的 <strong>因果关系</strong> ，这是传统工具无法提供的。这张表直接回答了“谁阻塞了谁”这个核心问题。</p> <h3 id=_36>基础检查<a class=headerlink href=#_36 title="Permanent link">&para;</a></h3> <div class=highlight><pre><span></span><code><span class=c1>-- 基础检查</span>
<span class=k>SHOW</span><span class=w> </span><span class=n>VARIABLES</span><span class=w> </span><span class=k>LIKE</span><span class=s1>&#39;performance_schema&#39;</span><span class=p>;</span>

<span class=c1>-- 更详细的配置检查（MySQL 8.0/9.0 同样适用）</span>
<span class=k>SELECT</span>
<span class=w>    </span><span class=n>VARIABLE_NAME</span><span class=p>,</span>
<span class=w>    </span><span class=n>VARIABLE_VALUE</span><span class=p>,</span>
<span class=w>    </span><span class=n>CASEWHEN</span><span class=w> </span><span class=n>VARIABLE_VALUE</span><span class=w> </span><span class=o>=</span><span class=s1>&#39;ON&#39;</span><span class=k>THEN</span><span class=s1>&#39;✅&#39;</span><span class=k>ELSE</span><span class=s1>&#39;❌&#39;</span><span class=n>ENDAS</span><span class=w> </span><span class=n>STATUS</span>
<span class=k>FROM</span><span class=w> </span><span class=n>performance_schema</span><span class=p>.</span><span class=n>global_variables</span>
<span class=k>WHERE</span><span class=w> </span><span class=n>VARIABLE_NAME</span><span class=w> </span><span class=k>IN</span><span class=w> </span><span class=p>(</span>
<span class=w>    </span><span class=s1>&#39;performance_schema&#39;</span><span class=p>,</span>
<span class=w>    </span><span class=s1>&#39;performance_schema_consumer_events_statements_current&#39;</span><span class=p>,</span>
<span class=w>    </span><span class=s1>&#39;performance_schema_consumer_global_instrumentation&#39;</span>
<span class=p>);</span>
</code></pre></div> <h3 id=_37>必要时调整采集粒度<a class=headerlink href=#_37 title="Permanent link">&para;</a></h3> <p>默认情况下，MySQL 8.0 和 9.0 已经为锁监控启用了必要的采集点。但在某些深度调试场景，你可能需要确认。</p> <div class=highlight><pre><span></span><code><span class=c1>-- 查看当前锁监控设置</span>
<span class=k>SELECT</span><span class=w> </span><span class=n>NAME</span><span class=p>,</span><span class=w> </span><span class=n>ENABLED</span><span class=p>,</span><span class=w> </span><span class=n>TIMED</span><span class=w> </span>
<span class=k>FROM</span><span class=w> </span><span class=n>performance_schema</span><span class=p>.</span><span class=n>setup_instruments</span><span class=w> </span>
<span class=k>WHERE</span><span class=w> </span><span class=n>NAME</span><span class=w> </span><span class=k>LIKE</span><span class=s1>&#39;%lock%&#39;</span><span class=k>AND</span><span class=w> </span><span class=n>NAME</span><span class=w> </span><span class=k>LIKE</span><span class=s1>&#39;%innodb%&#39;</span><span class=p>;</span>

<span class=c1>-- 在测试环境中，如果需要更全面的监控，可以启用所有锁相关的instrument</span>
<span class=c1>-- 生产环境请谨慎评估性能影响</span>
<span class=k>UPDATE</span><span class=w> </span><span class=n>performance_schema</span><span class=p>.</span><span class=n>setup_instruments</span><span class=w> </span>
<span class=k>SET</span><span class=w> </span><span class=n>ENABLED</span><span class=w> </span><span class=o>=</span><span class=s1>&#39;YES&#39;</span><span class=p>,</span><span class=w> </span><span class=n>TIMED</span><span class=w> </span><span class=o>=</span><span class=s1>&#39;YES&#39;</span>
<span class=k>WHERE</span><span class=w> </span><span class=n>NAME</span><span class=w> </span><span class=k>LIKE</span><span class=s1>&#39;wait/synch/mutex/innodb/%&#39;</span>
<span class=w>   </span><span class=k>OR</span><span class=w> </span><span class=n>NAME</span><span class=w> </span><span class=k>LIKE</span><span class=s1>&#39;wait/synch/rwlock/innodb/%&#39;</span><span class=p>;</span>
</code></pre></div> <h3 id=_38>核心视图<a class=headerlink href=#_38 title="Permanent link">&para;</a></h3> <p><code>performance_schema.data_locks</code> 表（MySQL 8.0 引入，替代了 <code>information_schema.INNODB_LOCKS</code>）记录了 InnoDB 引擎当前持有或正在请求的**所有锁**。</p> <div class=highlight><pre><span></span><code><span class=c1>-- 关键字段解读</span>
<span class=k>SELECT</span><span class=w> </span>
<span class=w>    </span><span class=n>ENGINE</span><span class=p>,</span><span class=w>                   </span><span class=c1>-- 存储引擎（始终为 INNODB）</span>
<span class=w>    </span><span class=n>ENGINE_LOCK_ID</span><span class=p>,</span><span class=w>           </span><span class=c1>-- 锁的唯一标识</span>
<span class=w>    </span><span class=n>ENGINE_TRANSACTION_ID</span><span class=p>,</span><span class=w>    </span><span class=c1>-- 事务 ID</span>
<span class=w>    </span><span class=n>THREAD_ID</span><span class=p>,</span><span class=w>                </span><span class=c1>-- 持有锁的线程 ID</span>
<span class=w>    </span><span class=n>OBJECT_SCHEMA</span><span class=p>,</span><span class=w>            </span><span class=c1>-- 数据库名</span>
<span class=w>    </span><span class=n>OBJECT_NAME</span><span class=p>,</span><span class=w>              </span><span class=c1>-- 表名</span>
<span class=w>    </span><span class=n>INDEX_NAME</span><span class=p>,</span><span class=w>               </span><span class=c1>-- 索引名（NULL 表示表锁）</span>
<span class=w>    </span><span class=n>LOCK_TYPE</span><span class=p>,</span><span class=w>                </span><span class=c1>-- 锁类型：TABLE（表锁）/ RECORD（行锁）</span>
<span class=w>    </span><span class=n>LOCK_MODE</span><span class=p>,</span><span class=w>                </span><span class=c1>-- 锁模式：S, X, IS, IX, GAP, NEXT_KEY 等</span>
<span class=w>    </span><span class=n>LOCK_STATUS</span><span class=p>,</span><span class=w>              </span><span class=c1>-- 状态：GRANTED（已持有）/ WAITING（等待中）</span>
<span class=w>    </span><span class=n>LOCK_DATA</span><span class=w>                 </span><span class=c1>-- 锁定的数据（主键值或其他索引值）</span>
<span class=k>FROM</span><span class=w> </span><span class=n>performance_schema</span><span class=p>.</span><span class=n>data_locks</span><span class=p>;</span>
</code></pre></div> <p>根据 MySQL 官方文档以及 InnoDB 存储引擎的底层实现，<code>lock_mode</code> 的类型实际上是由 <strong>基础锁模式</strong> 和 <strong>锁范围属性</strong> 组合而成的。</p> <p><strong>基础锁模式</strong></p> <table> <thead> <tr> <th><strong>锁模式</strong></th> <th><strong>完整名称</strong></th> <th><strong>级别</strong></th> <th><strong>核心功能描述</strong></th> <th><strong>兼容性 (S)</strong></th> <th><strong>兼容性 (X)</strong></th> </tr> </thead> <tbody> <tr> <td><strong>S</strong></td> <td><strong>共享锁 (Shared Lock)</strong></td> <td>行级</td> <td>允许事务读取一行数据。多个事务可以同时持有同一行的 S 锁。</td> <td><strong>兼容</strong></td> <td>冲突</td> </tr> <tr> <td><strong>X</strong></td> <td><strong>排他锁 (Exclusive Lock)</strong></td> <td>行级</td> <td>允许事务删除或更新一行。一旦持有 X 锁，其他事务不能再对该行加任何锁。</td> <td>冲突</td> <td><strong>冲突</strong></td> </tr> <tr> <td><strong>IS</strong></td> <td><strong>意向共享锁 (Intent Shared)</strong></td> <td>表级</td> <td>表示事务打算给表中的某些行加 S 锁。由系统自动添加。</td> <td>兼容</td> <td>冲突</td> </tr> <tr> <td><strong>IX</strong></td> <td><strong>意向排他锁 (Intent Exclusive)</strong></td> <td>表级</td> <td>表示事务打算给表中的某些行加 X 锁。由系统自动添加。</td> <td>冲突</td> <td>冲突</td> </tr> </tbody> </table> <p><strong>锁范围属性</strong></p> <table> <thead> <tr> <th><strong>属性类型</strong></th> <th><strong>日志标识示例</strong></th> <th><strong>锁定区间 (假设当前值 10, 前值 5)</strong></th> <th><strong>是否锁记录</strong></th> <th><strong>是否锁间隙</strong></th> <th><strong>核心用途</strong></th> </tr> </thead> <tbody> <tr> <td><strong>记录锁</strong></td> <td><code>X,REC_NOT_GAP</code></td> <td><code>[10]</code></td> <td>是</td> <td>否</td> <td>精准锁定已有行</td> </tr> <tr> <td><strong>间隙锁</strong></td> <td><code>X,GAP</code></td> <td><code>(5, 10)</code></td> <td>否</td> <td>是</td> <td>防止某个区间插入</td> </tr> <tr> <td><strong>临键锁</strong></td> <td><code>X</code></td> <td><code>(5, 10]</code></td> <td>是</td> <td>是</td> <td>RR 级默认锁，防幻读</td> </tr> <tr> <td><strong>插入意向锁</strong></td> <td><code>X,INSERT_INTENTION</code></td> <td>间隙内的特定点</td> <td>否</td> <td>是 (等待中)</td> <td>提高间隙插入的并发</td> </tr> </tbody> </table> <p><code>performance_schema.data_lock_waits</code>这是 <strong>最关键</strong> 的视图，直接映射了阻塞关系。它回答了“谁在等谁”。</p> <div class=highlight><pre><span></span><code><span class=k>SELECT</span><span class=w> </span>
<span class=w>    </span><span class=n>REQUESTING_ENGINE_LOCK_ID</span><span class=p>,</span><span class=w>              </span><span class=c1>-- 正在等待的锁 ID</span>
<span class=w>    </span><span class=n>REQUESTING_ENGINE_TRANSACTION_ID</span><span class=p>,</span><span class=w>       </span><span class=c1>-- 正在等待的事务 ID</span>
<span class=w>    </span><span class=n>BLOCKING_ENGINE_LOCK_ID</span><span class=p>,</span><span class=w>                </span><span class=c1>-- 造成阻塞的锁 ID  </span>
<span class=w>    </span><span class=n>BLOCKING_ENGINE_TRANSACTION_ID</span><span class=p>,</span><span class=w>         </span><span class=c1>-- 造成阻塞的事务 ID</span>
<span class=w>    </span><span class=n>REQUESTING_THREAD_ID</span><span class=p>,</span><span class=w>                   </span><span class=c1>-- 等待的线程 ID</span>
<span class=w>    </span><span class=n>BLOCKING_THREAD_ID</span><span class=w>                      </span><span class=c1>-- 阻塞的线程 ID</span>
<span class=k>FROM</span><span class=w> </span><span class=n>performance_schema</span><span class=p>.</span><span class=n>data_lock_waits</span><span class=p>;</span>
</code></pre></div> <h3 id=_39>锁排查实战<a class=headerlink href=#_39 title="Permanent link">&para;</a></h3> <p>业务反馈：<code>UPDATE orders SET status = 2 WHERE user_id = 100 AND order_time &gt; '2023-01-01';</code> 执行超过 30 秒未返回。</p> <p>第一步：快速确认锁等待存在</p> <div class=highlight><pre><span></span><code><span class=c1>-- 快速检查是否存在锁等待</span>
<span class=k>SELECT</span><span class=w> </span><span class=k>COUNT</span><span class=p>(</span><span class=o>*</span><span class=p>)</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=n>lock_wait_count</span><span class=w>  </span><span class=k>FROM</span><span class=w> </span><span class=n>performance_schema</span><span class=p>.</span><span class=n>data_lock_waits</span><span class=p>;</span>

<span class=c1>-- 如果有等待，查看等待概况</span>
<span class=k>SELECT</span><span class=w> </span>
<span class=w>    </span><span class=k>COUNT</span><span class=p>(</span><span class=o>*</span><span class=p>)</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=n>total_waits</span><span class=p>,</span>
<span class=w>    </span><span class=k>COUNT</span><span class=p>(</span><span class=k>DISTINCT</span><span class=w> </span><span class=n>BLOCKING_ENGINE_TRANSACTION_ID</span><span class=p>)</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=n>blocking_trx_count</span>
<span class=k>FROM</span><span class=w> </span><span class=n>performance_schema</span><span class=p>.</span><span class=n>data_lock_waits</span><span class=p>;</span>
</code></pre></div> <p>第二步：定位阻塞关系链</p> <div class=highlight><pre><span></span><code><span class=c1>-- 完整阻塞关系查询（核心 SQL）</span>
<span class=k>WITH</span><span class=w> </span><span class=n>LockWaitChain</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=p>(</span>
<span class=w>    </span><span class=k>SELECT</span>
<span class=w>        </span><span class=n>w</span><span class=p>.</span><span class=n>REQUESTING_ENGINE_TRANSACTION_ID</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=n>waiting_trx_id</span><span class=p>,</span>
<span class=w>        </span><span class=n>w</span><span class=p>.</span><span class=n>BLOCKING_ENGINE_TRANSACTION_ID</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=n>blocking_trx_id</span><span class=p>,</span>
<span class=w>        </span><span class=n>r</span><span class=p>.</span><span class=n>trx_started</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=n>waiting_started</span><span class=p>,</span>
<span class=w>        </span><span class=n>b</span><span class=p>.</span><span class=n>trx_started</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=n>blocking_started</span><span class=p>,</span>
<span class=w>        </span><span class=n>TIMESTAMPDIFF</span><span class=p>(</span><span class=k>SECOND</span><span class=p>,</span><span class=w> </span><span class=n>b</span><span class=p>.</span><span class=n>trx_started</span><span class=p>,</span><span class=w> </span><span class=n>NOW</span><span class=p>())</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=n>blocking_age_seconds</span><span class=p>,</span>
<span class=w>        </span><span class=n>r</span><span class=p>.</span><span class=n>trx_mysql_thread_id</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=n>waiting_thread</span><span class=p>,</span>
<span class=w>        </span><span class=n>b</span><span class=p>.</span><span class=n>trx_mysql_thread_id</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=n>blocking_thread</span>
<span class=w>    </span><span class=k>FROM</span><span class=w> </span><span class=n>performance_schema</span><span class=p>.</span><span class=n>data_lock_waits</span><span class=w> </span><span class=n>w</span>
<span class=w>    </span><span class=k>JOIN</span><span class=w> </span><span class=n>information_schema</span><span class=p>.</span><span class=n>innodb_trx</span><span class=w> </span><span class=n>r</span><span class=w> </span>
<span class=w>        </span><span class=k>ON</span><span class=w> </span><span class=n>w</span><span class=p>.</span><span class=n>REQUESTING_ENGINE_TRANSACTION_ID</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>r</span><span class=p>.</span><span class=n>trx_id</span>
<span class=w>    </span><span class=k>JOIN</span><span class=w> </span><span class=n>information_schema</span><span class=p>.</span><span class=n>innodb_trx</span><span class=w> </span><span class=n>b</span><span class=w> </span>
<span class=w>        </span><span class=k>ON</span><span class=w> </span><span class=n>w</span><span class=p>.</span><span class=n>BLOCKING_ENGINE_TRANSACTION_ID</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>b</span><span class=p>.</span><span class=n>trx_id</span>
<span class=p>)</span>
<span class=k>SELECT</span>
<span class=w>    </span><span class=n>waiting_trx_id</span><span class=p>,</span>
<span class=w>    </span><span class=n>blocking_trx_id</span><span class=p>,</span>
<span class=w>    </span><span class=n>waiting_thread</span><span class=p>,</span>
<span class=w>    </span><span class=n>blocking_thread</span><span class=p>,</span>
<span class=w>    </span><span class=n>blocking_age_seconds</span><span class=p>,</span>
<span class=w>    </span><span class=n>waiting_started</span><span class=p>,</span>
<span class=w>    </span><span class=n>blocking_started</span><span class=p>,</span>
<span class=w>    </span><span class=k>CASE</span>
<span class=w>        </span><span class=k>WHEN</span><span class=w> </span><span class=n>blocking_age_seconds</span><span class=w> </span><span class=o>&gt;</span><span class=mi>300</span><span class=k>THEN</span><span class=s1>&#39;⛔ 长事务风险&#39;</span>
<span class=w>        </span><span class=k>WHEN</span><span class=w> </span><span class=n>blocking_age_seconds</span><span class=w> </span><span class=o>&gt;</span><span class=mi>60</span><span class=k>THEN</span><span class=s1>&#39;⚠️  事务较长&#39;</span>
<span class=w>        </span><span class=k>ELSE</span><span class=s1>&#39;✅ 正常范围&#39;</span>
<span class=w>    </span><span class=n>ENDAS</span><span class=w> </span><span class=n>risk_assessment</span>
<span class=k>FROM</span><span class=w> </span><span class=n>LockWaitChain</span>
<span class=n>ORDERBY</span><span class=w> </span><span class=n>blocking_age_seconds</span><span class=w> </span><span class=k>DESC</span><span class=p>;</span>
</code></pre></div> <p>第三步：获取阻塞双方 SQL 上下文</p> <div class=highlight><pre><span></span><code><span class=c1>-- 获取所有涉及锁等待的线程当前执行的 SQL</span>
<span class=k>SELECT</span>
<span class=w>    </span><span class=n>t</span><span class=p>.</span><span class=n>PROCESSLIST_ID</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=n>conn_id</span><span class=p>,</span>
<span class=w>    </span><span class=n>t</span><span class=p>.</span><span class=n>PROCESSLIST_USER</span><span class=w> </span><span class=n>ASuser</span><span class=p>,</span>
<span class=w>    </span><span class=n>t</span><span class=p>.</span><span class=n>PROCESSLIST_HOST</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=k>host</span><span class=p>,</span>
<span class=w>    </span><span class=n>t</span><span class=p>.</span><span class=n>PROCESSLIST_DB</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=n>db</span><span class=p>,</span>
<span class=w>    </span><span class=n>t</span><span class=p>.</span><span class=n>PROCESSLIST_COMMAND</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=n>cmd</span><span class=p>,</span>
<span class=w>    </span><span class=n>t</span><span class=p>.</span><span class=n>PROCESSLIST_INFO</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=n>current_sql</span><span class=p>,</span>
<span class=w>    </span><span class=n>es</span><span class=p>.</span><span class=n>SQL_TEXT</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=n>p_sql_text</span><span class=p>,</span>
<span class=w>    </span><span class=n>es</span><span class=p>.</span><span class=n>ROWS_EXAMINED</span><span class=p>,</span>
<span class=w>    </span><span class=n>es</span><span class=p>.</span><span class=n>ROWS_AFFECTED</span><span class=p>,</span>
<span class=w>    </span><span class=n>TIMESTAMPDIFF</span><span class=p>(</span><span class=k>SECOND</span><span class=p>,</span><span class=w> </span><span class=n>es</span><span class=p>.</span><span class=n>EVENT_TIME</span><span class=p>,</span><span class=w> </span><span class=n>NOW</span><span class=p>())</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=n>sql_duration_sec</span>
<span class=k>FROM</span><span class=w> </span><span class=n>performance_schema</span><span class=p>.</span><span class=n>threads</span><span class=w> </span><span class=n>t</span>
<span class=n>LEFTJOIN</span><span class=w> </span><span class=n>performance_schema</span><span class=p>.</span><span class=n>events_statements_current</span><span class=w> </span><span class=n>es</span><span class=w> </span>
<span class=w>    </span><span class=k>ON</span><span class=w> </span><span class=n>t</span><span class=p>.</span><span class=n>THREAD_ID</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>es</span><span class=p>.</span><span class=n>THREAD_ID</span>
<span class=k>WHERE</span><span class=w> </span><span class=n>t</span><span class=p>.</span><span class=n>PROCESSLIST_ID</span><span class=w> </span><span class=k>IN</span><span class=w> </span><span class=p>(</span>
<span class=w>    </span><span class=c1>-- 获取所有阻塞者和等待者的连接 ID</span>
<span class=w>    </span><span class=n>SELECTDISTINCT</span><span class=w> </span><span class=n>r</span><span class=p>.</span><span class=n>trx_mysql_thread_id</span>
<span class=w>    </span><span class=k>FROM</span><span class=w> </span><span class=n>performance_schema</span><span class=p>.</span><span class=n>data_lock_waits</span><span class=w> </span><span class=n>w</span>
<span class=w>    </span><span class=k>JOIN</span><span class=w> </span><span class=n>information_schema</span><span class=p>.</span><span class=n>innodb_trx</span><span class=w> </span><span class=n>r</span><span class=w> </span>
<span class=w>        </span><span class=k>ON</span><span class=w> </span><span class=n>w</span><span class=p>.</span><span class=n>REQUESTING_ENGINE_TRANSACTION_ID</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>r</span><span class=p>.</span><span class=n>trx_id</span>
<span class=w>        </span><span class=k>OR</span><span class=w> </span><span class=n>w</span><span class=p>.</span><span class=n>BLOCKING_ENGINE_TRANSACTION_ID</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>r</span><span class=p>.</span><span class=n>trx_id</span>
<span class=p>)</span>
<span class=k>AND</span><span class=w> </span><span class=n>t</span><span class=p>.</span><span class=n>PROCESSLIST_ID</span><span class=w> </span><span class=n>ISNOT</span><span class=w> </span><span class=k>NULL</span><span class=p>;</span>
</code></pre></div> <p>第四步：分析锁的粒度与范围</p> <div class=highlight><pre><span></span><code><span class=c1>-- 分析锁的具体类型和范围</span>
<span class=k>SELECT</span>
<span class=w>    </span><span class=n>dl</span><span class=p>.</span><span class=n>OBJECT_SCHEMA</span><span class=p>,</span>
<span class=w>    </span><span class=n>dl</span><span class=p>.</span><span class=n>OBJECT_NAME</span><span class=p>,</span>
<span class=w>    </span><span class=n>dl</span><span class=p>.</span><span class=n>INDEX_NAME</span><span class=p>,</span>
<span class=w>    </span><span class=n>dl</span><span class=p>.</span><span class=n>LOCK_TYPE</span><span class=p>,</span>
<span class=w>    </span><span class=n>dl</span><span class=p>.</span><span class=n>LOCK_MODE</span><span class=p>,</span>
<span class=w>    </span><span class=n>dl</span><span class=p>.</span><span class=n>LOCK_STATUS</span><span class=p>,</span>
<span class=w>    </span><span class=n>dl</span><span class=p>.</span><span class=n>LOCK_DATA</span><span class=p>,</span>
<span class=w>    </span><span class=k>COUNT</span><span class=p>(</span><span class=o>*</span><span class=p>)</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=n>lock_count</span><span class=p>,</span>
<span class=w>    </span><span class=n>GROUP_CONCAT</span><span class=p>(</span><span class=k>DISTINCT</span><span class=w> </span><span class=n>dl</span><span class=p>.</span><span class=n>ENGINE_TRANSACTION_ID</span><span class=p>)</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=n>involved_trx_ids</span>
<span class=k>FROM</span><span class=w> </span><span class=n>performance_schema</span><span class=p>.</span><span class=n>data_locks</span><span class=w> </span><span class=n>dl</span>
<span class=k>WHERE</span><span class=w> </span><span class=n>dl</span><span class=p>.</span><span class=n>ENGINE_TRANSACTION_ID</span><span class=w> </span><span class=k>IN</span><span class=w> </span><span class=p>(</span>
<span class=w>    </span><span class=n>SELECTDISTINCT</span><span class=w> </span><span class=n>REQUESTING_ENGINE_TRANSACTION_ID</span><span class=w> </span>
<span class=w>    </span><span class=k>FROM</span><span class=w> </span><span class=n>performance_schema</span><span class=p>.</span><span class=n>data_lock_waits</span>
<span class=w>    </span><span class=k>UNION</span>
<span class=w>    </span><span class=n>SELECTDISTINCT</span><span class=w> </span><span class=n>BLOCKING_ENGINE_TRANSACTION_ID</span><span class=w> </span>
<span class=w>    </span><span class=k>FROM</span><span class=w> </span><span class=n>performance_schema</span><span class=p>.</span><span class=n>data_lock_waits</span>
<span class=p>)</span>
<span class=n>GROUPBY</span>
<span class=w>    </span><span class=n>dl</span><span class=p>.</span><span class=n>OBJECT_SCHEMA</span><span class=p>,</span>
<span class=w>    </span><span class=n>dl</span><span class=p>.</span><span class=n>OBJECT_NAME</span><span class=p>,</span>
<span class=w>    </span><span class=n>dl</span><span class=p>.</span><span class=n>INDEX_NAME</span><span class=p>,</span>
<span class=w>    </span><span class=n>dl</span><span class=p>.</span><span class=n>LOCK_TYPE</span><span class=p>,</span>
<span class=w>    </span><span class=n>dl</span><span class=p>.</span><span class=n>LOCK_MODE</span><span class=p>,</span>
<span class=w>    </span><span class=n>dl</span><span class=p>.</span><span class=n>LOCK_STATUS</span><span class=p>,</span>
<span class=w>    </span><span class=n>dl</span><span class=p>.</span><span class=n>LOCK_DATA</span>
<span class=n>ORDERBY</span><span class=w> </span><span class=n>lock_count</span><span class=w> </span><span class=k>DESC</span><span class=p>;</span>
</code></pre></div> <h3 id=_40>关键注意事项与最佳实践<a class=headerlink href=#_40 title="Permanent link">&para;</a></h3> <ol> <li> <p><strong>警惕监控本身的性能风险</strong>：当系统中存在**海量行锁**（如一个未提交的事务锁定了上百万行）时，查询 <code>performance_schema.data_locks</code> 可能会消耗大量内存和 CPU，<strong>在早期 MySQL 8.0 版本中甚至可能导致实例挂起</strong>。</p> </li> <li> <p><strong>最佳实践</strong>：先用 <code>SELECT COUNT(*) FROM performance_schema.data_locks;</code> 快速评估锁数量。若数量巨大，优先通过 <code>information_schema.innodb_trx</code> 找出并处理长事务源头。</p> </li> <li><strong>优化关联查询效率</strong>：<code>data_lock_waits</code> 表上的事务 ID 索引在复杂关联查询时可能效率不高。如果发现查询慢，可以尝试简化查询条件或使用 <code>IGNORE INDEX</code> 提示。</li> <li><strong>拓展监控范围至元数据锁</strong>：除了 InnoDB 行锁，<strong>元数据锁</strong>（MDL）等待是另一个常见阻塞原因。在 MySQL 8.0/9.0 中，你可以通过以下方式监控</li> </ol> <div class=highlight><pre><span></span><code><span class=c1>-- 首先确保启用 MDL 监控（通常默认开启）</span>
<span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>performance_schema</span><span class=p>.</span><span class=n>setup_instruments</span><span class=w> </span>
<span class=k>WHERE</span><span class=w> </span><span class=n>NAME</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s1>&#39;wait/lock/metadata/sql/mdl&#39;</span><span class=p>;</span>

<span class=c1>-- 查询当前的 MDL 等待</span>
<span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>performance_schema</span><span class=p>.</span><span class=n>metadata_locks</span><span class=w> </span>
<span class=k>WHERE</span><span class=w> </span><span class=n>OWNER_THREAD_ID</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=mi>0</span><span class=w> </span>
<span class=k>AND</span><span class=w> </span><span class=n>LOCK_STATUS</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s1>&#39;PENDING&#39;</span><span class=p>;</span>
</code></pre></div> <p><strong>拥抱新的诊断工具</strong>：</p> <ul> <li>• <strong><code>EXPLAIN ANALYZE</code> (MySQL 8.0.18+)</strong>：在排查因低效查询导致锁范围过大时，这个工具可以实际执行查询并输出详细的执行计划和实际耗时，比传统 <code>EXPLAIN</code> 更精准。</li> <li>• <strong><code>SELECT * FROM sys.schema_table_lock_waits;</code></strong>：如果你启用了 <code>sys</code> 库，这个视图能快速给出表级锁等待的友好摘要。</li> </ul> <aside class=md-source-file> <span class=md-source-file__fact> <span class=md-icon title=最后更新> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M21 13.1c-.1 0-.3.1-.4.2l-1 1 2.1 2.1 1-1c.2-.2.2-.6 0-.8l-1.3-1.3c-.1-.1-.2-.2-.4-.2m-1.9 1.8-6.1 6V23h2.1l6.1-6.1-2.1-2M12.5 7v5.2l4 2.4-1 1L11 13V7h1.5M11 21.9c-5.1-.5-9-4.8-9-9.9C2 6.5 6.5 2 12 2c5.3 0 9.6 4.1 10 9.3-.3-.1-.6-.2-1-.2s-.7.1-1 .2C19.6 7.2 16.2 4 12 4c-4.4 0-8 3.6-8 8 0 4.1 3.1 7.5 7.1 7.9l-.1.2v1.8Z"/></svg> </span> <span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-iso_datetime" title="2025年12月24日 05:56:46 UTC">2025-12-24 05:56:46</span> </span> </aside> </article> </div> <script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script> </div> <button type=button class="md-top md-icon" data-md-component=top hidden> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12Z"/></svg> 回到页面顶部 </button> </main> <footer class=md-footer> <div class="md-footer-meta md-typeset"> <div class="md-footer-meta__inner md-grid"> <div class=md-copyright> <div class=md-copyright__highlight> Copyleft &copy; 2020 - 2023 fengzhao </div> Made with <a href=https://squidfunk.github.io/mkdocs-material/ target=_blank rel=noopener> Material for MkDocs </a> </div> </div> </div> </footer> </div> <div class=md-dialog data-md-component=dialog> <div class="md-dialog__inner md-typeset"></div> </div> <script id=__config type=application/json>{"base": "../..", "features": ["navigation.tabs", "navigation.tabs.sticky", "navigation.sections", "navigation.top"], "search": "../../assets/javascripts/workers/search.b8dbb3d2.min.js", "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}}</script> <script src=../../assets/javascripts/bundle.1e8ae164.min.js></script> </body> </html>