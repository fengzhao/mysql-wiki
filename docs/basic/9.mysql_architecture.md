## MySQL逻辑架构

![architecture](https://fengzhaonote.notion.site/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F60e63f69-3261-48df-a6d9-34ac0f8d73a7%2FUntitled.png?table=block&id=d6d2f0cf-e51d-48c7-a078-9126b92ec080&spaceId=5468c791-49fa-43aa-825f-28501aabf76f&width=1920&userId=&cache=v2)

MySQL逻辑架构整体分为三层：

- 连接层：最上层为客户端层，并非MySQL所独有，诸如：连接处理、授权认证、安全等功能均在这一层处理。
- 中间层：MySQL大多数核心服务均在中间这一层，包括查询解析、分析、优化、缓存、内置函数(比如：时间、数学、加密等函数)。所有的跨存储引擎的功能也在这一层实现：存储过程、触发器、视图等。
- 存储引擎层：最下层为存储引擎，其负责MySQL中的数据存储和提取。和Linux中的文件系统类似，每种存储引擎都有其优势和劣势。中间的服务层通过API与存储引擎通信，这些API接口屏蔽了不同存储引擎间的差异。


MySQL Server是一个单进程多线程的服务程序，在 MySQL Server上 用 ps -ef | grep mysqld 就能看到其系统进程ID了。

MySQL请求处理流程

1. 客户端向MySQL服务器发送一条查询请求。
2. 服务器首先检查查询缓存，如果命中缓存，则立刻返回存储在缓存中的结果。否则进入下一阶段。
3. 服务器进行SQL解析、预处理、再由优化器生成对应的执行计划。
4. MySQL根据执行计划，调用存储引擎的API来执行查询。
5. 将结果返回给客户端，同时缓存查询结果。

每一个客户端发起一个新的请求都由服务器端的 **连接/线程处理工具** 负责接收客户端的请求，并在服务端内存中开辟一个新的内存空间，生成一个新的线程。

当每一个用户连接到服务器端的时候就会在进程地址空间里生成一个新的线程用于响应客户端请求，用户发起的查询请求都在线程空间内运行，结果也在这里面缓存并返回给服务器端。

线程的重用和销毁都是由 **连接/线程处理管理器** 实现的。

综上所述：用户发起请求，连接/线程处理器开辟内存空间，开始提供查询的机制。

用户总是希望MySQL能够获得更高的查询性能，最好的办法是弄清楚MySQL是如何优化和执行查询的。

一旦理解了这一点，就会发现：很多的查询优化工作实际上就是遵循一些原则让MySQL的优化器能够按照预想的合理方式运行而已。



### **客户端/服务端通信协议**


一般来说，不需要去理解 MySQL 通信协议的内部实现细节，只需要大致理解通信协议是如何工作的。

MySQL客户端/服务端 **通信协议是“半双工”的：在任一时刻，要么是服务器向客户端发送数据，要么是客户端向服务器发送数据，这两个动作不能同时发生。**

这种协议让 MySQL 通信简单快速， 但是也从很多地方限制了 MySQL。一个明显的限制是， 这意味着没法进行流量控制。

一旦一端开始发送消息，另一端要接收完整个消息才能响应它，所以我们无法也无须将一个消息切成小块独立发送，也没有办法进行流量控制。


**客户端提交一个SQL请求给服务器时是直接用一个单独的数据包发送的，所以当查询语句很长的时候，比如一次性提交插入大量数据时，需要注意控制 `max_allowed_packet` 参数。**

```shell
# max_allowed_packet表示服务器所能处理的请求包的最大值。默认是64MB，最大值是1GB。MySQL 8.0单个packet可以允许的最大值是1GB
# 客户端和服务端都有自己的max_allowed_packet变量，所以要调节此参数时，必须同时增加server端和client端的配置变量。
max_allowed_packet=64MB


# 每个客户端线程都关联了 1 个连接缓冲区（connection buffer）和 1 个结果集缓冲区（result buffer）。
# 这 2 个缓冲区的初始大小都由 net_buffer_length 控制，需要时最大可以自动增长到不超过 max_allowed_packet。
# 每条 SQL 语句执行完成后，结果集缓冲区都会自动恢复到 net_buffer_length 指定的大小。

# 一般情况下，不应该修改 net_buffer_length 的值，如果这个值设置得非常小，你可以把它修改为客户端发送的 SQL 语句预期的长度。
# 如果 SQL 语句长度超过这个值，连接缓冲区还会自动增长。net_buffer_length 的最大值为 1048576（1M）。

```

MySQL是C/S结构，client与server之间的通信需要遵循约定的规则，C/S之间通信的最小单元就是packet，通信约定的规则就是packet的结构。

一个传输的包（a communication packet ）代表着：

- 客户端发送到mysql 服务端的单个SQL STATEMENT
- 服务端发送到客户端的单行数据
- master发往slave的一个binary log event

但是需要注意的是，如果查询实在是太大，服务端会拒绝接收更多数据并抛出异常。当服务器收到大于 max_allowed_packet 字节的信息包时，将发"信息包过大"错误，并关闭连接。

于某些客户端，如果通信信息包过大，在执行查询期间，可能会遇到"丢失与 MySQL 服务器的连接"错误。


与之相反的是，服务器响应给用户的数据通常会很多，由多个数据包组成。当服务器响应客户端请求时，客户端必须完整的接收整个返回结果，而不能简单的只取前面几条结果，然后让服务器停止发送。

这种情况下，客户端若接收完整的结果，然后取前面几条需要的结果，或者接收完几条结果后就"粗暴"地断开连接，都不是好主意。

因而在实际开发中，**尽量保持查询简单且只返回必需的数据，减小通信间数据包的大小和数量是一个非常好的习惯**。

**这也是查询中尽量避免使用SELECT * 以及加上LIMIT限制的原因之一。** 

>> 引自《高性能 MySQL》。


当客户端从服务器取数据时，看起来是一个拉数据的过程，但实际上是 MySQL 在向客户端推送数据的过程。客户端不断地接收从服务器推送的数据，客户端也没法让服务器停下来。



InnoDB的数据是保存在主键索引上的，所以全表扫描实际上是直接扫描表的主键索引，对于单表超过系统内存的情况，查询会不会把数据都读到内存中导致系统内存耗尽呢？

**显然不会，实际上服务端并不需要保存一个完整的结果集**。取数据和发数据的流程是这样的：

- 获取一行，写到net_buffer中。这块内存的大小是由参数net_buffer_length定义的，默认是16k。

- 重复获取行，直到net_buffer写满，调用网络接口发出去。

- 如果发送成功，就清空net_buffer，然后继续取下一行，并写入net_buffer。

- 如果发送函数返回EAGAIN或WSAEWOULDBLOCK，就表示本地网络栈（socket send buffer）写满了，进入等待。直到网络栈重新可写，再继续发送。

一个查询在发送过程中，占用的MySQL内部的内存最大就是net_buffer_length这么大，并不会达到200G；

socket send buffer 也不可能达到200G（默认定义/proc/sys/net/core/wmem_default），如果 **socket send buffer** 被写满，就会暂停读数据的流程。

也就是说，MySQL 是 **边读边发的**，这个概念很重要。这就意味着，如果客户端接收得慢，会导致MySQL服务端由于结果发不出去，这个事务的执行时间变长。



### MySQL插件体系

MySQL 现在很多模块都是通过`plugin`的方式连接到 MySQL 核心中的，除了大家熟悉的存储引擎都是`Plugin`之外，MySQL 还支持其他类型的`plugin`。


```SQL
select  * from information_schema.plugins  -- where plugin_name like "%daemon%";


```

#### 密码强度插件

在 MySQL 官方文档中，`The Password Validation Component` 应该翻译为组件更为合适，不过实际上都差不多，这里我们就不做过多赘述。

#### 克隆插件



### **连接器/连接管理**


连接器负责跟客户端建立连接、获取权限、维持和管理连接。

客户端使用命令行登陆时连接命令：`mysql -h${ip} -P${port} -u${user} -p${password}`

在完成TCP三次握手之后，连接器就要开始认证身份进行账密校验，校验通过之后，**连接器会到权限表里查询拥有的权限之后在这个连接里的权限判断，SQL执行的权限都依赖于此时读取的权限。**

这就意味着，一个用户成功建立连接后，即使你用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限。修改完成后，**只有再新建的连接才会使用新的权限设置**。


MySQL客户端，当使用默认参数连接的时候，MySQL 客户端会提供一个本地库名和表名补全的功能。


为了实现这个功能，客户端在连接成功后，需要多做一些操作：

- 执行 show databases；
- 切到 db1 库，执行 show tables；
- 把这两个命令的结果用于构建一个本地的哈希表。

在这些操作中，最花时间的就是第三步在本地构建哈希表的操作。所以，当一个库中的表个数非常多的时候，这一步就会花比较长的时间。也就是说，感知到的连接过程慢，其实并不是连接慢，也不是服务端慢，而是客户端慢。

如果在连接命令中加上 -A，就可以关掉这个自动补全的功能，然后客户端就可以快速返回了。

这里自动补全的效果就是，你在输入库名或者表名的时候，输入前缀，可以使用 Tab 键自动补全表名或者显示提示。实际使用中，如果你自动补全功能用得并不多，建议每次使用的时候都默认加 -A。


MySQL 客户端发送请求后，接收服务端返回结果的方式有两种：

一种是本地缓存，也就是在本地开一片内存，先把结果存起来。如果你用 API 开发，对应的就是 mysql_store_result 方法。
另一种是不缓存，读一个处理一个。如果你用 API 开发，对应的就是 mysql_use_result 方法。
MySQL 客户端默认采用第一种方式，而如果加上–quick 参数，就会使用第二种不缓存的方式。

采用不缓存的方式时，如果本地处理得慢，就会导致服务端发送结果被阻塞，因此会让服务端变慢。

为什么要给这个参数取名叫作 quick 呢？

这是因为使用这个参数可以达到以下三点效果：

第一点，跳过表名自动补全功能。

第二点，mysql_store_result 需要申请本地内存来缓存查询结果，如果查询结果太大，会耗费较多的本地内存，可能会影响客户端本地机器的性能；

第三点，是不会把执行命令记录到本地的命令历史文件。
–quick 参数的意思，是让客户端变得更快。


#### MySQL连接线程模型

MySQL是一个 **单进程多线程** 的软件，启动一个 MySQL 实例，操作系统中会使用 mysqld 这个可执行文件来启动一个mysqld进程。

mysqld 通过创建多个线程来服务于不同的用户连接。通常情况下，随着用户连接数的增加，MySQL内部用于处理用户连接的线程也会同步的增加，在一定范围内，增加用户并发连接，对提高系统的吞吐量有一定的帮助，然而用户并发连接数超过某个阈值，MySQL的性能反而会降低。

每个线程至少有两个唯一标识符： 一个是操作系统线程ID， 另一个是MySQL内部线程ID。 

- THREAD_ID:  MySQL内部的线程ID

- PROCESSLIST_ID:  连接ID，每个前台线程都有一个指定的PROCESSLIST_ID连接标识符。我们平时 kill processlist_id 就是这个

- THREAD_OS_ID: 操作系统线程ID

操作系统线程ID可以通过相关工具查看， 如在Linux系统中可使用`ps-eLf`命令查看。 而MySQL内部线程ID在大多数performance_schema表中以THREAD_ID命名。 

此外，每个前台线程都有一个指定的PROCESSLIST_ID： 连接标识符， 在SHOW PROCESSLIST命令输出中

我们打开 htop 或 top 时，如果查看以线程方式查看，就可以看到很多 mysqld 线程。这些就是用于处理客户端连接而创建的线程。

### MySQL线程管理

MySQL是一个单进程多线程的程序，主要分为 BACKGROUND 和 FOREGROUND 线程。可以通过 performance_schema.threads 表查看其线程。

使用 htop 也可以看到 MySQL 服务的各个线程。

#### 后台线程

|                                 |                                                              |      |
| ------------------------------- | ------------------------------------------------------------ | ---- |
| thread/innodb/srv_master_thread | srv_master_thread是最重要的后台主线程，主要负责将缓冲池中的数据异步刷新到磁盘，保证数据的一致性，包括脏页的刷新、合并插入缓冲、UNDO页的回收等。 |      |
|                                 |                                                              |      |
|                                 |                                                              |      |
|                                 |                                                              |      |
|                                 |                                                              |      |
|                                 |                                                              |      |
|                                 |                                                              |      |
|                                 |                                                              |      |
|                                 |                                                              |      |
|                                 |                                                              |      |
|                                 |                                                              |      |
|                                 |                                                              |      |
|                                 |                                                              |      |
|                                 |                                                              |      |
|                                 |                                                              |      |
|                                 |                                                              |      |
|                                 |                                                              |      |




#### 前台线程

MySQL处理用户连接的都是前台线程。可以使用如下语句查看：

```SQL
select * from `performance_schema`.threads where type='FOREGROUND';

SELECT * FROM `information_schema`.PROCESSLIST;
```

MySQL内部处理用户连接的线程调度方式由 `thread_handling` 参数控制。严格来说有三种：

- `no-threads`，单线程处理所有用户连接，一般在调试时使用。
- `one-thread-per-connection` ， 多线程处理用户连接，一个线程对应一个用户连接，也是 `MySQL Community Server` 默认的连接处理方式。主要由 `thread_handling` 参数配置。
- `Thread pool`, 在Percona，MariaDB，Oracle MySQL 企业版，[阿里云polarDB](https://help.aliyun.com/document_detail/206413.htm)，[腾讯数据库](https://cloud.tencent.com/document/product/236/48851)中提中，提供了 **线程池** 特性。

在 `one-thread-per-connection` 情况下，每个连接分配一个线程，当客户端和MySQL服务器建立TCP连接之后，MySQL服务器就会给这个连接分配一个线程，当这个连接收到SQL时，对应的线程就执行这个SQL，而当SQL执行结束后，这个线程就去Sleep，等待客户端的新请求。这个线程会一直存活，直到客户端退出登录或线程超时断开（由wait_timeout或interactive_timeout参数控制，），并关闭连接，这个线程才会退出（或者进入MySQL的ThreadCache）。

超时参数，详见 https://zhuanlan.zhihu.com/p/82554484



MySQL 连接方式有很多种，区分Unix系统 和 Windows 系统以及通用的连接方式，在这里仅说两种方式：

- 一种为 `unix domain socket`

- 另外一种为基于 `tcp/ip` 协议，一般我们如果远程访问数据库肯定是基于 `tcp/ip` 的，但是如果我们在本机登录就会分为使用 socket 还是 tcp/ip。

```txt
Copysocket：mysql -uroot -p
tcp/ip：mysql -h127.0.0.1 -uroot -p
```

当数据库服务器和应用服务器位于不同的主机时就要使用 tcp/ip 的方式建立连接。每一个连接在操作系统中占用一个线程来维护。

建立连接也分为两类：**短连接**和**长连接**：



**短连接**

所谓短连接就是指应用程序和数据库通信完毕之后连接关闭。这种连接每次的操作就是：

```
发出请求--->建立连接--->操作数据--->释放连接
```

这样做的问题是：

1. 频繁的建立 / 释放连接对数据库来说增加了系统负担，频繁创建/销毁线程**增加数据库服务器CPU上下文切换开销，影响数据库服务器性能。**；

2. 应用程序每次操作数据库的过程将会变得很慢，**tcp三次握手四次断开要时间开销的**；

3. 应用系统每次建立连接都要占用一个端口，频繁的建立/释放，每个被释放的连接在发出释放请求之后并不是马上就执行，必须经历一个 FIN 阶段的等待直到确认为止。所以在每秒几千次数据库请求的时候，应用服务器端口很有可能被消耗完。

   

**长连接**

长连接即在建立连接后一直打开，直到应用程序关闭才释放。使用长连接的好处是减少每次创建连接带来的开销。

对于客户端来说维持长连接的好处不言自明，但是对于数据库服务器来说，过多的长连接则是灾难。

如果滥用长连接的话，可能会使用过多的MySQL服务器连接。现代的操作系统可以拥有几千个MySQL连接，但很有可能绝大部分都是睡眠（sleep）状态的，这样的工作方式不够高效，而且连接占据内存，也会导致内存的浪费。

MYSQL的TCP连接支持长连接，所以每次操作完数据库，可以不必直接关掉连接，而是等待下次使用的时候在复用这个连接。

所有的Socket长连接都是通过TCP自带的ping来维持心跳(TCP保活)，从而保持连接状态，而我们熟悉的`websocket`,也正是通过TCP的心跳来维持连接不被中断。



**连接池**

长连接的好处这么大，自然大家都用长连接。慢慢就搞出一套长连接维护的工具 - 数据库连接池。

设计连接池也没有多么复杂，大致的步骤就是：

1. 初始化连接；
2. 业务取出连接；
3. 业务发送请求；
4. 放回连接。

除了上面的基本功能以外，还要处理并发问题，多数据库服务器和多用户，事务处理，连接池的配置与维护。

大概就这些功能。有了连接池（在服务端，有时候叫线程池）之后，连接的建立和释放跟业务就没有关系，交给交接池来维护。

[参考](https://xmmarlowe.github.io/2021/05/21/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E9%95%BF%E8%BF%9E%E6%8E%A5%E3%80%81%E7%9F%AD%E8%BF%9E%E6%8E%A5%E3%80%81%E8%BF%9E%E6%8E%A5%E6%B1%A0/)

**对此，研发工程师、系统运维工程师、DBA需要保持沟通，确定合理的连接策略，千万不要不假思索就采用长连接。**




MySQL的最大连接数由 `max_connections` 参数控制，在5.7和8.0中默认是151，最大可以达到16384（2^14）。

对于海量连接的数据库，如果设置的太小，连接满了之后后面的新连接就会报`too many connections`。


MySQL Server其实默认允许的最大客户端连接数为 max_connections + 1 ，这其中额外可以登陆的1一个连接仅仅允许拥有super权限的用户进行连接。

MySQL如此设计其实是为了当数据库出现连接数打满的情况下，可以使用同时拥有super、process权限的高权限数据库账号登陆数据库，将问题会话或者一些空闲连接进行kill，紧急处理故障。所以通常避免让业务账号具备super和process的管理权限。


在MySQL8.0里，则引入了admin port的概念，顾名思义，就是单独开一个端口给管理员用，该特性从8.0.14开始引入。这个需要单独设置。
可以说这是个对运维非常有用，关键时候可以救命的特性。这个feature由facebook贡献给上游。主要包括以下几个参数设置：

```shell

# admin_address: 用于指定管理员发起tcp连接的主机地址，可以是ipv4,ipv6, 或者Host name等等，但只能接受一个ip地址
# admin_port: 是管理员用来连接的端口号，默认是33062。注意如果admin_address没有设置的话，这个端口号是无效的
# create_admin_listener_thread: 是否创建一个单独的listener线程来监听admin的链接请求，默认值是关闭的，即会使用已有的监听线程去监听admin连接。该参数同样需要admin_address打开, 否则没有任何影响

# 通常建议这样设置。让mysql内部单独开启一个listener线程来监听127.0.0.0。紧急情况连接用满了，可以在服务器上本地用管理端口连接。
admin_address='localhost'
create_admin_listener_thread=1


mysql -u root -P 33062 --protocol tcp -p'zhtj6668182'
```






**基于此，数据库账号权限一定要做好明确的规划，业务账号仅仅拥有对应业务数据库的读写权限、高权限数据库账号用于运维管理。**


MySQL 官网给出了一个最大连接数推荐计算方式，`Max_used_connections / max_connections * 100% ≈ 85%`



MySQL的 **状态变量** 显示MySQL服务实例的运行状态信息，这些状态信息是动态的，包括MySQL服务器连接的会话状态、变量信息等。默认情况下状态变量都是以大写字母开头。

```shell
show status;
show session status;
show global status;
```

| 状态变量                          | 含义                                                         |
| --------------------------------- | ------------------------------------------------------------ |
| Connections                       | 状态变量：MySQL服务从初始化开始成功建立连接的数量，该值不断累加 |
| Max_used_connections              | 状态变量：MySQL服务从启动开始，同一时刻并发连接的最大值，如果该值很大，则有可能系统并发较高，可以考虑调大max_connections |
| Connection_errors_max_connections | 状态变量：当MySQL的最大并发连接数超过设置的max_connections变量的值，被拒绝的次数会记录到这个状态值里 |
| Threads_connected                 | 状态变量： MySQL server当前打开的连接数                      |

### 控制参数

| 配置                 | 含义                                                         |
| -------------------- | ------------------------------------------------------------ |
| max_connections      | 配置参数：MySQL server层面限制**总的所有账号一起**最大的可连接的数量，默认151，最大值为100000 |
| max_user_connections | 配置参数：代表允许单个用户的连接数最大值，即并发值。默认为0，表示不限制 |
| wait_timeout         | 配置参数：即MySQL长连接(非交互式)的最大生命时长，默认是8小时，根据业务特点配置 |
| interactive_timeout  | 配置参数：即MySQL长连接长连接(交互式)的最大生命时长，默认是8小时，根据业务特点配置 |
| connect_timeout      | 配置参数：获取MySQL连接是多次握手的结果，除了用户名和密码的匹配校验外，还有IP->HOST->DNS->IP验证，任何一步都可能因为网络问题导致线程阻塞。为了防止线程浪费在不必要的校验等待上，超过connect_timeout的连接请求将会被拒绝。默认是10秒 |

#### 线程缓存

线程缓存实现在MySQL server端，client连接之后对应的sql线程在服务端会被缓存起来，缓存的线程数量由 [thread_cache_size](https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_thread_cache_size) 大小决定。

当服务器不断有大量连接创建、关闭的场景下，使用线程缓存能够重用缓存起来的线程，避免了大量连接线程的反复创建销毁带来的CPU上下文切换性能消耗，但是仍然无法解决高连接数带来的线程数过高的问题。

```shell
# 查看线程缓存大小
show global variables like 'thread_cache_size';


# thread_stack: 每个连接线程被创建时，MySQL给它分配的内存大小。当MySQL创建一个新的连接线程时，需要给它分配一定大小的内存堆栈空间，以便存放客户端的请求的Query及自身的各种状态和处理信息。
# Thread Stack默认值（192KB）足够正常运行。如果线程堆栈大小太小，则会限制服务器可以处理的SQL语句的复杂性，存储过程的递归深度以及其他消耗内存的操作。一般情况下都能正常使用，但是当查询语句或者存储过程复杂时会报Threadstack overrun（超限）错误，此时只要修改增加默认配置就可以了
show VARIABLES like 'thread_stack'

# 系统启动到现在共接受到客户端的连接次数
show status like 'connections'


# 可以通过如下几个MySQL状态值来适当调整线程池的大小
show global status like 'Threads_%';
```

| 配置              | 含义                                                         |
| ----------------- | ------------------------------------------------------------ |
| Threads_cached    | 状态变量：当前线程池中缓存有多少空闲线程                     |
| Threads_connected | 状态变量：当前的连接数 ( 也就是线程数 )                      |
| Threads_created   | 状态变量：开启以来累计已经创建过的线程总数                                 |
| Threads_running   | 状态变量：当前激活的线程数 ( Threads_connected 中的线程有些可能处于休眠状态 ) |



#### 主机缓存

MySQL 服务会在内存中维护 `host cache` ，`host cache` 包含很多关于**客户端**的信息：IP，地址，主机名，和错误信息。

`host cache` 的内容是公开的，可以用 `select` 语句进行查询，以便诊断当前的连接问题.

```
select * from performance_schema.host_cache ; 


```

> 提示：
>
> host cache仅用于非localhost的tcp连接：对于 loopback 环回地址的tcp连接，或者socket file连接，命名管道，共享内存等。
>
> 执行flush hosts可以刷新host_cache，刷新后会清除内存中的主机缓存





1. 当有一个新的客户端连接进来时，MySQL Server会为这个IP在host cache中建立一个新的记录，包括IP，主机名和client lookup validation flag，分别对应host_cache表中的IP，HOST和HOST_VALIDATED这三列。第一次建立连接因为只有IP，没有主机名，所以HOST将设置为NULL，HOST_VALIDATED将设置为FALSE。

2. MySQL Server检测HOST_VALIDATED的值，如果为FALSE，它会试图进行**DNS反向解析**，如果解析成功，它将更新HOST的值为主机名，并将HOST_VALIDATED值设为TRUE。如果没有解析成功，判断失败的原因是永久的还是临时的，如果是永久的，则HOST的值依旧为NULL，且将HOST_VALIDATED的值设置为TRUE，后续连接不再进行解析，如果该原因是临时的，则HOST_VALIDATED依旧为FALSE，后续连接会再次进行DNS解析。



解析成功的标志并不只是通过IP，获取到主机名即可，这只是其中一步，还有一步是通过解析后的主机名来反向解析为IP，判断该IP是否与原IP相同，如果相同，才判断为解析成功，才能更新host cache中的信息。



缺点：当有一个新的客户端连接进来时，MySQL Server都要建立一个新的记录，如果DNS解析很慢，无疑会影响性能。如果被允许访问的主机很多，也会影响性能，这个与host_cache_size有关，这个参数是5.6.5引入的。5.6.8之前默认是128,5.6.8之后默认是-1,基于max_connections的值动态调整。所以如果被允许访问的主机很多，基于LRU算法，先前建立的连接可能会被挤掉，这些主机重新进来时，会再次进行DNS查询。

优点：通常情况下，主机名是不变的，而IP是多变的。如果一个客户端的IP经常变化，那基于IP的授权将是一个繁琐的过程。因为你很难确定IP什么时候变化。而基于主机名，只需一次授权。而且，基于host cache中的失败信息，可在一定程度上阻止外界的暴力破解攻击。



[参考](https://www.cnblogs.com/ivictor/p/5311607.html)



### MySQL线程池

在线程池方案下，通常在MySQL server服务端实现，MySQL 通过预先创建一定数量的线程，在监听到有新的请求时，线程池直接从现有的线程中分配一个线程来提供服务，服务结束后这个线程不会直接销毁，而是又去处理其他的请求。

这样就避免了线程和内存对象频繁创建和销毁，减少了上下文切换，提高了资源利用率，从而在一定程度上提高了系统的性能和稳定性。

**线程池技术限制了并发线程数，相当于限制了MySQL的runing线程数，无论系统目前有多少连接或者请求，超过最大设置的线程数的都需要排队，让系统保持高性能水平，从而防止DB出现雪崩，对底层DB起到保护作用。**

> Thread pool，在Percona，MariaDB，Oracle MySQL企业版，以及阿里云polarDB中提中，提供了**线程池**特性。

### MySQL连接池

MySQL连接池，连接池通常实现在client端，是指应用(客户端)预先创建一定的连接，利用这些连接服务于客户端所有的DB请求。如果某一个时刻，空闲的连接数小于DB的请求数，则需要将请求排队，等待空闲连接处理。

通过连接池的连接复用，避免连接的频繁创建和释放，从而减少请求的平均响应时间，并且在请求繁忙时，通过请求排队，可以缓冲应用对DB的冲击。常见的MySQL连接池Tomcat、WildFly(JBoss)、 c3p0、 Druid等。

在很多公司，有不少程序员写代码，懒得用数据库连接池，所以就在每次数据操作时，临时连接数据库，使用完后直接关闭，这显然不好。 


[MySQL线程池与连接池](https://fengzhao.notion.site/MySQL-c5d5f4871cca4ea3ac434fa826095a1c)



### 线程处理和线程事务

```sql
-- 查看所有连接线程，其中ID为线程ID
SELECT * FROM information_schema.`PROCESSLIST` 

-- 在MySQL中有两个kill命令：
-- 一个是kill query +线程id，表示终止这个线程中正在执行的语句；
-- 一个是kill connection +线程id，这里connection可缺省，表示断开这个线程的连接，当然如果这个线程有语句正在执行，也是要先停止正在执行的语句的。

-- 经常遇到使用了kill命令，却没能断开这个连接。再执行show processlist命令，看到这条语句的Command列显示的是Killed


-- 大多数情况下，kill query/connection 命令是有效的。比如，执行一个查询的过程中，发现执行时间太久，要放弃继续查询，这时就可以用 kill query 命令，终止这条查询语句。还有一种情况是，语句处于锁等待的时候，直接使用 kill 命令也是有效的。


-- 1、超大事务执行期间被 kill。这时候，回滚操作需要对事务执行期间生成的所有新数据版本做回收操作，耗时很长。大查询回滚。如果查询过程中生成了比较大的临时文件，加上此时文件系统压力大，删除临时文件可能需要等待 IO 资源，导致耗时较长。


-- 2、DDL 命令执行到最后阶段，如果被 kill，需要删除中间过程的临时文件，也可能受 IO 资源影响耗时较久。

-- 查看事务执行情况，其中trx_id为事务ID，trx_mysql_thread_id为线程ID
SELECT * FROM information_schema.INNODB_TRX;

```

收到 kill 以后，线程做什么？


在全局锁和表锁中，当对一个表做增删改查操作时，会在表上加 MDL 读锁。所以，session B 虽然处于 blocked 状态，但还是拿着一个 MDL 读锁的。

如果线程被 kill 的时候，就直接终止，那之后这个 MDL 读锁就没机会被释放了。这样看来，kill 并不是马上停止的意思，而是告诉执行线程说，这条语句已经不需要继续执行了，可以开始“执行停止的逻辑了”。

其实，这跟 Linux 的 kill 命令类似，kill -N pid 并不是让进程直接停止，而是给进程发一个信号，然后进程处理这个信号，进入终止逻辑。只是对于 MySQL 的 kill 命令来说，不需要传信号量参数，就只有“停止”这个命令。

1. 一个语句执行过程中有多处“埋点”，在这些“埋点”的地方判断线程状态，如果发现线程状态是 THD::KILL_QUERY，才开始进入语句终止逻辑；

2. 如果处于等待状态，必须是一个可以被唤醒的等待，否则根本不会执行到“埋点”处；

3. 语句从开始进入终止逻辑，到终止逻辑完全完成，是有一个过程的。



### **查询缓存**

MySQL 的查询，主要处理过程都是从硬盘中读取数据加载到内存，然后通过网络发给客户端，

MySQL 以前有一个查询缓存 Query Cache，从 MySQL8.0 开始，不再使用这个查询缓存，随着技术的进步，经过时间的考验，MySQL的工程团队发现启用缓存的好处并不多。所以在 8.0 中移除了这个特性。

在解析一个查询语句前，如果查询缓存是打开的，那么MySQL会检查这个查询语句是否命中查询缓存中的数据。如果当前查询恰好命中查询缓存，在检查一次用户权限后直接返回缓存中的结果。

这种情况下，查询不会被解析，也不会生成执行计划，更不会执行。

MySQL将缓存存放在一个引用表（不要理解成table，可以认为是类似于HashMap的数据结构），通过一个哈希值索引，这个哈希值通过查询本身、当前要查询的数据库、客户端协议版本号等一些可能影响结果的信息计算得来。

**所以两个查询在任何字符上的不同（例如：空格、注释），都会导致缓存不会命中。如果查询中包含任何用户自定义函数、存储函数、用户变量、临时表、mysql库中的系统表，其查询结果都不会被缓存。**

**比如函数 NOW() 或者 CURRENT_DATE() 会因为不同的查询时间，返回不同的查询结果。再比如包含 CURRENT_USER 或者 CONNECION_ID() 的查询语句会因为不同的用户而返回不同的结果，将这样的查询结果缓存起来没有任何的意义。**

既然是缓存，就会失效，那查询缓存何时失效呢？

MySQL的查询缓存系统会跟踪查询中涉及的每个表，如果这些表（数据或结构）发生变化，那么和这张表相关的所有缓存数据都将失效。

正因为如此，在任何的写操作时，MySQL必须将对应表的所有缓存都设置为失效。如果查询缓存非常大或者碎片很多，这个操作就可能带来很大的系统消耗，甚至导致系统僵死一会儿。

而且查询缓存对系统的额外消耗也不仅仅在写操作，读操作也不例外：

1. 任何的查询语句在开始之前都必须经过检查，即使这条SQL语句永远不会命中缓存
2. 如果查询结果可以被缓存，那么执行完成后，会将结果存入缓存，也会带来额外的系统消耗

首先，查询缓存的效果取决于缓存的命中率，只有命中缓存的查询效果才能有改善，因此无法预测其性能。

其次，查询缓存的另一个大问题是它受到单个互斥锁的保护。在具有多个内核的服务器上，大量查询会导致大量的互斥锁争用。

通过基准测试发现，大多数工作负载最好禁用查询缓存（5.6的默认设置）：query_cache_type = 0

如果你认为会从查询缓存中获得好处，请按照实际情况进行测试。

- 数据写的越多，好处越少
- 缓冲池中容纳的数据越多，好处越少
- 查询越复杂，扫描范围越大，则越受益

==**最后的忠告是不要轻易打开查询缓存，特别是写密集型应用。**==

如果你实在是忍不住，可以将query_cache_type设置为DEMAND，这时只有加入SQL_CACHE的查询才会走缓存，其他查询则不会，这样可以非常自由地控制哪些查询需要被缓存。

对于一些热点数据，现在比较流行的做法是引入外部的缓存中间件，比如 redis 等，这个以后展开再讲。

### **语法解析和预处理**

MySQL通过关键字将SQL语句进行解析，并生成一颗对应的解析树。这个过程解析器主要通过语法规则来验证和解析。

比如SQL中是否使用了错误的关键字或者关键字的顺序是否正确等等。预处理则会根据MySQL规则进一步检查解析树是否合法。比如检查要查询的数据表和数据列是否存在等等。

### **查询优化**

经过前面的步骤生成的语法树被认为是合法的了，并且由优化器将其转化成查询计划。

==多数情况下，一条查询可以有很多种执行方式，最后都返回相应的结果。优化器的作用就是找到这其中最好的执行计划。==

MySQL采用了基于开销成本的优化器，以确定处理查询的最解方式，也就是说执行查询之前，都会先选择一条自以为最优的方案，然后执行这个方案来获取结果。

在很多情况下，MySQL能够计算最佳的可能查询计划，但在某些情况下，MySQL没有关于数据的足够信息，或者是提供太多的相关数据信息，估测就不那么友好了。

**对于一些执行起来十分耗费性能的语句，MySQL 还是依据一些规则，竭尽全力的把这个很糟糕的语句转换成某种可以比较高效执行的形式，这个过程也可以被称作查询重写**。

**它尝试预测一个查询使用某种执行计划时的成本，并选择其中成本最小的一个。**

基于成本的优化器将枚举可能的执行计划，并为每个计划分配成本，成本是执行该计划所需的时间和资源的估计值。

一旦这些可能性被列举出来，优化器就会选择成本最低的计划并将其交付执行。虽然成本模型通常被设计为最大化吞吐量（即每秒查询），但它也可以被设计为支持其他期望指标的查询行为，例如最小化延迟（即检索第一行的时间）或最小化内存使用。



> CBO(Cost-Based Optimization)
> 
> CBO: Cost-Based Optimization也即"基于代价的优化器"，该优化器通过根据优化规则对关系表达式进行转换，生成多个执行计划，然后CBO会通过根据统计信息(Statistics)和代价模型(Cost Model)计算各种可能“执行计划”的“代价”，即COST，从中选用COST最低的执行方案，作为实际运行方案。
> 
> CBO依赖数据库对象的统计信息，统计信息的准确与否会影响CBO做出最优的选择。
> 
> 以Oracle数据库为例，统计信息包括SQL执行路径的I/O、网络资源、CPU的使用情况。
> 
> 目前各大数据库和大数据计算引擎都倾向于使用CBO，例如从Oracle 10g开始，Oracle已经彻底放弃RBO，转而使用CBO；而Hive在0.14版本中也引入了CBO。


#### 优化器和查询成本

一般来说一个sql查询可以有不同的执行方案，可以选择走某个索引进行查询，也可以选择全表扫描。


SQL优化器，其中最重要的一个组件是查询优化器，是数据库系统的重要组成部分。特别是对于现代大数据系统，执行计划的搜索空间异常庞大，研究人员研究了许多方法对执行计划空间进行裁剪，以减少搜索空间的代价。

在当今数据库系统领域，查询优化器可以说是必备组件，不管是关系型数据库系统Oracle、MySQL，流处理领域的Flink、Storm，批处理领域的Hive、Spark SQL，还是文本搜索领域的Elasticsearch等，都会内嵌一个查询优化器。

有的数据库系统会采用自研的优化器，而有的则会采用开源的查询优化器插件，比如Apache Calcite就是一个优秀的开源查询优化器插件。而像Oracle数据库的查询优化器，则是Oracle公司自研的一个核心组件，负责解析SQL，其目的是按照一定的原则来获取目标SQL在当前情形下执行的最高效执行路径。

[参考](https://www.cnblogs.com/JasonCeng/p/14199298.html)


**查询优化器** 则会比较并选择其中成本最低的方案去执行查询。





查询成本分大体为两种：

- **I/O成本**：磁盘读写的开销。一个查询或一个写入，都要从磁盘中读写数据，要一定的IO开销。

- **CPU成本**：关联查询，条件查找，都要CPU来进行计算判断，一定的计算开销。

MySQL使用的InnoDB引擎会把数据和索引都存储到磁盘上，当查询的时候需要先把数据先加载到内存中在进行下一步操作，这个加载的时间就是I/O成本。

当数据被加载到内存中后，CPU会计算查询条件匹配，对数据排序等等操作，这一步所消耗的时间就是CPU成本。

**但是查询优化器并不会真正的去执行sql，只会去根据优化的结果去预估一个成本。**

==**InnoDB引擎规定读取一个页面花费的成本默认约是0.25，读取以及检测一条记录是否符合搜索条件的成本默认约是0.1。**==

为什么都是约呢，因为MySQL内部的计算成本比较复杂这里提取了两个主要的计算参数。

```sql
## MySQL server 层面的各种开销
mysql> select * from mysql.server_cost;
+------------------------------+------------+---------------------+---------+---------------+
| cost_name                    | cost_value | last_update         | comment | default_value |
+------------------------------+------------+---------------------+---------+---------------+
| disk_temptable_create_cost   |       NULL | 2021-09-24 14:47:20 | NULL    |            20 |
| disk_temptable_row_cost      |       NULL | 2021-09-24 14:47:20 | NULL    |           0.5 |
| key_compare_cost             |       NULL | 2021-09-24 14:47:20 | NULL    |          0.05 |
| memory_temptable_create_cost |       NULL | 2021-09-24 14:47:20 | NULL    |             1 |
| memory_temptable_row_cost    |       NULL | 2021-09-24 14:47:20 | NULL    |           0.1 |
| row_evaluate_cost            |       NULL | 2021-09-24 14:47:20 | NULL    |           0.1 |
+------------------------------+------------+---------------------+---------+---------------+
6 rows in set (0.00 sec)

mysql>

## MySQL 存储引擎层面的各种开销
mysql> select * from mysql.engine_cost;
+-------------+-------------+------------------------+------------+---------------------+---------+---------------+
| engine_name | device_type | cost_name              | cost_value | last_update         | comment | default_value |
+-------------+-------------+------------------------+------------+---------------------+---------+---------------+
| default     |           0 | io_block_read_cost     |       NULL | 2021-09-24 14:47:20 | NULL    |             1 |
| default     |           0 | memory_block_read_cost |       NULL | 2021-09-24 14:47:20 | NULL    |          0.25 |
+-------------+-------------+------------------------+------------+---------------------+---------+---------------+
2 rows in set (0.00 sec)

mysql>
```


在 MySQL 可以通过查询当前会话的 last_query_cost 的值来得到其计算当前查询的成本。

```sql
 mysql> select * from t_message limit 10;
 ...省略结果集
 
 mysql> show status like 'last_query_cost';
 +-----------------+-------------+
 | Variable_name   | Value       |
 +-----------------+-------------+
 | Last_query_cost | 6391.799000 |
 +-----------------+-------------+
 ————————————————
```

示例中的结果表示优化器认为大概需要做 6391 个数据页的随机查找才能完成上面的查询。

这个结果是根据一些列的统计信息计算得来的，这些统计信息包括：每张表或者索引的页面个数、索引的基数、索引和数据行的长度、索引的分布情况等等。

有非常多的原因会导致 MySQL 选择错误的执行计划，比如统计信息不准确、不会考虑不受其控制的操作成本（用户自定义函数、存储过程）。

**MySQL认为的最优跟我们想的不一样（我们希望执行时间尽可能短，但 MySQL 选择它认为成本小的，但成本小并不意味着执行时间短）等等。**


#### 优化器追踪

MySQL优化器可以生成Explain执行计划，我们可以通过执行计划查看是否使用了索引，使用了哪种索引？

但是它只能展示 SQL 语句的执行计划，无法展示为什么一些其他的执行计划未被选择，比如说明明有索引，但是为什么查询时未使用索引等。

好在MySQL提供了一个好用的工具 — optimizer trace（优化器追踪），可以帮助我们查看优化器生成执行计划的整个过程，以及做出的各种决策，包括访问表的方法、各种开销计算、各种转换等。

众所周知，MySQL是基于成本的优化器（CBO），每个执行计划的成本大致反应了该计划查询所需要的资源。

CBO选择目标SQL执行计划的判断原则是成本，从目标SQL的诸多执行计划中选取成本值最小的执行路径为其执行计划，各执行路径的成本值是根据目标SQL中涉及到的表、索引、列等相关对象的统计信息计算出来的，实际反应执行目标SQL所要消耗的I/O、CPU和网络资源的一个估计值。

优化器会为每个操作标上成本，这些成本的基准单位或最小值是从磁盘读取随机数据页的成本，其他操作的成本都是它的倍数。所以优化器可以根据每个执行计划的所有操作为其计算出总的成本，然后从众多执行计划中，选取成本最小的来最终执行。


```SQL

CREATE TABLE `user` (
	`id` int NOT NULL AUTO_INCREMENT COMMENT '主键',
	`name` varchar(100) NOT NULL COMMENT '姓名',
	`gender` tinyint NOT NULL COMMENT '性别',
	PRIMARY KEY (`id`),
	KEY `idx_name` (`name`),
	KEY `idx_gender_name` (`gender`,`name`)
) ENGINE=InnoDB COMMENT='用户表';

INSERT INTO  user(id,name,gender)  VALUES
	(1,'小明',1),
	(2,'小黄',1),
	(3,'关羽',1),
	(4,'张飞',0),
	(5,'曹操',1),
	(6,'刘备',0),
	(7,'孙悟空',1),
	(8,'林冲',1),
	(9,'李白',0),
	(19,'李四',1),
	(10,'小强',1),
	(11,'刘婵',1),
	(12,'赵芸',1),
	(13,'惠月',1),
	(14,'景逸',1),
	(15,'小黄',1),
	(16,'思峰',1),
	(17,'伏尔泰',1),
	(18,'雨果',1),
	(20,'贝多芬',1),
	(21,'小明',1),
	(22,'小明',1),
	(23,'小明',1),
	(24,'小明',1),
	(25,'小明',1),
	(26,'小明',1),
	(27,'小明',1),
	(28,'小明',1);

--这条语句用的是`idx_gender_name`这个联合索引	
explain select * from user  where gender=1 and name='小明';

--这条语句用的是`idx_name`这个索引	
explain select * from user  where gender=0 and name='张三';



-- 同一条SQL因为传参不同，而使用了不同的索引。
-- 到这里，使用现有工具，我们已经无法排查分析，MySQL优化器为什么使用了(name)上的索引，而没有使用(gender,name)上的联合索引。
```



相关变量

```sql
mysql> show variables like '%optimizer_trace%';
+------------------------------+----------------------------------------------------------------------------+
| Variable_name                | Value                                                                      |
+------------------------------+----------------------------------------------------------------------------+
| optimizer_trace              | enabled=off,one_line=off                                                   |
| optimizer_trace_features     | greedy_search=on,range_optimizer=on,dynamic_range=on,repeated_subselect=on |
| optimizer_trace_limit        | 1                                                                          |
| optimizer_trace_max_mem_size | 1048576                                                                    |
| optimizer_trace_offset       | -1                                                                         |
+------------------------------+----------------------------------------------------------------------------+
5 rows in set (0.00 sec)
mysql> 

-- 可用SET语句操作，用如下命令即可打开OPTIMIZER TRACE
SET OPTIMIZER_TRACE="enabled=on",END_MARKERS_IN_JSON=on;
-- 即使全局开启OPTIMIZER_TRACE，每个Session也只能跟踪它自己执行的语句
SET GLOBAL OPTIMIZER_TRACE="enabled=on",END_MARKERS_IN_JSON=on;
-- 默认情况下，由于optimizer_trace_offset=-1，optimizer_trace_limit=1，记录最近的一条SQL语句，展示时，每次展示1条数
SET optimizer_trace_offset=<OFFSET>, optimizer_trace_limit=<LIMIT>


-- 开启OPTIMIZER_TRACE功能，并设置要展示的数据条目数
SET OPTIMIZER_TRACE="enabled=on",END_MARKERS_IN_JSON=on;
SET optimizer_trace_offset=-30, optimizer_trace_limit=30;


-- 发送你想要分析的SQL语句
-- SELECT * FROM users;

-- 查看分析结果
SELECT * FROM INFORMATION_SCHEMA.OPTIMIZER_TRACE limit 30;
```


optimizer_trace

- enabled：启用/禁用optimizer_trace功能。默认关闭，也建议关闭，因为它会产生额外的性能开销。根据相关评测，当打开`optimizer trace`时，约有不到10%的性能下降。

- one_line：决定了跟踪信息的存储方式，为on表示使用单行存储，否则以JSON树的标准展示形式存储。










在Optimizer Trace的输出中，主要分为三个部分:

- join_preparation    SQL准备阶段

    完成SQL的准备工作，在这个阶段，SQL语句会被格式化输出，通配符*会被具体字段代替，但不会进行等价改写动作。

- join_optimization   SQL优化阶段

    完成SQL语句的逻辑与物理优化的过程，这其中的优化步骤比较多。在展开具体内容之前，先解释下”select #”的问题。在输出中经常会看到有”select#:N”的字样，它表示当前跟踪的结构体是属于第几个SELECT。如果语句中使用多个SELECT语句拼接（如UNION）或者有嵌套子查询中有SELECT，会产生多个序号。

- join_execution      SQL执行阶段

#### 统计数据


既然是基于统计数据来进行标记成本，就总会有样本无法正确反映整体的情况，这也是 MySQL 优化器有时做出错误优化的重要原因之一。


MySQL统计信息是指数据库通过采样、统计出来的表、索引的相关信息，例如，表的记录数、聚集索引 page 个数、字段的Cardinality....。

MySQL在生成执行计划时，需要根据索引的统计信息进行估算，计算出最低代价（或者说是最小开销）的执行计划，MySQL支持有限的索引统计信息，因存储引擎不同而统计信息收集的方式也不同。

根据统计数据是否可以持久化，MySQL提供了两种统计方式：

- **统计数据存储在磁盘上。** 

- 统计数据存储在内存中，当服务器关闭时这些这些统计数据就都被清除掉了。　　

MySQL给我们提供了系统变量innodb_stats_persistent来控制到底采用哪种方式去存储统计数据。

```shell
# 在MySQL 5.6.6之前，innodb_stats_persistent的值默认是OFF，InnoDB的统计数据默认是存储到内存的
innodb_stats_persistent=OFF
# 在MySQL 5.6.6之后，innodb_stats_persistent的值默认是ON，InnoDB的统计数据默认是存储到磁盘中
innodb_stats_persistent=ON
```



InnoDB默认是以表为单位来收集和存储统计数据的，也就是说我们可以把某些表的统计数据（以及该表的索引统计数据）存储在磁盘上，把另一些表的统计数据存储在内存中。

我们可以在创建和修改表的时候通过指定(STATS_PERSISTENT,STATS_AUTO_RECALC,STATS_SAMPLE_PAGES)属性来指明该表的统计数据存储方式，以及其他属性。

```SQL
CREATE TABLE table1 (...) Engine=InnoDB, STATS_PERSISTENT = (1|0);
ALTER TABLE table2 Engine=InnoDB, STATS_PERSISTENT = (1|0);
```

持久化的统计数据存储在 `mysql.innodb_index_stats` 和 `mysql.innodb_table_stats` 中：



- database_name 数据库名
- table_name 表名
- last_update 本条记录最后更新时间
- n_rows 表中记录的条数
- clustered_index_size 表的聚簇索引占用的页面数量
- sum_of_other_index_sizes 表的其他索引占用的页面数量

在InnoDB存储引擎下，其对表中记录数量的统计值n_rows是不准确的。其统计方法是先通过算法选取若干个(聚簇索引的)叶子节点页面，然后计算叶子节点页面中记录数量的均值，最后将均值乘以(聚簇索引的)叶子节点的数量得到n_rows值。故其不是一个精确值，而是一个估计值。

在计算均值过程中，如果选取的叶子节点越多，则n_rows值越准确。故在MySQL中，可通过系统变量`innodb_stats_persistent_sample_pages`来设置在计算永久性的统计数据时统计过程所需的页面采样数量。显然`innodb_stats_persistent_sample_pages`值越大，统计过程所需耗时也就越多。


##### 更新统计数据

当系统变量innodb_stats_auto_recalc值为ON，即可实现统计数据的自动更新。具体地，一般当表中变化的记录数超过一定阈值，MySQL会自动开始重新进行统计。只不过该统计是异步的，所以即使满足重新统计的条件也不会立即开始计算，有可能会延迟几秒才开始

前面我们说了，统计数据是以表为单位进行统计的，故我们还可以通过STATS_AUTO_RECALC属性来显式地设置表是否自动更新统计数据。具体地，当值为0意为不会进行自动更新；当值为1意为会进行自动更新。更多地，我们一般很少会在建表时指定该属性，则该表就默认使用我们上面提到的系统变量innodb_stats_auto_recalc的配置

#### **优化器的功能**

1. 不改变语义的情况下，重写sql。重写后的 sql 更简单，更方便制定执行计划。
2. 根据成本分析，制定执行计划。

```sql
SELECT @@optimizer_switch;

index_merge=on,
index_merge_union=on,
index_merge_sort_union=on,
index_merge_intersection=on,
engine_condition_pushdown=on
index_condition_pushdown=on,
mrr=on,
mrr_cost_based=on,
block_nested_loop=on,
batched_key_access=off,
materialization=on,
semijoin=on,
loosescan=on,
firstmatch=on,
duplicateweedout=on,
subquery_materialization_cost_based=on,
use_index_extensions=on,
condition_fanout_filter=on,
derived_merge=on,
use_invisible_indexes=off,
skip_scan=on,
hash_join=on


-- 修改优化器
SET [GLOBAL|SESSION] optimizer_switch='command[,command]...';

-- command语法如下：
-- default          --重置为默认
-- opt_name=default	--选项默认 
-- opt_name=off	    --关掉某项优化
-- opt_name=on	    --开启某项优化

```


举个例子，数据库中有个概念叫**谓词下推**

==谓词下推的基本思想是将过滤表达式尽可能移动至靠近数据源的位置，以使真正执行时能直接跳过无关的数据。==



在传统数据库的查询系统中谓词下推作为优化手段很早就出现了，谓词下推的目的就是通过将一些过滤条件尽可能的在最底层执行可以减少每一层交互的数据量，从而提升性能。例如下面这个例子：

```SQL
select count(1) from A Join B on A.id = B.id where A.a > 10 and B.b < 100;

-- 对于这个SQL语句，在MySQL内部，大概可以有两种方式执行，一种是分别对A和B全表扫描并关联查询出结果集，再对结果集分别进行按照 where 条件过滤，最终得出结果。显然这个效率不高，表关联的开销是很大的。

-- 第二种方式，先分别对两个表按照where查找后，分别生成临时的结果集，然后再关联查询，可以大大降低Join操作的输入数据量。优化后的SQL如下：

select count(1) from (select *  from A  where a>10)A1 Join (select *  from B  where b<100)B1 on A1.id = B1.id;

-- 无论是行式存储还是列式存储，都可以在将过滤条件在读取一条记录之后执行以判断该记录是否需要返回给调用者，在Parquet做了更进一步的优化，优化的方法时对每一个Row Group的每一个Column Chunk在存储的时候都计算对应的统计信息

```




####  查看优化器重写后的SQL

SQL语句在被服务器执行时，并不一定就会按照我们写的顺序执行，MySQL优化器会重写sql，如何才能看到sql优化器重写后的sql呢？这就要用到explain extended和show warnings了。


explain extended sql语句，然后show warnings查看。

explain extended会输出sql的执行计划，查询记录的方式(全表扫描、全索引扫描、索引范围扫描等)、是否用上索引

show warnings会看到优化器重写后的sql



### **条件化简**

我们编写的查询语句的 where 搜索条件本质上是一个表达式，这些表达式可能比较繁杂，或者不能高效的执行，MySQL 的查询优化器会为我们简化这些表达式。

**移除不必要的括号**

有时候表达式里有许多无用的括号，比如这样一条 sql 条件：

```sql
 ((a = 5 AND b = c) OR ((a > c) AND (c < 5)))
 
 # 优化器就会对其进行优化成下面这样
 
 (a = 5 and b = c) OR (a > c AND c < 5)
```

**常量传递**

```sql
 a = 5 AND b > a 就可以被转换为： a = 5 AND b > 5 
```



**子查询优化**

我们查询中的 select 列 from 表 中，有时候，列和表可能是我们其他查询中出来的。这种列和表是用 select 语句表现出来的就叫子查询。外层 select 就叫外层查询。

- SELECT 子句

```sql
 SELECT (SELECT m1 FROM e1 LIMIT 1);
```

- FROM 子句

```sql
 -- 子查询后边的 AS t 表明这个子 查询的结果就相当于一个名称为 t 的表，这个名叫 t 的表的列就是子查询结果中的列（m和n）。
 -- 这个放在 FROM 子句中的子查询本质上相当于一个表，但又和我们平常使用的表有点儿不一样，MySQL 把这种由子查询结果集组成的表称之为派生表。
 SELECT m, n FROM (SELECT m2 + 1 AS m, n2 AS n FROM e2 WHERE m2 > 2) AS t;
```

- WHERE 或 ON 子句

```sql
 -- 最常见的查询：整个查询语句的意思就是我们想找 e1 表中的某些记录，这 些记录的 m1 列的值能在 e2 表的 m2 列找到匹配的值。
 SELECT * FROM e1 WHERE m1 IN (SELECT m2 FROM e2);
```

**子查询分类**

- 标量子查询 （一行一列）

```sql
 -- 那些只返回一个单一值的子查询称之为标量子查询：子查询里面的查询结果只返回一行一列一个值的情况。
 SELECT * FROM (SELECT m1 FROM e1 LIMIT 1);
 SELECT * FROM e1 WHERE m1 = (SELECT MIN(m2) FROM e2);
 SELECT * FROM e1 WHERE m1 < (SELECT MIN(m2) FROM e2);
 


-- 查询出销售单价高于平均销售单价的商品:子查询只返回一个值(平均单价)
SELECT product_id, product_name, sale_price
 FROM Product
WHERE sale_price > (SELECT AVG(sale_price)FROM Product);


 
-- 标量子查询的书写位置并不仅仅局限于 WHERE 子句中，通常任何可以使用单一值的位置都可以使用。
-- 也就是说，能够使用常数或者列名的地方，无论是 SELECT 子句、GROUP BY 子句、HAVING 子句，还是ORDER BY 子句，几乎所有的地方都可以使用。
```

- 行子查询（一行多列）

```sql
 -- 顾名思义，就是返回一条记录的子查询，不过这条记录需要包含多个列（只包含一个列就成了标量子查询了）。
 -- 其中的(SELECT m2, n2 FROM e2 LIMIT 1)就是一个行子查询
 -- 整条语句的含义就是要从 e1 表中找一些记录，这些记录的 m1 和 n1 列分别等于子查询结果中的 m2 和 n2 列
 SELECT * FROM e1 WHERE (m1, n1) = (SELECT m2, n2 FROM e2 LIMIT 1);
```

- 列子查询

```sql
 -- 列子查询自然就是查询出一个列的数据，不过这个列的数据需要包含多条记录
 -- 其中的(SELECT m2 FROM e2)就是一个列子查询，表明查询出 e2 表的 m2 列 的所有值作为外层查询 IN 语句的参数。
 SELECT * FROM e1 WHERE m1 IN (SELECT m2 FROM e2);
```

- 表子查询（二维多行多列）

```sql
 -- 顾名思义，就是子查询的结果既包含很多条记录，又包含很多个列
 -- 其中的(SELECT m2, n2 FROM e2)就是一个表子查询、此sql必须要在m1，n1都满足的条件下方可成立
 SELECT * FROM e1 WHERE (m1, n1) IN (SELECT m2, n2 FROM e2);
```


- 不相关子查询

如果子查询可以单独运行出结果，而不依赖于外层查询的值，我们就可以把这个子查询称之为不相关子查询。我们前边介绍的那些子查询全部都可以看作不相关子查询。


- 相关子查询

如果子查询的执行需要依赖于外层查询的值，我们就可以把这个子查询称之为相关子查询。

```SQL
-- 对于外部查询返回的每一行数据，内部查询都要执行一次。
-- 在关联子查询中是信息流是双向的。外部查询的每行数据传递一个值给子查询，然后子查询为每一行数据执行一次并返回它的记录。然后，外部查询根据返回的记录做出决策。

-- 在普通子查询中，执行顺序是由内到外，先执行内部查询再执行外部查询。内部查询的执行不依赖于外部查询，且内部查询只处理一次，外部查询基于内部查询返回值再进行查询，就查询完毕了。

-- 而在关联子查询中，信息传播是双向而不是单向的。内部查询利用关联子查询涉及外部查询提供的信息，外部查询也会根据内部查询返回的记录进行决策。内部查询的执行依赖于外部查询，不能单独执行。


-- 检索工资大于同职位的平均工资的员工信息。

-- 员工多，而相应的职位（如销售员、经理、部门经理等）少，因此首先想到的思路是对职位分组，这样就能分别得到各个职位的平均工资，再比较每个人的工资和他对应职位的平均工资，大于则被筛选出来。

```
[参考](https://www.cnblogs.com/heenhui2016/p/10574695.html)

[]()

### **子查询在 MySQL 中是怎么执行的**

常规想象思维中子查询的执行方式（非实际）

```sql
 -- 不相关子查询
 SELECT * FROM s1 WHERE order_note IN (SELECT order_note FROM s2 WHERE order_no = 'a');

-- 对于这样一个查询
SELECT * FROM t1 WHERE t1.a IN (SELECT t2.b FROM t2 WHERE id < 10);


-- 我们可能会认为这样执行的
--SELECT t2.b FROM t2 WHERE id < 10; 
-- 结果:1,2,3,4,5,6,7,8,9 
-- select * from t1 where t1.a in(1,2,3,4,5,6,7,8,9);

-- 实际上在MySQL内部，优化器可能会改写成如下SQL
select * from t1 where exists(select b from t2 where id < 10 and t1.a=t2.b);

-- 不相关子查询变成了关联子查询（select_type:DEPENDENT SUBQUERY），子查询需要根据 b 来关联外表 t1，因为需要外表的 t1 字段，所以子查询是没法先执行的。执行流程如下：

-- 1、扫描 t1，从 t1 取出一行数据 R；
-- 2、从数据行 R 中，取出字段 a 执行子查询，如果得到结果为 TRUE，则把这行数据 R 放到结果集；
-- 3、重复 1、2 直到结束。

-- 总的扫描行数为 100+100*9=1000（这是理论值，实际值为 964，怎么来的一直没想明白，看规律是子查询结果集每多一行，总扫描行数就会少几行）。
 
 -- 我们想象中的可能是把子查询里面的这个结果集查出来放到内存中，然后做为外层查询的条件进行查询。可能会导致两个问题：
 -- 1.子查询的结果集太多，可能内存中都放不下。
 -- 2.对于外层查询来说，如果子查询的结果集太多，那就意味着IN子句中的参数特别多，由于order_note不是索引列，每个IN语句的条件都会全表扫描进行遍历。
 
 -- 结果集过多的处理方案
 -- IN子句中的结果集可能存在着大量的重复字段。这些字段对于获取最后的查询结果而言，都是浪费资源的无用功，因此，结果集过多的第一个处理方案，就是考虑去重。
 -- 如果结果集中确实过大，导致即使结果去重后，内存存放仍然有压力，因此转存到磁盘当中。
 
 -- order_note不是索引，你怎么滴还能让他不进行全表扫描不成？当然，直接加索引是不成的。但是我们可以通过物化表的方式对sql进行改造，由优化器再次判断是否使用全表扫描。
 -- 当IN的结果集过大时，我们会将IN子句升级为物化表。升级流程如下：
 
 -- 1.该临时表的列就是子查询结果集中的列。
 -- 2.写入临时表的记录会被去重，临时表也是个表，只要为表中记录的所有列建立主键或者唯一索引。
 
 -- 物化表是基于磁盘的么？不，这个表在不是特别大的时候是基于内存的。
 -- 一般情况下子查询结果集不会大的离谱，所以会为它建立基于内存的使用 Memory 存储引擎的临时表，而且会为该表建立哈希索引。
 -- 如果子查询的结果集非常大，超过了系统变量 tmp_table_size 或者 max_heap_table_size，临时表会转而使用基于磁盘的存储引擎来保存结果集中的记录，索引类型也对应转变为 B+树索引。



--物化表转连接
-- 当我们把子查询进行物化之后，假设子查询物化表的名称为 materialized_table，该物化表存储的子查询结果集的列为 m_val，那么这个查询就相当于表 s1 和子查询物化表 materialized_table 进行内连接。
 SELECT s1.* FROM s1 INNER JOIN materialized_table ON order_note = m_val

 -- 驱动表算法 
```


**ANY/ALL子查询优化**

如果 ANY/ALL 子查询是不相关子查询的话， 它们在很多场合都能转换成我们熟悉的方式去执行：

```SQL
< ANY (SELECT inner_expr ...)   < (SELECT MAX(inner_expr) ...)  --小于任何一个，等价于小于最大的
> ANY (SELECT inner_expr ...)   > (SELECT MIN(inner_expr) ...)  --大于任何一个，等价于大于最小的
< ALL (SELECT inner_expr ...)   < (SELECT MIN(inner_expr) ...)  --小于所有的，等价于小于最小的
> ALL (SELECT inner_expr ...)   > (SELECT MAX(inner_expr) ...)  --大于所有的，等价于大于最大的
```


### IN和EXISTS区别

SQL 的保留字中，有很多都被归为谓词一类。例如，"=,<,>,<>,"等比较谓词，以及 BETWEEN 、LIKE 、IN 、IS NULL 等。

谓词是一种特殊的函数，返回值是真值。
前面提到的每个谓词，返回值都是 true 、 false 或者 unknown （一般的谓词逻辑里没有 unknown ，但是 SQL 采用的是三值逻辑，因此具有三种真值）。
谓词逻辑提供谓词是为了判断命题（可以理解成陈述句）的真假，而在关系数据库里，表中的一行数据可以看作是一个命题。

表常常被认为是行的集合，但从谓词逻辑的观点看，也可以认为是命题的集合（也就是描述每一行记录陈述句的集合）。

一言以蔽之，谓词的作用就是"判断是否存在满足某种条件的记录"。如果存在这样的记录就返回真（ TRUE ），如果不存在就返回假（ FALSE ）

也就是说，我们平时使用的 WHERE 子句，其实也可以看成是由多个谓词组合而成的新谓词。只有能让 WHERE 子句的返回值为真的命题，才能从表（命题的集合）中查询到。


不管子查询是相关的还是不相关的， 都可以把 IN 子查询尝试转为 EXISTS子查询其实对于任意一个 IN 子查询来说， 都可以被转为 EXISTS 子查询

通用的例子如下：
```SQL
outer_expr IN (SELECT inner_expr FROM ... WHERE subquery_where)
-- 可以被转换为：
EXISTS (SELECT inner_expr FROM ... WHERE subquery_where AND outer_expr=inner_expr)


--需要注意的是， 如果 IN 子查询不满足转换为 semi-join 的条件， 又不能转换为物化表或者转换为物化表的成本太大， 那么它就会被转换为 EXISTS 查询。

在 MySQL5.5 以及之前的版本没有引进 semi-join 和物化的方式优化子查询时，优化器都会把 IN 子查询转换为 EXISTS 子查询，所以当时好多声音都是建议大家把子查询转为连接，不过随着 MySQL 的发展，最近的版本中引入了非常多的子查询优化策略，内部的转换工作优化器会为大家自动实现。
```


[https://blog.csdn.net/weixin_47184173/article/details/117411011](https://blog.csdn.net/weixin_47184173/article/details/117411011)

[为什么300的并发能把支持最大连接数4000数据库压死？](https://www.notion.so/300-4000-5eb680aec38d4cc8adda2f70d33af246)



### 如何处理查询？

有时候，各种查询语句经常会直接查询超大表，甚至单表就超过整个服务器的所有物理内存了。那会不会一下子就打挂MySQL呢？

显然不会。客户端执行查询要求返回的结果集是很普遍的情况。





## MySQL线程状态







| 状态                                     | 含义                                                         |
| ---------------------------------------- | ------------------------------------------------------------ |
| `After create`                           | 当线程在创建表的函数末尾创建表（包括内部临时表）时，会发生这种情况。即使由于某些错误而无法创建表，也会使用此状态 |
| altering table                           | 服务器正在执行就地 ALTER TABLE                               |
| Analyzing                                | 线程正在计算MyISAM表键分布（例如，for ANALYZE TABLE）。      |
| checking permissions                     | 线程正在检查服务器是否具有执行语句所需的权限                 |
| Checking table                           | 该线程正在执行表检查操作                                     |
| cleaning up                              | 该线程已经处理了一个命令，并准备释放内存并重置某些状态变量   |
| **`closing tables`**                     |                                                              |
| committing alter table to storage engine |                                                              |
| converting HEAP to MyISAM                |                                                              |
| copy to tmp table                        |                                                              |
| Copying to group table                   |                                                              |
| Copying to tmp table                     |                                                              |
| **`Copying to tmp table on disk`**       |                                                              |
| Creating index                           |                                                              |
| Creating sort index                      |                                                              |
| creating table                           |                                                              |
| **`Creating tmp table`**                 |                                                              |














## 存储引擎

为了方便管理，人们把连接管理、查询缓存、语法解析、查询优化这些并不涉及真实数据存储的功能划分为MySQL Server的功能，把真实存取数据的功能划分为存储引擎的功能。所以在MySQL server完成了查询优化后，只需按照生成的执行计划调用底层存储引擎提供的API，获取到数据后返回给客户端就好了。

MySQL中提到了存储引擎的概念，简而言之，存储引擎就是指表的类型。其实存储引擎以前叫做表处理器，后来改名为存储引擎，它的功能就是接收上层传下来的指令，然后对表中的数据进行提取或写入操作。
