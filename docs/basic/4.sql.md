# SQL 语法

在不同的数据库管理系统中，实例和模式都有不同的概念。在 MySQL 中，分别有如下意义：

- 实例（instance）：一个操作系统中启动中的一个mysqld守护进程被称为一个数据库实例。
- 数据库（database）：存放多个相关业务数据表的逻辑对象。
- 模式（schema）：MySQL中schema等同于database。

可以在[MySQL术语表](https://dev.mysql.com/doc/refman/8.0/en/glossary.html)中查到上面这些定义。



## SQL语言概述

SQL语言概览

SQL最早是IBM公司开发，最初称作Sequel，后来变为SQL（结构化查询语言），SQL的标准是由美国国家标准化组织和国际标准化组织制定。

最新的标准是 SQL:2023 ，网上有一份的[SQL-99](https://sql-99.readthedocs.io/en/latest/)规范

SQL语言有以下几个部分：

- 数据定义语言（DDL）：表定义，表删除，表结构修改等语句。
- 数据操纵语言（DML）：对数据库表的增删改查语句。
- 完整性：SQL DDL 中包括数据定义的完整性的约束。是指数据的一致性和有效性；
- 视图定义：SQL  DDL 包含视图定义的命令
- 事务控制：SQL
- 嵌入式和动态SQL
- 授权


每个关系型数据库都在不同程度上实现SQL标准，但是也有自己实现的标准，但是大部分都是基本一致，但是每个数据库都有自己的高级特性和实现标准。


当引入关系模型时，关系模型包含了一种查询数据的新方法：SQL，它是一种 `声明式` 的数据查询语言。

在声明式查询语言（如 SQL 或关系代数）中，你只需指定所需数据的模式 - 结果必须符合哪些条件，以及如何将数据转换（例如，排序，分组和集合） - 但不关注如何实现这一目标。数据库系统的查询优化器决定使用哪些索引和哪些连接方法，以及以何种顺序执行查询的各个部分。

声明式查询语言是迷人的，因为它通常比命令式 API 更加简洁和容易。但更重要的是，它还隐藏了数据库引擎的实现细节，这使得数据库系统可以在无需对查询做任何更改的情况下进行性能提升。


Oracle，MySQL，MicroSoft SQL server, PostgreSQL 是不同组织对关系型数据库的具体实现产品，他们都部分实现了SQL标准。


## SQL规范

在广泛的数据分析师和工程师团队中工作时，您是否曾为不同的 SQL 风格而苦苦挣扎。上/下关键字、前导/尾随逗号、缩进、别名规则等。

随着模型数量的增长，拥有一致的风格变得有益，以简化代码审查、新成员的入职等。SQLfluff 来拯救，它是 SQL 文件的 CLI linter。它可以突出显示并经常修复样式违规。

dbt 是另一个令人惊叹的工具，可以简化数据建模、跟踪模型之间的依赖关系并减少样板代码的数量。


[gitlab-sql-style-guide](https://about.gitlab.com/handbook/business-technology/data-team/platform/sql-style-guide/)



### 团队对齐

首先，您需要与团队交谈并解释为什么拥有某些风格规则很重要。

这一步非常重要，因为如果没有清楚地了解为什么需要 PR，没有人会乐于看到 PR 停留在审查中。

这次谈话的一个好的结果是有一套你同意遵守的初始规则。此外，如果它很大和/或由多个 dbt 项目组成，您可能只想为项目的某个区域推出它。


### 集成到开发工作流程中

下一步是将 SQLfluff 集成到开发工作流中。实现它的最简单方法是使用预提交挂钩。

如果您已经在使用它们，只需添加几个新的钩子会容易得多sqlfliff fix，sqlfluff lint.

否则，您可能需要更多时间来采用预提交挂钩。值得一提的是，尽管强烈推荐此步骤，但为了使开发工作流程更加顺畅，此步骤可能是可选的。

### 集成到 CI/CD 中
下一步是通过将 SQLfluff 集成到 CI/CD 中来强制执行规则。

它可以以软或硬的方式完成。

在第一种情况下，它应该只发出警告，而不是阻止 PR 被合并。

在第二种情况下，PR 应该

## SQL语法和注释

```SQL
-- MySQL有几种注释语法

-- 1、用双斜线注释一行
/* 2、用C语言风格的注释注释语句块 */

SELECT 1+1 from dual;     -- 注释文字


/* 标准SQL注释采用了C语言中的注释语法, MySQL同样支持这种语法  */ 
-- 下面这段注释表示：当接收SQL的Server版本大于4.0.001时，后面的注释文字就可以被识别。
SELECT /*!40001 SQL_NO_CACHE */  count(*) FROM db_test.test_table
SELECT SQL_NO_CACHE  count(*) FROM db_test.test_table
```

## 字符串字面量



## 数据库的创建与删除

```sql
-- 建库，在Unix中，库名是严格区分大小的，强烈建议库名由小写字母和下划线组成
CREATE DATABASE `database_test`  IF NOT EXISTS CHARACTER SET 'utf8mb4' COLLATE 'utf8mb4_0900_ai_ci';

-- 设置某个库只读
-- MySQL 8.0.22中引入的READ ONLY选项控制是否允许修改数据库和其中的对象。允许的值为DEFAULT或0（非只读）和1（只读）。
-- 此选项对于数据库迁移非常有用，因为启用了只读功能的数据库可以迁移到另一个MySQL实例，而不必担心在操作过程中数据库可能会发生更改。

ALTER DATABASE  `database_test`   READ ONLY = 0 ;


-- 删库
DROP DATABASE database_test;


-- 修改数据库
-- 注意：在 MySQL 中，数据库创建之后库名是无法直接修改的。能改的只有字符集等属性。

```



### 表的创建

```SQL

-- 文件大小写，在不同的操作系统中的文件系统，是不一样的。
-- Linux操作系统，严格区分大小写，Test 和 TEST 是两个不同的文件或文件夹。
-- Windows操作系统，不区分大小写，无法同时创建 Test 和 TEST 两个同名的文件或文件夹。

-- 对于MySQL数据库和表，要在操作系统创建与库名和表名相同的文件夹或文件。

-- lower_case_file_system 是一个只读参数，无法被修改，这个参数是用来告诉你在当前的系统平台下，是否对文件名大小写敏感。

-- lower_case_table_names是一个MySQL可配置的参数，它的取值如下：

-- 0 大小写敏感。（Unix，Linux默认） 创建的库表将原样保存在磁盘上。
-- 如 create database TeSt ; 将会创建一个TeSt的目录，create table AbCCC …将会原样生成AbCCC.frm。 SQL语句也会原样解析。

-- 1 大小写不敏感。（Windows默认） 创建库表时，MySQL将所有的库表文件转换成小写存储在磁盘上。SQL语句同样会将库表名转换成小写。 
-- 如需要查询以前创建的Testtable（生成Testtable.frm文件），即便执行select * from Testtable，也会被转换成select * from testtable，致使报错表不存在。

-- 列名，索引名，存储过程、函数及事件名称在任何操作系统下都不区分大小写，列别名也不区分大小写。


-- 最佳实践：建议将lower_case_table_names值统一设置为0，在代码中对大小写进行严格区分
-- 库名，表名，字段名，统一由小写英文字符和数字组成。

-- 在各家公司，都存在各种设计规范：
-- https://support.huaweicloud.com/bestpractice-rds/rds_02_0013.html


-- lower_case_table_names 参数是全局系统变量，不可以动态修改，想要变动时，必须写入配置文件然后重启数据库生效。
-- 如果你的数据库该参数一开始为 0 ，现在想要改为 1 ，这种情况要格外注意，因为若原实例中存在大写的库表，则改为 1 重启后，这些库表将会不能访问。
-- 如果需要将 lower_case_table_names 参数从 0 改成 1 ，可以按照下面步骤修改：

-- 1、首先核实下实例中是否存在大写的库及表，若不存在大写的库表，则可以直接修改配置文件然后重启。若存在大写的库表，则需要先将大写的库表转化为小写，然后才可以修改配置文件重启。

-- 2、通过 mysqldump 备份相关库，备份完成后删除对应库，之后修改配置文件重启，最后将备份文件重新导入。此方法用时较长，一般很少用到。

-- 3、 通过 rename 语句修改

-- 将大写表重命名为小写表 
rename table TEST to test;

-- 若存在大写库 则需要先创建小写库 然后将大写库里面的表转移到小写库
rename table TESTDB.test_tb to testdb.test_tb;

-- 分享两条可能用到的SQL
-- 查询实例中有大写字母的表
SELECT
 TABLE_SCHEMA,
 TABLE_NAME
FROM
 information_schema.`TABLES` 
WHERE
 TABLE_SCHEMA NOT IN ( 'information_schema', 'sys', 'mysql', 'performance_schema' ) 
 AND table_type = 'BASE TABLE' 
 AND TABLE_NAME REGEXP BINARY '[A-Z]'
  
 
-- 拼接SQL 将大写库中的表转移到小写库
SELECT
 CONCAT( 'rename table TESTDB.', TABLE_NAME, ' to testdb.', TABLE_NAME, ';' ) 
FROM
 information_schema.TABLES 
WHERE
 TABLE_SCHEMA = 'TESTDB';


-- 建表
-- 表名，字段名，字段类型，字段的约束，字段的字符集，存储引擎等
CREATE TABLE `cwd_group` (
  `id` bigint NOT NULL,
  `group_name` varchar(255) COLLATE utf8_bin NOT NULL,
  `lower_group_name` varchar(255) COLLATE utf8_bin NOT NULL,
  `active` char(1) COLLATE utf8_bin NOT NULL,
  `local` char(1) COLLATE utf8_bin NOT NULL,
  `created_date` datetime NOT NULL,
  `updated_date` datetime NOT NULL,
  `description` varchar(255) COLLATE utf8_bin DEFAULT NULL,
  `group_type` varchar(32) COLLATE utf8_bin NOT NULL,
  `directory_id` bigint NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `cwd_group_name_dir_id` (`lower_group_name`,`directory_id`),
  KEY `idx_group_active` (`active`,`directory_id`),
  KEY `idx_group_dir_id` (`directory_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;


CREATE TABLE Product (
    product_id        char(4)         NOT NULL,     
    product_name      varchar(100)    NOT NULL,     
    product_type      varchar(32)     NOT NULL,     
    sale_price        integer                 ,
    purchase_price    integer                 ,
    regist_date       date                    , 
    PRIMARY KEY (`product_id`)

) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;



-- 在demo库下建表ChineseCharInfo，有两列，其中ID为自增主键
CREATE TABLE demo.ChineseCharInfo
(
    ID        int              NOT NULL     auto_increment,
    Hanzi     varchar(10)      NOT NULL,
    primary   key (ID)
)
ENGINE=InnoDB auto_increment=1 DEFAULT CHARSET=utf8 COLLATE=utf8_general_ci;


-- 在demo库下建表ChinesePinyinInfo
CREATE TABLE demo.ChinesePinyinInfo
(
    ID         int                  NOT NULL     auto_increment,
    CharID     int                  NULL,
    Pinyin     varchar(10)          NULL,
    Tone       tinyint unsigned     NULL,
    primary key (ID),
    
    -- 方式一：不指定外键名称，数据库自动生成
    foreign key (CharID) references ChineseCharInfo(ID) on delete cascade on update cascade 
    
    -- 方式二：指定外键名称为(FK_Name)
    -- constraint FK_Name foreign key (CharID) references ChineseCharInfo(ID) on delete cascade on update cascade 
)
engine=innodb auto_increment=1 default charset=utf8 collate=utf8_general_ci;

-- 创建一个与原表结构一样的表
create table demo.ChineseCharInfobak like demo.ChineseCharInfo



```
### 数据插入



在 MySQL 中可以使用 INSERT 语句向数据库已有的表中插入一行或者多行元组数据。

```SQL

--单条插入
INSERT INTO items(name,city,price,number,picture)  VALUES ('耐克运动鞋','广州',500,1000,'003.jpg');



--批量插入
INSERT INTO  items(name,city,price,number,picture) 
 VALUES
('耐克运动鞋','广州',500,1000,'003.jpg'),
('耐克运动鞋2','广州2',500,1000,'002.jpg');

-- 1、要根据情况设置一次批量插入的数据量，数据量大，在网络中传输的事件也越久，出现问题的可能也越大；

-- 2、除了网络，还要看机器配置，MySQL Server配置差了，sql写得再好，效率也不会太高；

-- 3、另外批量这个词，是指一次插入多条数据，我们除了要注意数据的条数，还要注意一条数据的大小，举个例子：比如一条记录的数据量有1M，10条记录的数据量就10M，这时一次插100条，100M数据，嘿嘿，你试试看！！所以，一次插入多少数据，一定要经过多次测试后再决定，别人1次插100条最优，你可能1次插10条才最优，没有绝对的最优值（批量插入未必总是比单条插入效率高）。

-- 4、数据库有个参数，max_allowed_packet，也就是每一个包（sql）命令大小，默认是1M，那么sql的长度大于1M就会报错。你可能会说，咱们把这个参数设成10M，100M不就行了？？？对呀，没毛病，但你是DBA吗？你有权限吗？即使调大这一个参数，你要知道影响的可不止你这一张表，而是整个DB Server，那影响的可是很多库，很多表。

-- 5、批量插入并不是越快越好，我们可能希望越快越好，这很正常，节省时间嘛。但是我们一定要知道，数据库分读写，有集群，这就意味着，需要同步！！！如果有分库分表分区的情况，如果短时间内插入的数据量太大，数据库同步可能就会比较迷了，读写数据不一致的情况在所难免了，可能会因为一张表的批量插入，影响整个DB服务组的同步，同时还要考虑并发问题，哈哈哈。　
```

```SQL
-- REPLACE INSERT语句
-- 在向表中插入数据的时候，经常遇到这样的情况：1. 首先判断数据是否存在； 2. 如果不存在，则插入；3.如果存在，则更新。
-- 使用REPLACE INTO时，首先会根据主键或者唯一索引查看表中是否有该条记录，有的话则先删除，然后插入数据；没有该记录则直接插入。

CREATE TABLE `stu` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `cid` int(11) NOT NULL,
  `name` varchar(32) DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `cid` (`cid`)
) ENGINE=InnoDB  DEFAULT CHARSET=utf8;
-- 其中id为自增主键，cid为唯一索引。

-- 插入两条数据
INSERT INTO stu(cid, name) VALUES(1, '1111');
INSERT INTO stu(cid, name) VALUES(2, '2222');
REPLACE INTO stu(cid, name) VALUES(3,'3333');


-- 1	1	1111
-- 2	2	2222
-- 3	3	3333


REPLACE INTO stu(cid, name) VALUES(3,'33331'); 
-- 使用REPLACE INTO时，首先会根据主键或者唯一索引查看表中是否有该条记录，有的话则先删除，然后插入数据；没有该记录则直接插入。
-- 原先id为3的记录变成了id为4了，说明原先id为3的记录先删除了，然后新插入了id为4（id自增）的新记录

-- 1	1	1111
-- 2	2	2222
-- 4	3	33331


--再次执行replace，id为4和cid为2的原记录都存在，则被删除。然后再插入这条新纪录
REPLACE INTO stu(id, cid, name) VALUES(4, 2,'42')
> Affected rows: 3
> 查询时间: 0.007s
-- 1	1	1111
-- 4	2	42
```

```SQL
-- INSERT INTO…SELECT…FROM 语句用于快速地从一个或多个表中取出数据，并将这些数据作为行数据插入另一个表中。
-- SELECT 子句返回的是一个查询到的结果集，INSERT 语句将这个结果集插入指定表中，结果集中的每行数据的字段数、字段的数据类型都必须与被操作的表完全一致。
```



```SQL
-- 在MySQL数据库中，如果在insert语句后面带上ON DUPLICATE KEY UPDATE 子句，而要插入的行与表中现有记录的惟一索引或主键中产生重复值，那么就会发生旧行的更新；如果插入的行数据与现有表中记录的唯一索引或者主键不重复，则执行新纪录插入操作。另外，ON DUPLICATE KEY UPDATE不能写where条件。

```


### 查询基础

从表中选取筛选数据，需要使用 SELECT 语句，也就是用表中选出 SELECT 必要数据的意思。通过 SELECT 语句查询并选取必要数据的过程称为查询（query）

```SQL
-- 查询语句的基本结构

select A1,A2,A3 ... An
from r1,r2,r3 ... rn
where P

-- 注意：这个方法只是用来理解SQL语句的查询结果
-- from 多个关系后，可以理解为所有关系的笛卡尔积
-- 谓词P对关系进行过滤
-- 再从 select 中提取需要的列
-- 实际上，组成笛卡尔积的时候，会尽可能先执行谓词过滤一些数据后，再进行笛卡尔积
```

### EXIT和IN查询


在使用 IN 和 NOT IN 时是无法选取出 NULL 数据的。
实际结果也是如此，NULL 终究还是需要使用 IS NULL 和 IS NOT NULL 来进行判断。

### WITH查询（CTE）

由于业务的客观复杂性，有时候会写出长达 2000 行的单条 SQL 语句，其中包含大量的聚合和多层子查询嵌套，维护此类 SQL 堪称开发人员的噩梦。

CTE通用表达式(Common table expression)简称CTE，由SQL:1999标准引入。它是一种更加便捷的复用查询结果的方法。

它可以极大提升开发人员和 DBA 编写复杂业务逻辑 SQL 的效率，增强代码的可维护性。

可以认为是在单个 SELECT、INSERT、UPDATE、DELETE 或 CREATE VIEW 语句的执行范围内定义的临时结果集。

CTE 与派生表类似，具体表现在不存储为对象，并且只在查询期间有效。与派生表的不同之处在于，CTE 可自引用，还可在同一查询中引用多次。



```SQL
WITH
  cte1 AS (SELECT a, b FROM table1),
  cte2 AS (SELECT c, d FROM table2)
SELECT b, d FROM cte1 JOIN cte2
WHERE cte1.a = cte2.c;


-- 列表中的名称数量必须与查询结果中的字段数量相同
WITH cte (col1, col2) AS
(
  SELECT 1, 2
  UNION ALL
  SELECT 3, 4
)
SELECT * FROM cte;


-- 子查询的CTE写法
-- CTE 将子查询的结果集用 with 语句提到最前面，取一个别名，再在后面的语句中使用
with derived(...) as (
	subquery
) 
select ... from derived, table_name1 ……;


-- CTE 可以引用其他CTE
with derived_one as (
	subquery
),
derived_two as (
	select …… from derived_one
)
select …… from derived_one, derived_two ……;

-- 在同一个语句级别中只允许存在一个WITH子句，有效的语法格式是为一个WITH子句定义多个从句，使用逗号进行分隔：
-- 在包含WITH子句的查询中，可以使用CTE的名称访问相应 CTE 的结果集。
-- 前面定义的CTE可以在其他的CTE中进行引用，因此 CTE 可以基于前面的 CTE 进行定义。
-- 引用自己的 CTE 被称为递归 CTE。递归 CTE 的使用场景包括生成序列，遍历层次数据或树状结构的数据。
-- 通用表表达式属于 DML 语句的可选部分。




--找出预算值最大的系:系名，预算
-- 方法一
select dept_name , budget 
 from department , 
 (SELECT max( budget )as budget FROM department) as max_budget 
 
   where department.budget = max_budget.budget


-- 先用with语句查出一个临时表 max_budget ( VALUE )，
这里面存了所有系里面的最大的预算值。再将这个表与系表关联查询
WITH max_budget (value) AS ( SELECT max( budget ) FROM department ) SELECT
budget 
FROM
	department,
	max_budget 
WHERE
	department.budget = max_budget.value
```

**CTE相较于派生表有4个明显的优势：**

- 更好的可读性

```SQL
    SELECT ...
    FROM t1 LEFT JOIN ((SELECT ... FROM ...) AS dt JOIN t2 ON ...) ON ...
    
    
    WITH dt AS (SELECT ... FROM ...)
    SELECT ...
    FROM t1 LEFT JOIN (dt JOIN t2 ON ...) ON ...
```

​    

- 可以被多次引用

```sql
    -- 传统派生表子查询写法：每个子查询都要写完成SQL
    
    SELECT ...
    FROM (SELECT a, b, SUM(c) s FROM t1 GROUP BY a, b) AS d1
    JOIN (SELECT a, b, SUM(c) s FROM t1 GROUP BY a, b) AS d2 ON d1.b = d2.a;
    
    -- CTE写法：一次生成，多次引用
    
    WITH d AS (SELECT a, b, SUM(c) s FROM t1 GROUP BY a, b)
    SELECT ... FROM d AS d1 JOIN d AS d2 ON d1.b = d2.a;
```

​    

- 可以引用其他的 CTE

```sql
    -- 传统这种不行，会报表不存在，要用更复杂的子查询
    SELECT ...
    FROM (SELECT ... FROM ...) AS d1, (SELECT ... FROM d1 ...) AS d2 ...
    
    
    -- 派生表写法
    WITH d1 AS (SELECT ... FROM ...),
    d2 AS (SELECT ... FROM d1 ...)
    SELECT
    FROM d1, d2 ...
```


- 性能的提升

#### 递归CTE

递归 CTE 是一种特殊的 CTE，其子查询会引用自己的名字。

`WITH`子句必须以`WITH RECURSIVE`开头。

递归CTE子查询包括两部分：`seed查询`和`recursive查询`，由`UNION[ALL]`或`UNION DISTINCT`分隔。

```SQL
-- 递归CTE
with recursive derived(n) as (
 select 1  
 union all 
 select n + 1 from derived where n < 5  
)
 select * from derived;

-- 以上语句的执行结果是一个连续的数字序列：1,2,3,4,5

-- 如果在WITH子句中引用了自己，WITH子句必须使用WITH RECURSIVE。（如果没有 CTE 引用自己，也可以使用RECURSIVE，但不强制。）

-- 递归 CTE 的子查询由两部分组成，中间使用UNION [ALL]或者UNION DISTINCT进行连接：

-- 第一个SELECT语句用于生成初始数据行，该语句不会引用 CTE 自身。
-- 第二个SELECT语句在它的FROM子句中引用了 CTE自身，通过递归产生更多的结果。
-- 当第二个语句不会产生更多的新数据时结束递归。因此，递归 CTE由一个非递归的SELECT语句和一个递归的SELECT语句组成。
-- CTE最终结果中的字段类型由非递归的SELECT语句决定，所有字段都可以为空。查询结果的字段类型与递归SELECT语句无关。
-- 如果递归部分和非递归部分使用UNION DISTINCT进行连接，查询结果将会排除重复的数据行。
-- 这种方式可以用于执行传递闭包（transitive closure，例如两个地点之间的乘车路线）的查询，防止无限循环。

-- 递归部分的每次迭代只针对上次迭代生成的新数据行进行操作。
-- 如果递归部分包含多个查询块，迭代时每个查询块的执行顺序不固定，每个查询块基于它自己前一次迭代的结果，或者上次迭代结束后其他查询块生成的结果进行操作。


-- 前面递归 CTE 示例中的非递归语句如下，它会产生一条初始化的数据：
SELECT 1
-- 它的递归部分如下：
SELECT n + 1 FROM cte WHERE n < 5
-- 每次迭代时，SELECT语句将会产生一个比上一次结果中的 n 大 1 的新值。
-- 第一次迭代基于初始值（1）进行操作，生成 1+1=2；
-- 第二次迭代基于第一次迭代的结果（2），生成 2+1=3；如此等等。
-- 迭代一直执行到递归结束，此处为 n 的值大于或等于 5。
-- 如果递归部分产生的结果比非递归部分的字段长度更大，需要在非递归部分指定一个更宽的字段类型，避免数据被截断。



-- 假设用树形结构来描述一个部门的组织架构

-- DDL  用id来标识一个人，用manager_id来表示向上一个人汇报
CREATE TABLE db_test.employees_mgr (
	id INT PRIMARY KEY NOT NULL,
	name VARCHAR ( 100 ) NOT NULL,
	manager_id INT NULL,
	INDEX ( manager_id ),
	FOREIGN KEY ( manager_id ) REFERENCES employees_mgr ( id ) 
);


-- test data
insert into db_test.employees_mgr values 
(333, "Yasmina", null), /* Yasmina is the CEO (manager_id is null) */
(198, "John", 333),     /* John has id 198 and reports to 333 (Yasmina) */
(692, "Tarek", 333),    /* Tarek has id 692 and reports to 333 (Yasmina) */
(29, "Pedro ", 198),    /* Pedro has id 29 and reports to 198 (John) */
(4610, "Sarah", 29);    /* Sarah has id 4610 and reports to 29 (Pedro) */


-- 要查询出如下这种树形结果
                       
+------+---------+--------------------+                                                                                                                                                                          
| id   | name    | path               |                                                                                               
+------+---------+--------------------+                                                                
|  333 | Yasmina | 333                |                                                                                           
|  198 | John    | 333->198           |                                                                                            
|  692 | Tarek   | 333->692           |                                                                                           
|   29 | Pedro   | 333->198->29       |                                                                                              
| 4610 | Sarah   | 333->198->29->4610 |                                                                                             
+------+---------+--------------------+                                                                                                 
5 rows in set (0.00 sec)                                                                                              
mysql>   


-- MySQL8.0中支持with子句
-- 通过递归CTE来查询用户的层级关系
-- 规划一个ID，name，path这样的一个层级临时表
 with recursive employee_paths (id, name, path) as (
     --先查最顶层节点
     select id, name, cast(id as char(200))
     from db_test.employees_mgr
     where manager_id is null
     union all
     -- 递归查询
     select e.id, e.name, concat(ep.path, '->', e.id)
     from employee_paths as ep
     join db_test.employees_mgr as e
     on ep.id = e.manager_id
    )
     select * from employee_paths;
```


### 查询排序

```SQL

-- 对字符串类型中的中文字段排序

-- 

```

### 集合查询

```sql
-- 教师表  instructor(ID, name, dept_name, salary)
-- 找出满足下面条件的所有教师的姓名：他们的工资比 Biology 系教师的最低工资要高
-- 

-- 方法一
-- 将一个表和它自己进行笛卡尔积运算，然后再过滤
select distinct T.name from instructor as T, instructor as S where T.salary > S.salary and S.dep_tname='Biology';

-- >some 比较，至少比集合中某一个值要大
-- 大于some就是：比最小的还要大
-- 小于some就是，比最大的还要小
--方法二
--等价上面的写法，使用 > some 格式判断，子查询查出 Biology 系所有的工资组成集合。再用 >some 比较
select name from instructor where salary > some (select salary from instructor where dep_tname='Biology' );

-- SQL语句中存在3个著名的量词，some all 和 any
-- all：只有当其所有数据都满足条件时，条件才成立
-- any：只要有一条数据满足条件，条件就成立
-- some：其中存在一些数据满足条件，作用和Any大致相同 常规的使用中看作一致即可


--找出满足下面条件的所有教师的姓名：他们的工资比 Biology 系每个教师的最高工资要高（他们的工资比Biology中的每个教师的工资都要高）
-- >all 比较，比集合中的所有值都大。
select name from instructor where salary > all (select salary from instructor where dep_tname='Biology' );


-- 找出平均工资最高的系
-- 先查出所有系的平均工资做为一个集合，再在所有系的平均的工资里面比较，找出最大值。
select dept_name from instructor group by dept_name having avg(salary) >=all (select avg(salary) from instructor group by deptname); 

```



### 派生表和子查询

在数据库中，我们经常使用子查询和派生表来进行查询。

```SQL
-- 子查询
-- 在另一个查询(外部查询)中嵌套另一个查询语句(内部查询)，并使用内部查询的结果值作为外部查询条件。
-- 子查询在where中
-- where条件比对的值是从其他表查出来的。
-- 其实不光是 where ，select 后面跟的字段名也可以是从其他表中查出来的。

SELECT 
       customerNumber, checkNumber, amount
FROM
   　　 payments
WHERE
 　　   amount = (SELECT  MAX(amount) FROMpayments);


-- 标量子查询 （一行一列）
-- 那些只返回一个单一值的子查询称之为标量子查询：子查询里面的查询结果只返回一行一列一个值的情况。
SELECT (SELECT m1 FROM e1 LIMIT 1);
SELECT * FROM e1 WHERE m1 = (SELECT MIN(m2) FROM e2);
SELECT * FROM e1 WHERE m1 < (SELECT MIN(m2) FROM e2);


-- 行子查询（一行多列）
-- 顾名思义，就是返回一条记录的子查询，不过这条记录需要包含多个列（只包含一个列就成了标量子查询了）。
-- 其中的(SELECT m2, n2 FROM e2 LIMIT 1)就是一个行子查询
-- 整条语句的含义就是要从 e1 表中找一些记录，这些记录的 m1 和 n1 列分别等于子查询结果中的 m2 和 n2 列
SELECT * FROM e1 WHERE (m1, n1) = (SELECT m2, n2 FROM e2 LIMIT 1);

-- 列子查询（一列数据）
-- 列子查询自然就是查询出一个列的数据，不过这个列的数据需要包含多条记录
-- 其中的(SELECT m2 FROM e2)就是一个列子查询，表明查询出 e2 表的 m2 列 的所有值作为外层查询 IN 语句的参数。
SELECT * FROM e1 WHERE m1 IN (SELECT m2 FROM e2);

-- 表子查询（二维多行多列）
-- 顾名思义，就是子查询的结果既包含很多条记录，又包含很多个列
-- 其中的(SELECT m2, n2 FROM e2)就是一个表子查询、此sql必须要在m1，n1都满足的条件下方可成立
SELECT * FROM e1 WHERE (m1, n1) IN (SELECT m2, n2 FROM e2);


-- From子句中的子查询
-- 派生表（子查询）
-- from后面跟的表是通过其他查询查出来的，这种查询叫派生表，派生表必须要有别名，以便稍后在查询中引用其名称。
-- 这种子查询后边的 AS t 表明这个子 查询的结果就相当于一个名称为 t 的表，这个名叫 t 的表的列就是子查询结果中的列（m和n）。
-- 这个放在 FROM 子句中的子查询本质上相当于一个表，但又和我们平常使用的表有点儿不一样，MySQL 把这种由子查询结果集组成的临时表称之为派生表。
SELECT m, n FROM (SELECT m2 + 1 AS m, n2 AS n FROM e2 WHERE m2 > 2) AS t;
-- 派生表也是从 select 语句中返回的虚拟表。
SELECT 
    column_list
FROM
    (SELECT column_list ... FROM table_1) derived_table_name
WHERE derived_table_name.c1 > 0;


```



### 联表查询



#### 笛卡尔积/交叉连接

笛卡尔积是指在数学中，两个集合X和Y的笛卡尓积（Cartesian product），又称直积，表示为X × Y，第一个对象是X的成员而第二个对象是Y的所有可能有序对的其中一个成员。

笛卡尔积又叫笛卡尔乘积，是一个叫笛卡尔的人提出来的。 简单的说就是两个集合相乘的结果。

假设集合A={a, b}，集合B={0, 1, 2}，则两个集合的笛卡尔积为{(a, 0), (a, 1), (a, 2), (b, 0), (b, 1), (b, 2)}。

遍历左表的每一行数据，用左表每一行数据分别于与右表的每一行数据做关联

```SQL
 select * from stu cross join class;
 select * from stu,class;
 select * from stu as a ,  class as b join on 1=1 ;
 -- 可以看出，笛卡尔乘积的运算量超级大，一般不会使用笛卡尔乘积做表的关联查询
```

!!! 注意
    在 MySQL 中， CROSS JOIN  等价于  INNER JOIN ， 这两个可以互换使用。但是在标准SQL中，这两个并不一样。




#### 自然连接

对于两个表，自然连接是先找出两个表所有共用的属性，然后在**共用属性上做匹配，找出相同的行进行连接。（一定要注意连接谓词是所有的共有属性集合，即两个表上所有相同的列名）**


```SQL
-- 标准SQL写法一
select user_name,dept_name from user natural join dept ;     --这个限制比较大，要求字段名称一致。
-- 标准SQL写法二
select user_name,dept_name from  user, dept where user.id = dept.id  ...  --所有共有属性都连接起来。
-- MySQL写法三


-- select name , id , title from A1 natural join A2 natural join A3
-- select name , id , title from A1 natural join A2 , A3 where A2.id = A3.id 
-- 这两个写法的结果可能不一样，
-- 第一个可以认为将A1 A2进行自然连接的结果，再与A3进行自然连接
-- 第二个可以认为将A1 A2进行自然连接的结果，再与A3进行等值连接 

```


#### 等值连接

对两个表，等值连接是明确一组属性上进行匹配。然后进行连接。(连接谓词是在选定的属性集合)，**所以自然连接是一种特殊的等值连接。这种方法可能更加通用。**

```SQL
-- 在这个例子中，只在ID上进行匹配。要求两个表都要有ID这个字段。
-- 使用 using 语法 ， select ... from T1 join T2 using(id)
select user_name,dept_name from user join dept using (id) ;
-- 使用 join on 关键字，on条件允许在参与连接的关系上设置连接谓词。
select  user_name,dept_name from user join dept on user.id = dept.id ;

-- tb1 inner join tb2 on something
-- 不保留未匹配的元组
select  user_name,dept_name from students  left outer join dept on user.id = dept.id ;
```

#### 内连接

内连接包括自然连接，不等值连接和等值连接。上面这些连接，都是常规连接，都可以理解成内连接，两个表中的列互相匹配时，只按照少的那个表匹配。





##### 不等值连接

不等值连接：在连接条件使用除等于运算符以外的其它比较运算符比较被连接的列的列值。这些运算符包括>、>=、<=、<、!>、!<和<>。



### 分组查询

在标准SQL，正常的如果对一个表进行分组查询，分组会进行去重，每一组应该只有一行数据。

分组，主要是使用 group by 子句，一般是按照 where 条件过滤之后的结果集进行分组，group by 一般和聚合函数一起使用才有意义。


如果是需要一个组内有多行数据，需要组内排序，可以使用窗口函数。

**标准SQL规定：分组查询中的要查询的列必须是 group by 中要分组的列或聚集函数或常量。**

按多字段分组，所有字段值相同的才能算一组。

[参考](https://www.cnblogs.com/youzhibing/p/11516154.html)

```SQL

-- 查询每个系的平均工资(系名，平均工资)
-- 先按系分组，再求每个系的平均工资
select dept_name ,avg(salary) from instructor group by dept_name

-- 单独使用 GROUP BY 关键字时，查询结果会只显示每个分组中的第一条记录
mysql> SELECT COUNT(sex) as num ,sex FROM tb_students_info GROUP BY sex;
+-------+------+
| num   | sex  |
+-------+------+
| 10    | 女   |
| 15    | 男   |
+-------+------+
2 rows in set (0.01 sec)



-- 对于下面这样的两个表：

-- 项目（项目名称，项目经理，价格）
-- 消费（消费流水号，会员手机号，项目名称，消费金额，消费日期）
-- 每个项目只能有一个项目经理，一个项目经理只能负责一个项目


-- 问题：统计出所负责项目消费总金额大于等于10万的项目和项目经理信息



SELECT
	项目.项目名称,
	项目.项目经理,
	sum( 消费金额 ) 
FROM
	项目,消费 
WHERE
	项目.项目名称 = 消费.项目名称 
GROUP BY
	项目.项目名称 项目.项目经理 
HAVING
	sum( 消费金额 ) > 10000 
ORDER BY
	sum( 消费金额 ) DESC

```

### 对分组限定条件

对分组的结果限定查询查询条件，使用 having 子句，为要分组的标准限定条件。

`HAVING`子句必须写在`GROUP BY`子句之后，其在`RDBMS`内部的执行顺序也排在`GROUP BY`子句之后。



```SQL
--仅查询平均工资大于4000的系，列出这样系的系名和平均工资
select dept_name ,avg(salary) from instructor group by dept_name having avg(salary) > 4000;

select user_id  from user group by user_id 

-- 另外一种思路，把所有系的平均工资查出来，再从这个结果里面查平均工资大于4000的
select   dept_name , avg(salary) from ( select dept_name ,avg(salary)  from instructor group by dept_name ) where avg(salary) > 4000;
```

[参考](https://www.cnblogs.com/youzhibing/p/14175336.html)

### 去重查询

distinct支持单列、多列的去重方式。

- 单列去重的方式简明易懂，即相同值只保留1个。
- 多列的去重则是根据指定的去重的列信息来进行，即只有所有指定的列信息都相同，才会被认为是重复的信息。

```SHELL
mysql> select * from talk_test;
+----+-------+--------+
| id | name  | mobile |
+----+-------+--------+
|  1 | xiao9 | 555555 |
|  2 | xiao6 | 666666 |
|  3 | xiao9 | 888888 |
|  4 | xiao9 | 555555 |
|  5 | xiao6 | 777777 |
+----+-------+--------+

进行单列去重后的结果：
mysql> select distinct(name) from talk_test;
+-------+
| name  |
+-------+
| xiao9 |
| xiao6 |
+-------+
2 rows in set (0.01 sec)

mysql> select distinct(mobile) from talk_test;
+--------+
| mobile |
+--------+
| 555555 |
| 666666 |
| 888888 |
| 777777 |
+--------+
**只会保留指定的列的信息

进行多列去重后的结果：
mysql> select distinct name,mobile from talk_test;
+-------+--------+
| name  | mobile |
+-------+--------+
| xiao9 | 555555 |
| xiao6 | 666666 |
| xiao9 | 888888 |
| xiao6 | 777777 |
+-------+--------+
**只有所有指定的列信息都相同，才会被认定为重复的信息
```


```SQL
-- 所有列都不同，才被认为是重复的。
SELECT DISTINCT * FROM TABLE 

-- 两条记录之间之后只有部分字段的值是有重复的，但是主键唯一
SELECT * FROM TABLE WHERE ID IN (SELECT MAX(ID) FROM TABLE GROUP BY [去除重复的字段名列表,....]) 


```



### 集合查询

```SQL
-- AS 更名的用处：给查询结果的列名改一个名字，给要查询的表改一个名字。尤其是在同一个表中进行比较。

-- 教师表  instructor(ID, name, dept_name, salary)
-- 找出满足下面条件的所有教师的姓名：他们的工资比 Biology 系教师的最低工资要高

-- 方法一
-- 将一个表和它自己进行笛卡尔积运算，然后再过滤
select distinct T.name from instructor as T, instructor as S where T.salary > S.salary and S.dep_tname='Biology';

-- >some 比较，至少比集合中某一个值要大
--方法二
--等价上面的写法，使用 > some 格式判断，子查询查出 Biology 系所有的工资组成集合。再用 >some 比较
select name from instructor where salary > some (select salary from instructor where dep_tname='Biology' );



--找出满足下面条件的所有教师的姓名：他们的工资比 Biology 系每个教师的最高工资要高（他们的工资比Biology中的每个教师的工资都要高）
-- >all 比较，比集合中的所有值都大。
select name from instructor where salary > all (select salary from instructor where dep_tname='Biology' );


-- 找出平均工资最高的系
-- 先查出所有系的平均工资做为一个集合，再在所有系的平均的工资里面比较，找出最大值。
select dept_name from instructor group by dept_name having avg(salary) >=all (select avg(salary) from instructor group by deptname); 

```


### 集合运算

```SQL
-- 并集（union）

-- 并集 union 自动去重，将两个结果集求并集，如果想保留重复，使用union all

-- UNION 必须由两条或两条以上的 SELECT 语句组成，语句之间用关键字 UNION 分隔（因此，如果组合4条 SELECT 语句，将要使用3个UNION 关键字）。
-- UNION 中的每个查询必须包含相同的列、表达式或聚集函数（不过各个列不需要以相同的次序列出）。
-- 列数据类型必须兼容：类型不必完全相同，但必须是DBMS可以隐含地转换的类型（例如，不同的数值类型或不同的日期类型）。

-- 找出在2009年秋季或在2010年春季开课的课程信息
(select course_id from section where semester='Fall' and year=2009) union (select course_id from section where semester='Spring' and year=2010);

-- 也等价于下面这条查询 
select course_id from section where (semester='Fall' and year=2009) or (semester='Spring' and year=2010);



-- 交集（intersect all）

-- 交集 intersect all
-- 找出在2009年秋季和2010年春季同时开课的课程信息
(select course_id from section where semester='Fall' and year=2009) intersect all (select course_id from section where semester='Spring' and year=2010);


-- 差运算 (expect)
-- EXCEPT 子句/运算符用于将两个 SELECT 语句结合在一起，并返回第一个 SELECT 语句的结果中那些不存在于第二个 SELECT 语句结果的记录
-- 找出在2009年秋季开课，2010年春季没开课的课程信息
(select course_id from section where semester='Fall' and year=2009) expect (select course_id from section where semester='Spring' and year=2010);



-- 集合成员资格测试  in ，测试元组是否是集合中的成员。集合一般是由select查出来的。用于筛出在集合中的元素。

-- 找出在2009年秋季和2010年春季同时开课的课程信息
-- in关键字用于测试关素是否是集合中的成员。对于这个例子，3个查询条件：1、秋季；2、2009学期，3、课程id必须2010年春季开课的课程id一样。
-- 使用in关键字来描述这个查询。
select course_id from section where semester='Fall' and year=2009 and course_id in (select course_id from section where semester='Spring' and year=2010);


-- 集合成员资格测试 not in ，测试元组是否是集合中的成员。用于筛出不在集合中的元素。
```


### SQL中的null和DEFAULT

**NULL**

在 SQL 中建表，每个字段后面都加上 NULL 或 NOT NULL 修饰符来指定该字段是否可以为空(NULL)，还是说必须填上数据(NOT NULL)。

MySQL默认情况下指定字段为NULL修饰符，如果一个字段指定为NOT NULL，MySQL则不允许向该字段插入空值(这里面说的空值都为NULL)，因为这是“规定”。

但是在自增列和TIMESTAMP字段中，这个规则并不适用。向这些字段中插入NULL值将会导致插入下一个自动增加的值或者当前的时间戳。

**NULL 不是一个「值」，而是「没有值」。**

在 MySQL 中 null 不能使用任何运算符与其他字段或者变量（函数、存储过程）进行运算。若使用运算数据就可能会有问题。


在写 SQL 条件语句时经常用到 不等于 != 的筛选条件。

此时要注意此条件会将字段为 Null 的数据也当做满足不等于的条件而将数据筛选掉。（也就是说会忽略过滤掉为 null 的数据，导致数据不准确）。







## 运算符



数据库，除了数据的存取之外，还支持各种运算，主要包括 **算数运算** 和 **逻辑运算** 。





| 算数运算符 | 作用 |
| :--------- | :--- |
| +          | 加法 |
| -          | 减法 |
| *          | 乘法 |
| / 或 DIV   | 除法 |
| % 或 MOD   | 取余 |



| 运算符      |      |      |
| ----------- | ---- | ---- |
| =           |      |      |
| <>, !=      |      |      |
| >           |      |      |
| <           |      |      |
| >=          |      |      |
| <=          |      |      |
| BETWEEN     |      |      |
| NOT BETWEEN |      |      |
| IN          |      |      |
| NOT IN      |      |      |
| <=>         |      |      |
| LIKE        |      |      |
|             |      |      |
|             |      |      |



| 逻辑运算符 |                |      |
| ---------- | -------------- | ---- |
| NOT 或！   | 表示逻辑非     |      |
| AND 或 &&  | 表示逻辑与运算 |      |
| OR 或 \|\| |                |      |
| <          |                |      |
| >=         |                |      |







对于MySQL三大数据类型，数值类型，字符，时间



当两个不同类型的数据进行运算时，为了使得它们能够兼容，MySQL 可能会执行隐式的数据类型转换。例如，MySQL 在需要时会自动将字符串转换为数字，反之亦然。



- 如果任意一个参数为 NULL，比较运算符的结果为 NULL，<=> 相等比较运算符除外。NULL <=> NULL 的运算结果为 true，不需要进行类型转换。
- 如果两个参数都是字符串，执行字符串比较。





## 函数



### 数学函数

```sql
ABS(x)                              --返回x的绝对值
BIN(x)                              --返回x的二进制（OCT返回八进制，HEX返回十六进制），其中x为正整数
CONV(N,from_base,to_base)           --数字按照进制互转：N为要被转换的数字，原始进制，目标进制
CEILING(x)                          --返回大于x的最小整数值
EXP(x)                              --返回值e（自然对数的底）的x次方
FLOOR(x)                            --返回小于x的最大整数值
GREATEST(x1,x2,...,xn)              --返回集合中最大的值
LEAST(x1,x2,...,xn)                 --返回集合中最小的值
LN(x)                               --返回x的自然对数
LOG(x,y)                            --返回x的以y为底的对数
MOD(x,y)                            --返回x/y的模（余数）
PI()                                --返回pi的值（圆周率）
RAND()                              --返回０到１内的随机值,可以通过提供一个参数(种子)使RAND()随机数生成器生成一个指定的值。
ROUND(x,y)                          --返回参数x的四舍五入的有y位小数的值
SIGN(x)                             --返回代表数字x的符号的值
SQRT(x)                             --返回一个数的平方根
TRUNCATE(x,y)                       --返回数字x截短为y位小数的结果

-- 数学函数，因为其操作得都是数字，建议仅作用于数字类型的字段或常量上
```

### 聚合函数

聚集函数是以值的一个集合为输入、返回单个值的函数，标准SQL提供了五个固有的聚集函数：

- 平均值 avg
- 最小值 min
- 最大值 max
- 总和 sum
- 计数 count

```sql

--查询Biology系的平均工资
select avg(salary) from instructor where dept_name='Biology'
```



### 字符串函数

```sql
ASCII(char)                     --返回字符的ASCII码值      select ASCII("a") ——> 97
CONCAT(s1,s2...,sn)             --将s1,s2...,s等多个字符串拼接连接成一个字符串  select CONCAT("a","b","c"); ——> abc
CONCAT_WS(sep,s1,s2...,sn)      --将s1,s2...,sn连接成字符串，并用sep字符间隔 select CONCAT_WS("-","a","b","c") ——> a-b-c
INSERT(str,x,y,instr)           --将字符串str从第x位置开始，y个字符长的子串替换为字符串instr，返回结果
FIND_IN_SET(str,list)           --分析逗号分隔的list列表，如果发现str，返回str在list中的位置
LCASE(str)或LOWER(str)          --返回将字符串str中所有字符改变为小写后的结果
LEFT(str,x)                     --返回字符串str中最左边的x个字符
LENGTH(str)                     --返回字符串str的字节数(字节数)   select length(_utf8 '中'); ——> 3 
CHAR_LENGTH(str)                --返回字符串的字符数量(字符个数)  select  char_length(_utf8 '中') ——> 1
BIT_LENGTH(str)                 --返回字符串的比特长度
LTRIM(str)                      --从字符串str中切掉开头的空格
POSITION(substr,str)            --返回子串substr在字符串str中第一次出现的位置
QUOTE(str)                      --用反斜杠转义str中的单引号
REPEAT(str,srchstr,rplcstr)     --返回字符串str重复x次的结果
REVERSE(str)                    --返回颠倒字符串str的结果
RIGHT(str,x)                    --返回字符串str中最右边的x个字符
RTRIM(str)                      --返回字符串str尾部的空格
STRCMP(s1,s2)                   --比较字符串s1和s2
TRIM(str)                       --去除字符串首部和尾部的所有空格
UCASE(str)或UPPER(str)          --返回将字符串str中所有字符转变为大写后的结果


select length(_utf8 '€'), char_length(_utf8 '€')
--> 3, 1



mysql> SET @dolphin:='海豚';
Query OK, 0 rows affected (0.01 sec)

mysql> SELECT LENGTH(@dolphin), CHAR_LENGTH(@dolphin);
+------------------+-----------------------+
| LENGTH(@dolphin) | CHAR_LENGTH(@dolphin) |
+------------------+-----------------------+
|                6 |                     2 |
+------------------+-----------------------+
1 row in set (0.00 sec)
```





**其他函数**

```sql
-- 当前时间: 16:47:33
select curtime();

-- 当前日期+时间  2017-12-27 20:14:56 
select now();


-- sysdate() 日期时间函数跟 now() 类似。一般很少用到
-- 不同之处在于：now() 在执行开始时值就得到了， sysdate() 在函数执行时动态得到值。
select now(), sysdate(),sleep(3), now(),sysdate();
2019-12-29 23:49:27	2019-12-29 23:49:27	0	2019-12-29 23:49:27	2019-12-29 23:49:30

-- 当前MySQL版本  5.7.26-log
select version() 

-- 字符串长度： 3 ，3 ，1   length返回字节长度，char_length返回字符数量
select length("我") , length("你") , char_length("你");

-- 日期格式化  2019-12-27 
select date_format(now(),'%y-%m-%d');



-- md5加密:8a6f60827608e7f1ae29d1abcecffc3a
select md5("andyqian");
-- 字符串拼接 andyqian
select concat("andy","qian");

-- if函数判断

select t.name,if(t.weight<80,'正常','肥胖') 体重 from t_customer t


-- 当前时间：2022-05-27
select DATE(CURRENT_TIME)
```


### 窗口函数


窗口函数（Window Function）是 SQL:2013 标准中提出的，在后续标准版本的更新中也多次扩展，最新的版本是 SQL:2011 中的标准。

从某些方面来说，窗口函数与聚合函数（Aggregate Function）有些类似，他们都是对一系列的行进行聚合计算，然而不同于聚合函数的是，窗口函数的输出并不是被聚集到单独的一行。像 SUM, AVG, COUNT 这些聚合函数最终输出都是一行记录。

窗口函数可以通过计算每行周围窗口上的集合值来分析数据，例如：计算一定记录范围内、一定值域内、或者一段时间内的累计和以及移动平均值等等。

之所以使用窗口这个术语，是因为对结果的处理使用了一个滑动的查询结果集范围。

大部分数据库，尤其是商业数据库都支持SQL标准中定义的部分窗口函数，但是MySQL一直没有支持这个特性。窗口函数在MySQL社区一直呼声很高，却一直没有被实现，直到 MairaDB 10.2 和 MySQL8.0 才响应了客户的需求，实现了部分窗口函数，并且在持续完善中，我们就来简单介绍一下 MairaDB 的窗口函数。

**语法**

窗口函数查询指定使用 OVER 关键字，默认情况下，用于计算的行集合（Window，窗口）是整个数据集，并且可以用 ORDER BY 子句排序。PARTITION BY 子句可以用于将窗口缩小到特定的集合内。


窗口排序主要是指非全局排序，需要在某个维度下进行排序。例如说现在想看各个department内部cost最多的人，这时候不能全局order by了

我们需要选取出每个科目最高的成绩以及对应的同学和科目


```SQL
USE db_test;

DROP TABLE IF EXISTS  student ;

CREATE TABLE  student (
	name VARCHAR(20) NOT NULL,
	subject VARCHAR(20) NOT NULL,
	score INT NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

insert into student(name,subject,score) 
    values 
("小明","语文",66),
("小明","数学",67),
("小明","英语",69),
("小红","语文",65),
("小红","数学",99),
("小红","英语",88),
("小强","语文",60),
("小强","数学",72),
("小强","英语",92);
```

```SQL

-- 计算每个学生的自己排名（组内排序）
SELECT name, subject, score,
      row_number() OVER (partition BY name ORDER BY score DESC) as n
FROM student ;




--每个科目最高的成绩以及对应的同学和科目

--思路分析，首先按照科目分组并聚合求最大值。将其结果集与原表关联，查出同学名称即可。

	SELECT
		b.name,
		b.subject,
		b.score
	FROM
		(
			SELECT
				subject,
				MAX(score) AS score
				FROM
					student
				GROUP BY
					subject
		) a
	JOIN student b ON a.subject = b.subject
	AND a.score = b.score

```










[参考](https://www.kancloud.cn/taobaomysql/monthly/181781)


## 触发器

触发器是每当发生与表相关的事件时自动调用的函数。事件可以是以下任何一种：INSERT，UPDATE，DELETE 或 TRUNCATE。

触发器是绑定到表的特殊的用户自定义函数。**触发器和用户自定义函数的不同之处在于触发事件(当表发生变化时)发生时会自动调用**。

触发器一旦由某用户定义，任何用户对触发器规定的数据进行更新操作，均自动激活相应的触发器采取应对措施。

触发器本质上是一条SQL语句，当对数据库中的表做更新操作时，它自动被系统执行。


触发器三要素：

-- 事件：引起触发器动作的事件，通常是更新操作。

-- 条件：触发器将测试条件是否满足。如果条件满足，就执行相应的操作，否则什么也不做。

-- 动作：如果触发器测试满足预订的条件，就由 DBMS 执行这些动作。这些动作可以是一系列对数据库的操作

```sql

-- 创建触发器的语法

CREATE [DEFINER = user] TRIGGER trigger_name tirgger_time trigger_event
ON tbl_name FOR EACH ROW
BEGIN
    trigger_stmt
END

-- trigger_name：触发器的名称
-- tirgger_time：触发时机，为BEFORE或者AFTER
-- rigger_event：触发事件，为INSERT、DELETE或者UPDATE
-- tb_name：表示建立触发器的表明，就是在哪张表上建立触发器
-- trigger_stmt：触发器的动作程序体，可以是一条SQL语句或者是用BEGIN和END包含的多条语句



```




## 存储过程





### 流程控制语句



| 语句                                                         |      |      |
| ------------------------------------------------------------ | ---- | ---- |
| [`CASE`](https://dev.mysql.com/doc/refman/8.0/en/flow-control-functions.html#operator_case) |      |      |
| [`IF()`](https://dev.mysql.com/doc/refman/8.0/en/flow-control-functions.html#function_if) |      |      |
| [`IFNULL()`](https://dev.mysql.com/doc/refman/8.0/en/flow-control-functions.html#function_ifnull) |      |      |
| [`NULLIF()`](https://dev.mysql.com/doc/refman/8.0/en/flow-control-functions.html#function_nullif) |      |      |



