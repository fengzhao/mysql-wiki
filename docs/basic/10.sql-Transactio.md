## 数据库事务



数据库事务(Database Transaction)，一般是指要做的或所做的事情。在计算机术语中是指访问并可能更新数据库中各种数据项的一个程序执行单元(unit)。

**一个数据库事务通常包含对数据库进行读或写的一个操作序列**。它的存在有以下两个目的：

- 为数据库操作序列提供了一个从失败中恢复到正常状态的方法，同时提供了数据库即使在异常状态下仍能保持一致性的方法。
- 当多个应用程序在并发访问数据库时，可以在这些应用程序之间提供一个隔离方法，以防止彼此的操作互相干扰。

传统关系型数据库 **事务** 是访问并可能更新各种数据项的一个程序执行 **单元** (unit)。

事务由一个或多个步骤组成，一般使用形如 `begin transaction` 和 `end transaction` 语句或者函数调用作为事务界限。

**事务内的所有步骤必须作为一个单一的、不可分割的单元去执行。**

因此事务的结果只有两种：**1. 全部步骤都执行完成，2. 任一步骤执行失败则整个事务回滚。**

事务是应用程序中一系列严密的操作，所有操作必须成功完成，否则在每个操作中所作的所有更改都会被撤消。

也就是说事务需要具有原子性，一个事务中的一系列的操作要么全部成功，要么一个都不做。

一个事务被提交给了DBMS（数据库管理系统），则DBMS需要确保该事务中的所有操作都成功完成且其结果被永久保存在数据库中，如果事务中有的操作没有成功完成，则事务中的所有操作都需要被回滚，回到事务执行前的状态（要么全执行，要么全都不执行）;

同时，该事务对数据库或者其他事务的执行无影响，所有的事务都好像在独立的运行一样。

但在现实情况下，失败的风险很高。在一个数据库事务的执行过程中，有可能会遇上事务操作失败、数据库系统/操作系统失败，甚至是存储介质失败等情况。

这便需要DBMS对一个执行失败的事务执行恢复操作，将其数据库状态恢复到一致状态（数据的一致性得到保证的状态）。

为了实现将数据库状态恢复到一致状态的功能，DBMS通常需要维护事务日志以追踪事务中所有影响数据库数据的操作。


事务应该具有 4 个属性：原子性、一致性、隔离性、持久性。这四个属性通常称为 ACID 特性。

- 原子性(Atomicity)：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。
- 一致性(Consistency)：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态的含义是数据库中的数据应满足完整性约束。
- 隔离性(Isolation)：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。（取决于RDBMS的隔离级别）
- 持久性(Durability)： 一个事务一旦提交，他对数据库的修改应该永久保存在数据库中。


在同一个RDBMS中，用一个常用的 **A账户向B账号汇钱** 的例子来说明如何通过数据库事务保证数据的准确性和完整性。熟悉关系型数据库事务的都知道从帐号A到帐号B需要6个操作：

    1. 从A账号中把余额读出来（500）。
    
    2. 对A账号做减法操作（500-100）。
    
    3. 把结果写回A账号中（400）。
    
    4. 从B账号中把余额读出来（500）。
    
    5. 对B账号做加法操作（500+100）。
    
    6. 把结果写回B账号中（600）。

???+ 数据库事务

    - 原子性：一个事务必须被视为一个不可分割的最小工作单位，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，不能只执行一部分操作。
    
        保证1-6所有过程要么都执行，要么都不执行。一旦在执行某一步骤的过程中发生问题，就需要执行回滚操作。 假如执行到第五步的时候，B账户突然不可用（比如被注销），那么之前的所有操作都应该回滚到执行事务之前的状态。


    - 一致性：一致性要求数据库总是从一个一致性的状态转换为另外一个一致性的状态
    
        在转账之前，A和B的账户中共有500+500=1000元钱。在转账之后，A和B的账户中共有400+600=1000元。也就是说，数据的状态在执行该事务操作之后从一个状态改变到了另外一个状态。同时一致性还能保证账户余额不会变成负数等。
    
    - 隔离性：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。（取决于RDBMS的事务隔离级别）
    
        在A向B转账的整个过程中，只要事务还没有提交（commit），查询A账户和B账户的时候，两个账户里面的钱的数量都不会有变化。
        如果在A给B转账的同时，有另外一个事务执行了C给B转账的操作，那么当两个事务都结束的时候，B账户里面的钱应该是A转给B的钱加上C转给B的钱再加上自己原有的钱。
    
    - 持久性：事务一旦提交，所做的状态就会永久保存在数据库中，即使系统奔溃，修改的数据也不会丢。
    
        一旦转账成功（事务提交），两个账户的里面的钱就会真的发生变化（会把数据写入数据库做持久化保存）。





### **查询会不会开事务？**

MySQL 默认是 autocommit=1，也就是说默认是立即提交。

如果想开启事务，先设置 autocommit=0，然后用 START TRANSACTION、 COMMIT、 ROLLBACK 来使用具体的事务。









## 并发控制

> 在计算机科学，特别是程序设计、操作系统、多处理机和数据库等领域，并发控制（Concurrency control）是确保及时纠正由并发操作导致的错误的一种机制。

我们都知道事务的几种性质，数据库为了维护这些性质，尤其是 **一致性** 和 **隔离性** ，一般使用 **加锁** 这种方式。

同时数据库又是个高并发的应用，同一时间会有大量的并发访问，如果加锁过度，会极大的降低并发处理能力。

**所以对于加锁的处理，可以说就是数据库对于事务处理的精髓所在。**

数据库管理系统（DBMS）中的并发控制的任务是 **确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和一致性以及数据库的统一性。**



### 脏读现象

脏读是指在数据库访问中，当一个事务A正在访问数据，并且对数据进行了修改，而这种修改事务还没有提交到数据库中，这时另外一个事务B也访问这个数据，然后使用了这个数据。

然后A又进行回滚操作，则事务B访问的数据是无效的。即上述转账例子中，转账事务进行到一半的时候，此时另外一个事务去读了A账号的余额，然后以前的转账事务回滚，A的余额变回以前的值。

此时后面读余额的事务即为脏读。


举一个实际场景中的例子：两个火车票代售点，同时读取12306数据库中的某趟列车的车票余票数量为X，然后同时卖出一张票，然后同时提交了X-1到数据库中，这样就造成了卖了两张票，而库中记录只减了一张。生这种情况的原因是因为两个事务读入同一数据并同时修改，其中一个事务提交的结果破坏了另一个事务提交的结果，导致其数据的修改被丢失，破坏了事务的隔离性。并发控制要解决的就是这类问题。



###  重复读现象（前后多次读取，数据内容不一致）

事务A在执行读取操作，由整个事务A比较大，前后读取同一条数据需要经历很长的时间 。而在事务A第一次读取数据，比如此时读取了小明的年龄为20岁，事务B执行更改操作，将小明的年龄更改为30岁，此时事务A第二次读取到小明的年龄时，发现其年龄是30岁，和之前的数据不一样了，也就是数据不重复了，系统不可以读取到重复的数据，成为不可重复读。



### 幻读





## 数据库隔离级别


ANSI/ISO SQL定义的标准隔离级别有四种，从高到底依次为：

- 序列化(Serializable)
- 可重复读(Repeatable reads)
- 读已提交(Read committed)
- 读未提交读(Read uncommitted) 





| 隔离级别   | 脏读现象 | 重复读现象 | 幻读现象 |
| ---------- | -------- | ---------- | -------- |
| 读未提交读 | 可能     | 可能       | 可能     |
| 读已提交   | 不可能   | 可能       | 可能     |
| 可重复读   | 不可能   | 不可能     | 不可能   |
| 序列化     |          |            |          |




## 数据库锁

在 DBMS 中，当并发事务同时访问一个资源时，有可能导致在不同事务内部看到的数据不一致。

因此需要一种机制来将数据访问顺序化，以保证数据库数据的一致性。**锁就是其中的一种机制。**

可以简单理解为当某个事务在操作开始时，锁定某一个资源对象（比如某个表，比如某一行），在这个事务操作结束之前，不允许其他事务操作这个对象。





### 读锁写锁

读锁是共享的，是互相不阻塞的，多个数据库事务在同一时间读取同一资源，互不干扰。（读与读之间不互斥）

写锁是排他的，会阻塞其他的写锁和读锁，写锁有更高的优先级。（即我在写资源的时候，其他用户无法读写）



**一种提高共享资源并发性的方式就是让锁定对象更有选择性。尽量只锁定需要修改的部分数据，而不是所有的资源，锁定的资源越少，系统的并发性更好。**





## 锁的粒度

根据锁定对象的粒度和锁定范围，可以大致分为：

- 全局锁（整个实例）

- 表锁（table lock）（被锁定的资源的粒度是表）

- 行锁 （row lock）（被锁定资源的粒度是行）

  ```sql
  -- InnoDB 行级锁是通过给索引上的索引项加锁来实现的，InnoDB行级锁只有通过索引条件检索数据，才使用行级锁;
  -- 否则，InnoDB使用表锁，在不通过索引(主键)条件查询的时候，InnoDB是表锁而不是行锁。
  
  -- 如果没有使用索引或索引失效，行锁就会变成表锁
  SELECT c1 FROM t WHERE c1 = 10 FOR UPDATE;
  ```

  https://www.jianshu.com/p/1f4940c134b3



## 读锁写锁（共享锁/排他锁）

读锁写锁也被称为共享锁和排他锁

**InnoDB实现了 行级别的共享锁和排他锁。**

- **读锁是共享的，是互相不阻塞的，多个客户在同一时间读取同一资源，互不干扰。（即我在读资源的时候，其他人只能读不能写）**
- **写锁是排他的，会阻塞其他的写锁和读锁，写锁有更高的优先级。（即我在写资源的时候，其他用户无法读写）**
- 允许不同事务之间共享加锁读取，但不允许其它事务修改或者加入排他锁。





**隐式加锁**：InnoDB，在执行事务过程中会自动加锁，当事务 COMMIT 完成或 ROLLBACK 时锁会自动释放。

**显式加锁**：

```sql
-- 全局加锁，对整个数据库实例加锁
-- 整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：
-- 数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。DDL和DML都会被阻塞
Flush tables with read lock ;

-- 全局锁的使用场景：一般是数据库逻辑备份，或某种特殊业务需求要让整个库临时只读。


-- 对某个对象（一般是行锁）显式加读锁，如果这行对某些行加锁的时候，其他事务还在写入，那么这行select会一直等到其他事务提交才会读到最新的数据。
SELECT ... FOR SHARE
-- 等价于 SELECT...LOCK IN SHARE MODE，后面这种写法可以兼容老版本，for share这种写法可以支持更多特性。
-- 在 MySQL8.0.22之前， SELECT ... FOR SHARE需要select权限外，还需要 DELETE, LOCK TABLES, or UPDATE 三个之一
-- 在 MySQL8.0.22之后， SELECT ... FOR SHARE只需要select权限



-- 显式加写锁 
SELECT...FOR UPDATE 

-- 显示加读锁或写锁
-- 如果在某个线程A中执行lock tables t1 read, t2 write; 这个语句，
-- 那么其他线程写t1、读写t2的语句都会被阻塞。同时，线程A在执行unlock tables之前，也只能执行读t1、读写t2的操作。连写t1都不允许，自然也不能访问其他表。
lock tables … read/write
-- 释放锁 unlock tables


```



### 读锁

```sql
-- 注意：这里都是显示开启事务，故意执行事务不提交。
-- session1
start transaction;
select * from test where id = 1 lock in share mode;
-- 在session1线程里面，它自己也无法获得写锁
update emp set ename = 'ALLEN1111' where ename='ALLEN' ;

-- session2
start transaction;
select * from test where id = 1 lock in share mode;

-- 此时 session1 和 session2 都可以正常获取结果，那么再加入 session3 排他锁读取尝试

-- session3:
start transaction;
-- session3的SQL可以换成任意的写语句（update,insert,delete,alter效果都是一样）
select * from test where id = 1 for update; 
-- Lock wait timeout exceeded; try restarting transaction -- 在 session3 中则无法获取数据，直到超时或其它事物 commit



-- 通过 information_schema.INNODB_TRX 表里的 trx_mysql_thread_id 可以找到锁表的线程ID
-- 再回 information_schema.`PROCESSLIST` 表里面去查，就可以找到相应的连接。
SELECT * FROM information_schema.INNODB_TRX

```





### 写锁

当一个事务加入排他锁后，不允许其他事务加共享锁或者排它锁读取，更加不允许其他事务修改加锁的行。

```sql
-- session1:
-- session对资源添加写锁
start transaction;
select * from test where id = 1 for update;

-- session2(session2对test的增删改查任何访问都会被阻塞)
-- 如果session1的事务一直不提交或回滚，那么session2超时
start transaction;
select * from test where id = 1 for update;

```



### **意向锁**

MySQL支持多种粒度的锁（表锁，行锁）。它允许`行级锁`与`表级锁`共存，而 **意向锁** 其实就是其中的一种`表锁`。

```sql
-- 表级别的锁

-- 用读锁锁表，会阻塞其他事务修改表数据。
LOCK TABLE my_tabl_name READ; 
-- 用写锁锁表，会阻塞其他事务读和写。
LOCK TABLE my_table_name WRITe; 


-- 行级别的锁（查询走索引）
-- 读锁
SELECT ... FOR SHARE
-- 写锁
SELECT ... FOR UPDATE


-- 考虑这样的一个例子：

-- 事务A锁住了表中的一行，让这一行只能读，不能写。（对某行加读锁）

-- 事务B申请整个表的写锁。（如果事务B申请成功，那么理论上它就能修改表中的任意一行，这与A持有的行锁是冲突的。）

-- 数据库需要避免这种冲突，就是说要让B的申请被阻塞，直到A释放了行锁。

-- 数据库要怎么判断这个冲突呢？（即B事务准备对全表加写锁之前的检测）

-- step1：判断表是否已被其他事务用表锁锁表。
-- step2：判断表中的每一行是否已被行锁锁住。（由于这样的效率很低，需要遍历整个表。）

-- 于是意向锁出现了，在意向锁存在的情况下，事务A必须先申请表的意向共享锁，成功后再申请一行的行锁。

-- 在意向锁存在的情况下，上面的判断可以改成

-- step1：不变
-- step2：发现表上有意向共享锁，说明表中有些行被共享行锁锁住了，因此，事务B申请表的写锁会被阻塞。

-- 注意：申请意向锁的动作是数据库完成的，就是说，事务A申请一行的行锁的时候，数据库会自动先开始申请表的意向锁，不需要我们使用代码来申请。

-- 所以准确来讲，SELECT ... FOR SHARE 持有的是 IS lock（意向读锁）  
-- 所以准确来向，SELECT ... FOR UPDATE 持有的是 IX lock（意向写锁） 

```



