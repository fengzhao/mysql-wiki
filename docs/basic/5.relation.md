
# 关系模型

任何学科的专业人士都需要知道自己所在专业的基础。所以，如果你是数据库领域的专家，就需要知道关系模型，因为它是数据库领域的基础（至少是基础的主体）。

当今，不论是商业化的应用培训还是学术化的理论课程，任何课程都至少提到关系模型的内容，但是大多数教学从结果上看都很糟。

可以确定的是，数据库领域中的大多数人并没有很好地理解关系模型。造成这种情形的可能原因包括：

- 脱离实践的关系模型教学。就是说，至少对于初学者，理解关系模型知识的关联性或关系模型所要解决的问题是很难的。

- 授课的教师本身并没有充分理解或意识到关系模型知识内容的重要性。

- 在实践中更可能存在的问题：就根本没教关系模型，授课中取而代之的是 SQL 语言，或者 SQL 语言的一些方言（比如 Oracle 的 SQL 方言）。


SQL语言、数据库和关系模型三者经常被混淆。数据库的功能主要是存储数据，这些数据符合对现实世界一部分所建立的特定模型。

相应地，数据库必须提供可靠的基础设施（infrastructure），无论何时都能够让多个用户使用同一些数据，且在数据被修改时不破坏数据
完整性。这要求数据库能够处理来自不同用户的 “ 资源争用（contention ） ” ，并能在事务（transaction）处理过程中遇到机器故障等极端情况下也保持数据一致性。

结构化查询语言（Structured Query Language，SQL）无非是一种语言，虽然它与数据库关系密切。将SQL语言和关系数据库等同视之，或者更糟——与关系理论等同视之，都是错误的。这种错误就好比将掌握了电子表软件或文字处理软件视为掌握了 “ 信息技术 ” 。

实际上 ，有些软件产品并非数据库，但它们也支持SQL

简而言之，关系理论支持我们通过一组关系运算符来搜寻满足某些条件的数据，这些关系运算符几乎支持任何基本查询。

关键在于，关系理论有严格的数学基础，我们完全可以相信同一结果可由不同的关系表达式来获得，正如在算术中246/369完全等于2/3一样。

关系理论只关心如何根据查询条件取得正确的数据集；而对我们这些实践者（而非理论家）而言，关系操作阶段只负责准确无误地找出属于最终数据集的记录，而不同行的相同字段的关系并不是在这个阶段处理，而是完全属于排序操作。

关系理论并不涉及各种统计功能（例如百分位数等），而这些统计功能经常出现在不同的 “ SQL方言（dialect ） ” 当中。关系理论所研究的是集合（set），但并不涉及如何为这些集合排序。尽管有许多关于排序的数学理论，但它们都与关系理论无关。

当SQL引擎处理查询时，会用优化器找出执行查询最高效的方式。此时关系理论又可以大有作为了，优化器借助关系理论，对开发者提供的语义无误的原始查询进行有效的等价变换，即使原始查询编写得相当笨拙。

## 原理而非产品

“为什么你作为数据库领域专业人员需要懂得关系模型”这个问题是值得花时间去搞清楚的。原因是：关系模型不是特定的产品；相反，它关注于原理。

这里的原理指的是什么？这里有一个定义（来源于《Chambers Twentieth Century Dictionary》）。

> "原理：基础的、自然本质的、理论基础的源头，根本，本源：其他课题得以建立或发展的基础事实。"

关于原理的关键在于：原理具有普适性、稳定性。相反，产品和技术（以及 SQL 语言）总是在改变——而原理不变。举例来说，假设你懂 Oracle；事实上，可以假设你是
Oracle 专家。而如果你仅仅懂得 Oracle，那么你的知识就不一定是可移植的，比如 DB2 或 SQL Server 环境（甚至有可能会阻碍你在新环境中的进步）。但是如果你懂得底层原理（也就是说，如果你懂得关系模型），那么你就掌握了可移植的知识和技巧：这些知识和技巧可以应用于任何环境，永不过时。

> 热衷于实践而不要理论的人好像一个水手登上了一只没有舵和罗盘的船，他拿不准该往哪里航行。实践应以好的理论为基础。



什么是数据库？数据库（database）可以简单的认为是一个数据集合，这些数据互相关联，映射了真实世界的一些数据模型，例如一个班级（class）里的学生（student），学生会选课（student-lesson），老师会上课（teacher-lesson），学生会有考试成绩（student-grade），它们相互关联相互影响。

在数据库的上层，有提供给用户查询数据的语言，最常见的即 SQL（Structured Query Language），这门课程主要专注于如何实现一个功能完备的数据库系统。




1970 年代，数据存储并没有统一的概念和实现，每个应用都需要自己去实现一套数据存储的方案，这非常不利于应用和程序的移植。于是 Ted Codd 在 1970 年提出了关系模型（relational model）的概念，主要有以下三个关键点：

- 数据存储在简单的数据结构中

- 能够通过高级语言访问数据库

- 物理存储的细节交给数据库管理系统实现

数据模型（data model）指的是描述数据库中数据的概念集合，常见的数据模型有以下几种：

- Relational: 大多数DBMS为关系型数据库
- Key/Value, Graph, Document, Column-family :  NoSQL数据库（列簇数据库如RocksDB）
- Array/Matrix: Machine Learning会使用
- Hierarchical: 层次模型（不用了）
- Network: 网状模型（不用了）

其中 relational 是最常见、应用最广泛的关系模型，大多数常见的数据库系统例如 MySQL、PostgreSQL、Oracle 都是关系模型；K/V、Graph、Document、Column Family 属于 NoSQL 类型，例如 rocksdb、neo4j、MongoDB、Redis；Array/Matrix 常用于机器学习领域，例如 TileDB；Hierarchical 和 Network 分别代表层次和网状模型，是很古老的数据模型了，目前已经过时。





## 关系模型基本逻辑概念


???+ 实体
     实体是现实世界中可以区分于其他对象的一个事物或对象，每个实体有一组性质，其中一些性质的值可以唯一标识一个实体。
     实体是首要的数据对象，常用于表示一个人、地方、某样事物或某个事件。一个特定的实体被称为实体实例（entity instance或entity occurrence）。<br>
     例如每个人就是一个实体，人有姓名，性别，年龄，身份证等属性。身份证号就可以唯一标识一个人。**可以简单把一个实体等价认为一行数据。** <br>
     
     - 实体属性：实体通过一组属性来表示，属性是实体集中的每个实体都拥有描述性信息，比如每个student实体都有 student_id，sex，name，age等属性。<br>
     - 简单属性：不可以进一步拆分的属性，例如：student实体的sex属性只能是male或female。<br>
     - 复合属性：可以进一步拆分的属性，例如：student实体的name属性可以进一步拆分为：first_name和last_name两个子属性。<br>
     - 单值属性：每个特定实体中的某个属性只有一个值。即student表中任何一个行的sex列都只能是一个值，male和female。<br>
     - 多值属性：每个特定实体中的某个属性可能有多个值。即student表中任何一个行的phone_number列可能有多个值，一个学生有多个电话号码。<br>
     - 派生属性：这类属性的值可以从别的相关属性或实体派生出来（也就是可通过别的属性计算出来）。即年龄是通过当前时间和出生日期计算出来的。<br>

???+ 实体集
     实体集：是相同类型即具有相同属性的实体集合，例如：实体集 student 可以用来标识大学中所有学生的集合。**可以简单的把实体集等价认为是一张表。**
     在数据库建模过程中，


???+ 联系
     联系：实体与实体之间相互关联，存在关联关系，例如：student实体与insructor实体之间存在关系，表示教师是学生的导师。关系表示一个或多个实体之间的联系。关系依赖于实体，一般没有物理概念上的存在。关系最常用来表示实体之间，一对一，一对多，多对多的对应。关系的构图是一个菱形，关系的名称一般为动词<br>

???+ 联系集
     联系集：相同类型联系的集合，例如：student与insructor这两个实体集中的多个教师与多个学生之间存在导师-学生关系（advisor）。每个实体集可以参与多个联系集。<br>

     - 联系集的度：参与联系集的实体集的数量称为度，我们常见的是二元联系集，是涉及两个实体的联系集。度为3。<br>

     - 参与：如果实体集中的每个实体都参与到联系集中，则称为完全参与，如果只有部分实体参与到联系中，称为部分参与。<br>


???+ 映射基数
     映射基数（基数比率）：表示一个实体通过联系集可能关联的实体个数。<br>

     - 一对一：A实体集中的一个实体最多与B实体集中一个实体关联，B实体集中的一个实体最多与A实体集中一个实体关联。**每个学生只能有一个老师，每个老师只能有一个学生。**<br>
     - 一对多：A实体集中的一个实体可能与B实体集中任意个实体关联，B实体集中的一个实体最多与A实体集中一个实体关联。**每个学生可以有任意个老师，每个老师只能有一个学生。**<br>
     - 多对一：**多个学生对应一个老师。**<br>
     - 多对多：**多个学生对应多个老师。**<br>



???+ 表
     - 在关系数据库中，表也被叫做关系，它是一种行列形式的二维表。其实就是一系列二维数组的集合，用于存储各种信息。<br>
     - 关系模型中用 **元组** 指代 **行** ，用 **属性** 指代 **列**。<br>
     - 用 **关系实例** 指代一个关系中的特定实例，也就是一行数据。<br>
     - 对于关系中的每个属性的取值范围，称为该属性的域，对于域中的元素，如果是不可再分的单元，则称为为这个域是**原子性**的。<br>



## 关系模型基础

关系模型是逻辑模型中的一种，也是现在普遍使用的一种。其由实体、属性和关系三者构成。其可以使用一张二维表进行关系呈现。

关系模型由 ==数据结构、数据操作和完整性约束== 三部分构成:

- 构造机制（数据结构）：其中数据结构是指数据自身的组织形式；
- 构造机制（数据结构）：数据操作是指对数据进行的增删改查的各种访问操作，而对数据的查询是该模型中最为重要的操作；
- 约束机制（数据约束）：完整性约束是指满足现实条件的数据值的范围等


作为数据库的一种数据模型，关系模型提供了一组完整性规则或限制。==完整性约束用于确定关系数据库里数据的准确性和一致性。==

在关系型数据库里，完整性约束包括域完整性、实体完整性、引用完整性以及用户定义完整性。


关系永远也不会包含重复的元组。这一性质是成立的，因为主体的定义是元组的集合，而数学上的集合不包含重复元素。

然而，SQL不是这样的。一般情况下SQL表允许包含重复行。关系的元组是无序的。也是因为数学上的集合是无序的。

关系的属性也没有从左到右的顺序，

### 完整性约束


数据库的完整性指数据的正确性(correctness)和相容性(compat-ability)。

- 正确性：指数据符合现实语义。
- 相容性：指同一对象在不同关系表中的数据是符合逻辑的。

为了维护数据库的完整性，数据库管理系统(DBMS)必须实现如下功能：

- 定义完整性约束
在SQL标准中定义了一系列定义完整性约束的语句。

- 完整性检查
检查数据是否符合完整性约束条件的机制成为完整性检查。完整性检查通常在INSERT、UPDATE、DELETE语句执行后开始检查，也可在事务提交时检查。

- 违约处理
在DBMS发现用户的操作违背了完整性约束条件，将采取一定的操作。

==关系数据库管理系统使得完整性控制成为其核心支持的功能，从而能为所有用户和应用提供一致的数据库完整性。==




#### 域完整性

域完整性，是指给定列的取值范围（即输入的有效性），比如性别取值应为男或女。<br>

强制域有效性的方法有：

- 限制数据类型（通过数据类型）: 建表时指定字段的数据类型，自然而然就限制了字段的取值范围。<br>
- 格式（通过 CHECK 约束和规则）：check约束，指定某个字段的取值范围。例如用户名必须大写、余额不能小于零等。<br>
- 可能值的范围（通过 FOREIGN KEY 约束、CHECK 约束、DEFAULT 定义、NOT NULL 定义和规则）。<br>

```SQL
CREATE TABLE student (
		stuno CHAR(11) PRIMARY KEY ,
		stuname VARCHAR(20) ,
		stuage SMALLINT,
		stusex CHAR(1) CHECK (stusex in ('F','M'))  /* check约束，指定范围 */ 
	    schno CHAR(3)  REFERENCES school(schno) ON CASCADE DELETE 

)

-- 存储了正常价及折扣价，您想确保折扣价低于正常价

CREATE TABLE products (
    no INTEGER,
    name TEXT,
    price NUMERIC CHECK (price > 0),
    discounted_price NUMERIC CHECK (discounted_price > 0),
    CHECK (price > discounted_price)
);
```



> 现在互联网业务系统中，数据库往往是瓶颈，字段限制，往往可以在前端校验完成，外键约束，实体完整性等，可以在后端完成，不一定要完全依赖数据库的各种约束。这样可以有效减少数据库计算判断的压力。


#### 实体完整性

实体完整性，是指使用**主键**来唯一地标识一个实体。

在关系数据库中，一条记录代表一个实体。而实体是可以相互区分、识别的，也即它们应具有某种唯一性标识（该标识不能取相同的值，也不能为空）。<br>

实体完整性强制表的标识符列或主键的完整性（通过索引、UNIQUE 约束、PRIMARY KEY 约束或 IDENTITY 属性）。<br>


**实体完整性检查和违约处理**
使用PRIMARY KEY短语定义关系的主码后。每当用户插入或更新记录时，DBMS都会自动进行实体完整性检查：

- 检查主码是否唯一，若不唯一便拒绝插入或修改。
- 检查主码的各个属性是否为空，若存在为空便拒绝插入或修改。


#### 引用完整性

引用完整性/参照完整性，就是定义外键与主键之间的引用规则。

参照的完整性要求**关系中不允许引用不存在的实体**。也称引用完整性，参照完整性描述了实体间的联系。参照完整性一般是指多个实体表之间的引用关系。

参照完整性规则其实就描述了外键的定义。这个规则实际上是说：如何B参照A，那么A必须存在。



**断言**

在SQL中可以使用数据定义语言中的`CREATE ASSERTION`语句，通过声明性断言(declarative assertions)来制定更具一般性的约束。

> 在断言创立后，任何对断言中所涉及的关系的操作都会触发DBMS对断言的检查，任何使断言不为真值的操作都会被拒绝执行。

```SQL
CREATE ASSERTION <断言名> <CHECK子句>

-- 示例，限制一门课最多60个学生选修
CREATE ASSERTION ASSE_SC_CNUM2
    CHECK (60 >= ALL(SELECT COUNT(*) FROM SC GROUP BY cno, term))
```

???+ 码

     码是数据系统中的最基本的概念。所谓码就是能唯一标识实体的属性，它是整个实体集的性质，而不是单个实体的性质。

     一个元组的属性值必须是能够唯一区分元组的，换句话说，一个关系中没有两个元组在所有属性上的取值都相同。即表中没有完全重复的行。

    - 超码：一个或多个属性的集合，这些属性可以使我们在一个关系中唯一标识一个元组，这个属性集合被称为超码（super key），如果K是超码，那么K的任意超集也是超码。

    - 候选码：存在这样得一些超码，即他们得任意真子集都不能成为超码。这样的最小超码称为候选码（candidate key）

    - 主码：主码（primary key，中文又称主键）是被数据库设计者被选中的，主要用来在一个关系中区分不同元组的候选码。

    - 外码：外码（foregin key，中文又称外键），假设在某个表R1中存在一个属性，这个属性是另外一个表R2的主键。则这个属性在R1上被称为参照R2的外码（外键）。
           外码用于表示两个或多个实体间的关联关系。外码实际上是关系中的一个或多个属性，这些属性引用其他关系的主码或（候选码）


???+ 函数依赖
     设一个关系为R(U)，X和Y为属性集U上的子集，若对于X上的每个值都有Y上的一个唯一值与之对应，则称X和Y具有函数依赖关系，并称X函数决定Y，或称Y函数依赖于X，记作X→Y，称X为决定因素。

     数据依赖是一个关系内部属性与属性之间的一种约束关系。这种约束关系是通过属性间值的相等与否体现出来的数据间的相关联系。

     函数依赖指的是在数据库中，各种不同属性（或者属性集合）关系间的一种"约束"，也可以看作属性之间的一种映射，也是一种"依赖性"，存在"当且仅当"的前提。

     若在一张表中，在属性（或属性组）X的值确定的情况下，必定能确定属性Y的值，那么就可以说Y函数依赖于X，写作 X → Y。
     
     也就是说，在数据表中，不存在任意两条记录，它们在X属性（或属性组）上的值相同，而在Y属性上的值不同。这也就是“函数依赖”名字的由来。



???+ 部分函数依赖
     设一个关系为R(U)，X和Y为属性集U上的子集，若对于X上的每个值都有Y上的一个唯一值与之对应，则称X和Y具有函数依赖关系，并称X函数决定Y，或称Y函数依赖于X，记作X→Y，称X为决定因素。



???+ 传递函数依赖
     设一个关系为R(U)，X和Y为属性集U上的子集，若对于X上的每个值都有Y上的一个唯一值与之对应，则称X和Y具有函数依赖关系，并称X函数决定Y，或称Y函数依赖于X，记作X→Y，称X为决定因素。


???+ 第一范式
     第一范式最好理解，如果一个关系中的所有属性的域都是原子的，那么这个关系属于第一范式。（属性不可拆分）。

     在当前的任何关系数据库管理系统RDBMS中，设计出不符合第一范式的数据库都是不可能的。因为这些DBMS不允许你把数据库表的一列再分成二列或多列。

    
    ```SQL
    （学号，姓名，系名，系主任，课程名，分数）
     主码（学号，课程名） 

    -- 对于（学号，课名） → 姓名，有 学号 → 姓名，存在非主属性 姓名 对码（学号，课名）的部分函数依赖。
    -- 对于（学号，课名） → 系名，有 学号 → 系名，存在非主属性 系名 对码（学号，课名）的部分函数依赖。
    -- 对于（学号，课名） → 系主任，有 学号 → 系主任，存在非主属性 系主任 对码（学号，课名）的部分函数依赖。
    ```


???+ 第二范式
    非主属性（除主码以外的所有属性）

    消除了非主属性对于主码的部分函数依赖。判断的依据实际上就是看数据表中是否存在非主属性对于主码的部分函数依赖。
    
    ```SQL
    选课（学号，课名，分数） 主码（学号，课名）
    学生（学号，姓名，系名，系主任） 主码（学号）

    -- 主码为一个属性时，不存在非主属性对主码的部分函数依赖。
    -- 但是存在传递函数依赖。
    ```　

    （学号，学生姓名、年龄、性别、课程、课程学分、系别、学科成绩，系办地址、系办电话 )


???+ 第三范式
   　



### ER实体联系图

实体联系图（E-R diagram）ERD 可以用图形化表示数据库的全局逻辑结构。




## 形式化关系查询

关系代数是一种过程化查询语言。它包含一个运算的集合。这些运算以一个或多个关系做为输入，产生一个新关系做为结果。


基本运算：

- 选择运算：对应SELECT条件查询，选择运算选出来给定谓词的元组。\Sigma
- 投影运算：对应SELECT的字段，仅查询出需要的字段
- 集合并运算: 对应 UNION 查询，
- 集合差运算：
- 笛卡尔积运算：




\Sigma






