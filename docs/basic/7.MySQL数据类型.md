## 数据类型概述


MySQL 支持以下几种类别的 [SQL](https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_sql) 数据类型：

- 数值类型、
- "日期和时间"类型
- 字符串（字符和字节）类型
- 空间类型
- [JSON](https://dev.mysql.com/doc/refman/8.0/en/json.html) 数据类型


数据类型的描述使用了以下约定：

- 对于整型（integer），`int(M)` 中M表示最大的**显示宽度**（display width）；
- 对于浮点型（floating-point）和定点型（fixed-point）类型，`M` 表示可被存储数字的总个数（the precision）；
- 对于字符串类型，`varchar(M)` 中M是字符串中的字符数量。另外，`M` 的最大允许值取决于具体的数据类型和字符编码。
- `D` 应用于浮点型和定点型，它表示小数点后可存在多少个数字（the scale）。可能的最大值为 30，但不应大于 `M`-2。
- `fsp` 应用于 TIME、DATETIME 和 TIMESTAMP 类型，它表示小数的精度（即毫秒、微秒），即小数点后数字的个数。`fsp` 的取值范围为 [0, 6]，其中 0 表示没有小数。若缺省（即不传递该参数），默认精度为 0（与 SQL 标准的默认值 6 不同，主要为了兼容 MySQL 旧版本）。
- 方括号（[]）表示类型定义的可选部分。


## 数值类型

MySQL 支持 SQL 标准中所有数值数据类型。

其中包括 **精确数值类型**（INTEGER、SMALLINT、DECIMAL 和 NUMERIC），也包括 **近似数值类型**（FLOAT、REAL 和 DOUBLE PRECISION）。

**关键字 INT 是 INTEGER 的代名词，关键字 DEC 和 FIXED 是 DECIMAL 的代名词。**

MySQL 将 DOUBLE 视为 DOUBLE PRECISION 的代名词（一种非标准扩展）。

除非启用 SQL 的 [REAL_AS_FLOAT](https://dev.mysql.com/doc/refman/8.0/en/sql-mode.html#sqlmode_real_as_float) 模式，否则 MySQL 也把 REAL 视为 DOUBLE PRECISION 的代名词（一种非标准变体）。



### 精确整型

MySQL 支持 SQL 标准的整型类型：INTEGER（或 INT）和 SMALLINT。**不能存小数位。**

作为标准SQL的扩展，MySQL 也支持这些整型类型：TINYINT、MEDIUMINT 和 BIGINT。以下表格展示了每种整型类型所需的存储空间和取值范围。



| 类型      | 占用存储 (Bytes) | 有符号取值范围             | 无符号取值范围   | 用途备注   |
| --------- | ---------------- | -------------------------- | ---------------- | ---------- |
| TINYINT   | 1                | (-128 , 127)               | (0 , 255)        | 小整数值   |
| SMALLINT  | 2                | (-32768 , 32767)           | (0 , 65535)      | 大整数值   |
| MEDIUMINT | 3                | (-8388608 , 8388607)       | (0 , 16777215)   | 大整数值   |
| INT       | 4                | (-2147483648 , 2147483647) | (0 , 4294967295) | 大整数值   |
| BIGINT    | 8                | (-2^63 , 2^63-1)           | (0 , 2^64-1）    | 超大整数值 |

```sql
CREATE  TABLE demo_test (
    id INT(11) NOT NULL AUTO_INCREMENT,
    a  INT(11)  NOT NULL,
    b  INT(11) UNSIGNED ZEROFILL NOT NULL,
    PRIMARY KEY (`id`)
);
-- 对于Integer类型括号中的数字称为字段的显示宽度。显示宽度并不影响可以存储在该列中的最大值。INT(5) 和 INT(11)可以存储相同的最大值，都是INT最大值。
-- int(11)表示显示宽度，当列设置为UNSIGNED ZEROFILL时，INT(11)才有意义，其表示的意思为如果要存储的数字少于11个字符，则这些数字将在左侧补零。

INSERT INTO demo_a(a,b) VALUES(1, 1);
-- 查询时，显示的宽度是11位数
mysql> SELECT * FROM demo_a;
+----+---+-------------+
| id | a | b           |
+----+---+-------------+
|  1 | 1 | 00000000001 |
+----+---+-------------+
1 row in set (0.18 sec)

```





### 定点型类型（精确值）

DECIMAL 和 NUMERIC 类型能存储精确的数值数据。**可以存小数位**。这些类型适用于重视精确度的需求，如货币数据。



| 类型    | 占用存储 (Bytes) | 有符号取值范围 | 无符号取值范围 | 说明备注     |
| ------- | ---------------- | -------------- | -------------- | ------------ |
| float   | 4 bytes          |                |                | 单精度浮点数 |
| double  | 8 bytes          |                |                | 双精度浮点数 |
| decimal |                  |                |                | 定点型       |

```SQL
-- 浮点类型和定点类型都可以用 TYPE(M, D)来表示，其中M称为精度，表示总共的位数；D称为标度，表示小数的位数。
-- FLOAT(7,4) 表示 -999.9999
-- 不论是定点还是浮点类型，如果用户指定的精度超出精度范围，则会四舍五入进行处理。
-- FLOAT 和 DOUBLE 在不指定精度时，默认会按照实际的精度（由计算机硬件和操作系统决定），DECIMAL 如果不指定精度，默认为（10，0）。
-- DOUBLE 实际上是以字符串的形式存放的，DECIMAL 可能的最大取值范围与 DOUBLE 相同，但是有效的取值范围由 M 和 D 决定。如果改变 M 而固定 D，则取值范围将随 M 的变大而变大。

-- 浮点数相对于定点数的优点是在长度一定的情况下，浮点数能够表示更大的范围；缺点是会引起精度问题。
-- 在MySQL中，定点数以字符串形式存储，在对精度要求比较高的时候（如货币、科学数据），使用 DECIMAL 的类型比较好，另外两个浮点数进行减法和比较运算时也容易出问题，所以在使用浮点数时需要注意，并尽量避免做浮点数比较。
```


## 字符和字符串类型

- 字节：字节是计算机中的存储单位：`1GB=1024MB，1MB=1024KB，1KB=1024Byte，1Byte=8Bit`。其中的`Byte`就是字节。

- 字符(character)：可以理解为一个数字、字母、汉字、标点符号，比如：数字1是一个字符，数字9也是一个字符，但是数字10就是两个字符；字母a就是一个字符，字母B也是一个字符，字母aB就是两个字符；汉字你也是一个字符，汉字我也是一个字符，汉字你我就是两个字符；标点符号?是一个字符，标点符号!也是一个字符，当然这里的标点符号有全角和半角之分，但是不管全角还是半角，它们都是属于不同的字符，也就是说半角的?和全角的？是两个不同的字符。

|数据类型| 类型       | M取值范围  | M含义                        | 说明备注                                         |
|-------| ---------- | ---------- | ---------------------------- | ------------------------------------------------ |
|定长字符串| CHAR(M)    | 0-255      | 表示字段所能容纳最大字符数量 | 固定长度非二进制字符串：字符数量和存储都是固定的 |
|变长字符串| VARCHAR(M) | (0, 65535] | 表示字段所能容纳最大字符数量 | 变长非二进制字符串：字符越多，存储占用越多       |

- 在MySQL5.0以后的版本中，**M 表示当前字段的字符集编码下，字符的个数，也叫列长度。对于不同的字符集编码，单个字符所占用的空间可能有所不同。**
- **无论什么字符集，无论什么类型的字符串，表中的一行数据的所有列加在一起最字节大长度限制为`65535`个byte。（不含text和blob类型列，它们是单独存储的）**

**对于列宽的限制**：

  - MySQL Server层对单表支持最多4096列（[参考](https://dev.mysql.com/doc/refman/8.0/en/column-count-limit.html)），InnoDB引擎层最多支持1017列。（[参考](https://dev.mysql.com/doc/refman/8.0/en/innodb-limits.html)）
  - 如果表只有一个utf8mb4编码的VARCHAR列，列最大字符长度为 65535/4 = 16383 
  - MySQL内部规定，表内所有列加在一起占用的字节数不能大于 65535 
  - 对于InnoDB引擎，列宽还取决于innodb_page_size，[参考](https://dev.mysql.com/doc/refman/8.0/en/innodb-limits.html)



- 对于不同的字符集的字段，varchar类型的列最大字符数量如下：

| 字符集  | 单个字符字节数 | VARCHAR 最大列长度的取值范围(字符个数) | 能否中文 |
| :------ | :------------- | :------------------------------------- | -------- |
| ascii   | 1 byte         | (0, 65535]                             | 不能     |
| latin1  | 1 byte         | (0, 65535]                             | 不能     |
| binary  | 1 byte         | (0, 65535]                             | 不能     |
| utf8    | 3 byte         | (0, 21845]                             | 可以     |
| utf8mb4 | 4 byte         | (0, 16383]                             | 可以     |
|         |                |                                        |          |


- 假设在latin1字符集下。插入值占用情况如下：

|   **插入值**   | **CHAR(4)存入值** | **CHAR(4)占据空间** | **VARCHAR(4)存入值** | **VARCHAR(4)占据空间** |
| :------------: | :---------------: | :-----------------: | :------------------: | :--------------------: |
| `''`(空字符串) |       `'    '`       |       4 bytes       |         `''`         |         1 byte         |
|     `'ab'`     |      `'ab  '`      |       4 bytes       |        `'ab'`        |        3 bytes         |
|    `'abcd'`    |     `'abcd'`      |       4 bytes       |       `'abcd'`       |        5 bytes         |
|  `'abcdefgh'`  |     `'abcd'`      |       4 bytes       |       `'abcd'`       |        5 bytes         |

- 对于定长字符串，无论插入过长或过短，都要占据固定长度的字符数量和存储空间，过短会补空字符，过长会截取。
- 对于变长字符串，实际存入多少，就占用多少。存储超过的，可能会报错（取决于是否设置为严格模式）或者截取。


```SQL
CREATE TABLE vc (v VARCHAR(4), c CHAR(4));	
INSERT INTO vc VALUES ('12', '12');
INSERT INTO vc VALUES ('ab  ', 'ab  ');
INSERT INTO vc VALUES ('123456', '123456'); --这行会报错:Data to long... 
SELECT CONCAT('(', v, ')'), CONCAT('(', c, ')') FROM vc;
```



#### MySQL 为什么建议定义varchar(255) 而不是varchar(256)

我们在定义一个字段varchar(n)的时候，数据库在底层要知道这个字段的最大长度是多少。**这个有点像元数据。**

- 我们定义为varchar(1)，那么他就知道这个字段的长度为1，底层要记录好这个1；

- 我们定义为varchar(255)，那么他就知道这个字段的长度为255，底层要记录好这个255；

- 我们定义为varchar(256)，那么他就知道这个字段的长度为256，底层要记录好这个256；

数据在底层存储的时候，它不是直接把1或255这样的整数直接以十进制的方式存储的，它是把1和255这样的整数转换为2进制的方式来存储的，全部都是0或1的方式来存储。

**关于字段长度标识的元数据，如果是255，用tinyint来标识，元数据占用一个字节。如果超过255，要用smallint来标识，元数据占用两个字节。**

  

 **当实际长度大于255的时候，varchar变长字段长度列表需要用两个字节存储描述，也就意味着每一行数据都会增加1个字节，所以在我们的数据长度不可能超过255的情况下，我们尽量不要创建超过255长度的varchar类型的字段。**

当我们定义一个varchar(255)的字段时，其实它真实使用的空间是256（255+1）字节；（**注意，字段非空，latin1编码**）

当我们定义一个一个varchar(256)字段时，它真实使用的空间是258（256+2）字节



```sql
--验证


-- 试着创建一个字段长度超过mysql限制的表，从系统提示知道，列长度不能超过65535
mysql> create table test_varchar_length(v varchar(65536) not null) CHARSET=latin1;
ERROR 1074 (42000): Column length too big for column 'v' (max = 65535); use BLOB or TEXT instead

-- 创建一个字段长度小于max, 65534的表，继续失败
mysql> create table test_varchar_length(v varchar(65534) not null) CHARSET=latin1;
ERROR 1118 (42000): Row size too large. The maximum row size for the used table type, not counting BLOBs, is 65535. This includes storage overhead, check the manual. You have to change some columns to TEXT or BLOBs

-- 创建一个65533的表，65533+2=65535(max), 成功
mysql> create table test_varchar_length(v varchar(65533) not null) CHARSET=latin1;
Query OK, 0 rows affected (0.05 sec)
```



#### varchar变长为什么不是越大越好？

varchar(10)  和 VARCHAR(1000) 都是变长，反正不额外占用存储，为什么不是越大越好，省得以后要加长又要改变字段定义。

- 第一个原因，存储字段时，字段最大字符长度这个元数据也要占不同空间，上面说的255和256区别，避免浪费
- 字段长度是数据库一种约束，可以保证进入数据库的数据符合长度要求，定义合理的字段长度可以减少一部份非法数据进入。



## 日期和时间类型

MySQL 提供了多种存储时态 （与时间相关的）值的数据类型。主要有 YEAR、TIME、DATE、DATETIME、TIMESTAMP 等。

每个时间类型均拥有各自合法的取值范围，以及一个`零值`，即当你指定一个 MySQL 无法表达的非法值时会被替换为该值。TIMESTAMP 和 DATETIME 数据类型拥有特殊的自动更新能力。



| 数据类型                                                     | 取值范围 | 存储空间                             | 零值                    |
| :----------------------------------------------------------- | :------- | :----------------------------------- | ----------------------- |
| [`YEAR`](https://dev.mysql.com/doc/refman/8.0/en/year.html)  | 1 byte   | 1 byte                               | 0000                    |
| [`DATE`](https://dev.mysql.com/doc/refman/8.0/en/datetime.html) | 3 bytes  | 3 bytes                              | `'0000-00-00'`          |
| [`TIME`](https://dev.mysql.com/doc/refman/8.0/en/time.html)  | 3 bytes  | 3 bytes + fractional seconds storage | `'00:00:00'`            |
| [`DATETIME`](https://dev.mysql.com/doc/refman/8.0/en/datetime.html) | 8 bytes  | 5 bytes + fractional seconds storage | `'0000-00-00 00:00:00'` |
| [`TIMESTAMP`](https://dev.mysql.com/doc/refman/8.0/en/datetime.html) | 4 bytes  | 4 bytes + fractional seconds storage | `'0000-00-00 00:00:00'` |



## 二进制类型


MySQL支持两类字符型数据：文本字符串和二进制字符串。**二进制字符串类型有时候也直接被称为`二进制类型`。**



## 枚举类型



## 空间类型

## JSON类型



## MySQL中的NULL值

在 SQL 中建表，每个字段后面都可以加上 NULL 或 NOT NULL 修饰符来指定该字段是否可以为空(NULL)。**MySQL默认情况下指定字段为NULL修饰符**。

如果一个字段指定为NOT NULL，MySQL则不允许向该字段插入空值(这里面说的空值都为NULL)。**在标准SQL中也可以称为 NOT NULL 约束。**

但是在自增列和TIMESTAMP字段中，这个规则并不适用。向这些字段中插入NULL值将会导致插入下一个自动增加的值或者当前的时间戳。



**NULL 不是一个「值」，而是「没有值」。**

- **判断是否为NULL只能用`where name is null `或 `where name is not null ` 这种语句。**

- **在 MySQL 中将 null 与其他字段或者变量（函数、存储过程）进行算术运算或逻辑运算，结果总是NULL**
- **count计数，COUNT(*)：不管字段为什么，计算存在的行，COUNT(column_name)：结果不包含字段为NULL的记录。**
- 排序，`ASC`时，NULL值在所有其他值之前，`DESC`时，NULL值在所有其他值之后。**请注意与查询中的范围匹配区分，这只是一种约定，并不是因为NULL更小**



**在写 SQL 条件语句时关于字段判断或排序时，要注意考虑字段中可能为NULL的情况。**

- 一般强烈建议为业务字段设置为 not null ， 如果插入时没有值，可以设置为空字符串或业务字段的零值。

```sql
-- 示例

mysql> select 1 is  null  , 1 is not null , 1 and null , 1 = null , 1 > null , 1 + null  , null = null , null is null ;
+------------+---------------+------------+----------+----------+----------+-------------+--------------+
| 1 is  null | 1 is not null | 1 and null | 1 = null | 1 > null | 1 + null | null = null | null is null |
+------------+---------------+------------+----------+----------+----------+-------------+--------------+
|          0 |             1 |       NULL |     NULL |     NULL |     NULL |        NULL |            1 |
+------------+---------------+------------+----------+----------+----------+-------------+--------------+
1 row in set (0.00 sec)

mysql>

 mysql> select length(''), length(null), length(0), length('0');
 +------------+--------------+-----------+-------------+
 | length('') | length(null) | length(0) | length('0') |
 +------------+--------------+-----------+-------------+
 |          0 |         NULL |         1 |           1 |
 +------------+--------------+-----------+-------------+
 1 row in set (0.00 sec)
```





## 选择正确的数据类型

选择的原则是：



- 更小的更好：更小的数据类型通常更快，因为它们占用更少的磁盘、内存和CPU缓存，并且处理时需要的CPU周期也更少。

- 尽量避免NULL：

- 整形比字符操作代价更低。

- 保存日期格式时，要选用MySQL内置的日志格式（TimeStamp, DateTime），而不使用字符串。

- 小数点的保存如何有涉及到运算，用float和double可能会精度不准，可以考虑将小数乘于相应的倍数，然后用BIGINT来存储。







- 当数据存储的是字符，且长度是一个固定区间定值的话就可以考虑使用char来进行存储，如果字符长度是未知的且长度变化特别明显的话，这个时候最好使用varchar来存储。但是不管使用的是哪种字段来进行存储，都不要把字段的初始长度设置为最大化，应该是根据业务需求来存储最合适的长度字段。



- 数据库设计过程中尽量使用int来作为字段类型，因为在所有的数据类型中int不管是存储空间还是执行速度方面都是最好的。例如：如果业务中存储的都是数据的话而且长度不是特别长的话，就可以考虑使用int来进行存储，或者业务中要对数据进行排序的时候需要使用某一标识权重之类的，也可以使用tinyint来进行存储。但是不要因为int高效，而有意识的把所有字段都设计成int来处理，最终还是要根据业务的具体需求来设计相应的字段。

  





## 数据行格式

InnoDB存储引擎和大多数数据库一样，记录是以行的形式存储的，这意味着页中保存着表中一行行的数据。数据一行一行的存储在页中。一页存满了，马上到下一页。

在InnoDB 1.0.X之前，InnoDB存储引擎提供了Compact和Redundant两种格式来存放行记录数据。

Redundant是mysql5.0版本之前的行记录存储方式，之后仍然支持这个格式是为了兼容之前版本的格式，5.1之后很少用到了。

因为Compact的结构设计比它好得多，compact格式消耗的磁盘空间和备份耗时更小，Redundant相比之下大了一些。compact格式更适用于大多数的业务场景。


在InnoDB 1.0.X版本开始又引入了新的文件格式(file format)，以前支持Compact和Redundant格式称为Antelope文件格式，新引入的文件格式称为Barracuda文件格式。

Barracuda文件格式下拥有两种新的行记录格式：Compressed和Dynamic，同时，Barracuda文件格式也包括了Antelope所有的文件格式。这样Barracuda文件格式支持4种row_format：

```
Redundant、Compact、Compressed、Dynamic
```

所谓Row Format行格式是指数据记录(或者称之为行)在磁盘中的物理存储方式：

**具体地，对于InnoDB存储引擎而言，常见的行格式类型有如下四种：Compact、Redundant、Dynamic和Compressed**

- **参数innodb_default_row_format用于在配置文件中指定InnoDB表的默认文件格式，MySQL5.7和8.0的 innodb_default_row_format 默认值是DYNAMIC**
```
show variables like 'innodb_default_row_format';
```

- **用户可以在建表时，显示指定表的row format**
```
CREATE TABLE t1 (c1 INT) ROW_FORMAT=DYNAMIC;

```

```
show variables like 'innodb_file_format';
```

现在基本上都是Barracuda。Dynamic和Compact基本是类似的，但是它们在行溢出数据的处理上却完全不同：


表的行格式决定了它的每行数据是怎么物理存储的，其对查询和DML操作也是有影响。每个磁盘页存的行数越多，查询和索引的查找就越快，缓冲池需要的内存也越少，同时也能减少更新数据的I/O。

每个表的数据都被分成多个页，这些页都存在B-tree索引的树数据结构中。表数据和非主键索引都用这种数据结构。保存了整个表数据的B-tree索引叫做聚簇索引，它是根据表的主键来进行组织的。聚簇索引树的节点保存了一行的所有列的值，非主键索引的节点只包含索引列和主键列的值。

变长列在B-树索引节点的存储策略不太一样，如果长度超过了B-树页的长度，则它们会保存在单独申请的磁盘页中，即溢出页。这些列也叫做off-page列。off-page列的值保存在多个溢出页中，这些溢出页使用单独的链表连接在一起，每个列都有它自己的溢出页链表。为了避免浪费空间或者读取额外的页数据，当列长度超过B-树页大小时，会将变长列的部分前缀串保存在B-树种。

InnoDB存储引擎支持四种行格式： REDUNDANT, COMPACT, DYNAMIC, COMPRESSED。



| 行格式 | 紧凑的存储特性 |      | 压缩支持 |      |
| ------ | -------------- | ---- | -------- | ---- |
|        |                |      |          |      |
|        |                |      |          |      |
|        |                |      |          |      |





### REDUNDANT行格式

REDUNDANT format  提供了对老版本MySQL的兼容性。


## 数据类型转换