
# postgresql体系架构


### 简介


 PostgreSQL数据库是由一系列位于文件系统上的物理文件组成，在数据库运行过程中，通过整套高效严谨的逻辑管理这些物理文件。
 通常将这些物理文件称为数据库，将这些物理文件、管理这些物理文件的进程、进程管理的内存称为这个数据库的实例。
 在PostgreSQL的内部功能实现上，可以分为系统控制器、查询分析器、事务系统、恢复系统、文件系统这几部分。
 其中系统控制器负责接收外部连接请求，查询分析器对连接请求查询进行分析并生成优化后的查询解析树，从文件系统获取结果集或通过事务系统对数据做处理，并由文件系统持久化数据。


### 逻辑结构

数据库集簇（database cluster） 是一组数据库（database） 的集合，由一个PostgreSQL服务器管理。

第一次听到这个定义也许会令人疑惑，PostgreSQL中的术语“数据库集簇”，并非意味着“一组数据库服务器”。 一个PostgreSQL服务器只会在单机上运行并管理单个数据库集簇。


数据库（database） 是数据库对象（database objects） 的集合。 

在关系型数据库理论中，数据库对象是用于存储或引用数据的数据结构。表是一个典型的例子，还有更多种对象，例如索引，序列，视图，函数等。

在PostgreSQL中数据库本身也是数据库对象，并在逻辑上彼此分离。所有其他的数据库对象（例如表，索引等）归属于各自相应的数据库。


![逻辑架构](image.png)


在PostgreSQL内部，所有的数据库对象都通过相应的**对象标识符（Object Identifiers, OID）**进行管理，这些标识符是无符号的4字节整型。

数据库对象与相应OID之间的关系存储在相应的**系统目录（System Catalogs）**中，依具体的对象类型而异。例如数据库和堆表对象的OID分别存储在pg_database和pg_class中

```SQL


```



### postgres进程模型



在数据库术语中，PostgreSQL使用C/S架构。一次PostgreSQL会话由下列相关的进程（程序）组成：

- 服务端进程：一个服务器进程，它管理数据库文件、接受来自客户端与数据库的连接。并且代表客户端在数据库上执行操作。该数据库服务器程序叫做postgres。
postgres一般位于 /usr/lib/postgresql/13/bin/ 

- 客户端进程：典型的 C/S 架构，客户端和服务器可以在不同的主机上。这时它们通过 TCP/IP 网络联接通讯。




```
[postgres@stxz-elk-01 src]$
[postgres@stxz-elk-01 src]$ ps -ef | grep postgres | grep -v grep
postgres  9849     1  0 10:41 ?        00:00:00 /data/postgres/14.4/bin/postgres -D /home/postgres/data
postgres  9850  9849  0 10:02 ?        00:00:00 postgres: logger
postgres  9876  9849  0 10:42 ?        00:00:00 postgres: checkpointer
postgres  9878  9849  0 10:42 ?        00:00:00 postgres: background writer
postgres  9879  9849  0 10:42 ?        00:00:00 postgres: walwriter
postgres  9880  9849  0 10:42 ?        00:00:00 postgres: autovacuum launcher
postgres  9881  9849  0 10:42 ?        00:00:01 postgres: stats collector
postgres  9882  9849  0 10:42 ?        00:00:00 postgres: logical replication launcher
postgres 18247  9849  0 17:22 ?        00:00:00 postgres: postgres dbtt 10.10.30.205(4008) idle
postgres 18268  9849  0 17:22 ?        00:00:00 postgres: postgres dbtt 10.10.30.205(4009) idle
postgres 18995  9849  0 11:08 ?        00:00:00 postgres: postgres dbtt 10.10.30.205(12899) idle
postgres 30539  9849  0 11:42 ?        00:00:00 postgres: postgres postgres 10.10.30.205(12998) idle
[postgres@stxz-elk-01 src]$
[postgres@stxz-elk-01 src]$
```

在服务端用作管理一个数据库实例的多个进程的集合称为`PostgreSQL Server`，它主要包含以下3种类型的进程：

- `postgres server process`：Postgres服务器进程，即守护进程，是数据库集群管理的所有进程的父进程。

- `backend processes`：后端进程，每个后端进程处理连接进来的客户端发出的所有查询和语句。

- `backgroud processes`：后台进程，每个后台进程分别执行相应的功能（例如VACUUM和CHECKPOINT进程）以进行数据库管理。




####  主进程和postmaker进程

postmaker
如果是在centos7+下使用yum安装的postgresql，那么postgresql的启停会托管给systemctl，我们在/usr/lib/systemd/system/postgresql-11.service文件中就可以看到配置的ExecStart

实际上，postmaster 命令只是postgres命令的一个软链接，可以看到postmaster 的目标命令是postgres。

如果是用 pd_ctl -D $PGDATA -l $PGLOGFILE start 启动的，则直接启动postgresql主进程。

真正的主进程也就是postgres进程(可执行文件为./bin/postgres)，它监听了5432端口，用于处理连接。但是真正处理连接的并不是这个进程。


#### 连接进程backend processes

postgresql服务器可以处理来自多个客户端的多个并发请求。 因此，它为每个连接启动 fork 一个新进程(利用./bin/postgres可执行文件)。postgresql在处理客户端连接时成本还是很高的。

**postgresql是进程模型，各个后台进程由postmaster主进程创建，每个客户端连接进来服务器端都会创建一个server process与客户端交互，处理客户端请求。**

对于创建的每个连接，操作系统都需要为打开网络套接字的进程分配内存，PostgreSQL需要自己进行内部计算来建立连接。

将其扩展到数千个用户会话，而仅仅为用户准备好数据库连接就可能浪费大量时间。将max_connections设置为高的其他成本包括磁盘争用、操作系统调度，甚至CPU级缓存线争用。

一旦连接建立之后，客户端和新服务器进程就不再经过最初的 postgres 进程的干涉进行通讯。
因此，主服务器进程总是在运行并等待着客户端连接， 而客户端和相关联的服务器postgres进程则是起起停停（当然，这些对用户是透明的。我们介绍这些主要是为了内容的完整性）。

进程模型有个问题就是容易造成oom，当爆发连接风暴时，work_mem这类参数的设置可能造成内存溢出。
如果发生遇到使用pg_terminate_backend(pid)杀不掉某条sql的情况下（笔者生产环境多次遇到），pg可以在操作系统层面使用kill命令杀掉该连接。

为什么调整最大连接数需要重启，不能修改为reload方式？
这个问题不详细展开，简单来说最大连接数参数和共享内存及信号量等相关的，设置最大连接数后，在启动时系统会相应分配这些资源。那原生的最大连接数参数看起来只能是重启方式修改生效了。


#### 日志进程

logger进程可以收集包括postmaster进程在内的所有进程的stderr日志，这里需要注意是错误日志哦，并不是所有的日志它都会收集。

它支持通过postgresql.conf文件修改日志相关的参数，可以设置最大值并循环覆盖，日志的默认目录在$PGDATA/logs/，像我本机默认的日志记录如下，每天一个日志文件，按照星期存储。

```toml
# 创建一个名为 logging.conf 的补充配置文件，而不是就地修改主配置文件（postgresql.conf），该文件将包含在主集群配置文件中。
# 通过这种方式，我们将能够切换回原始日志记录配置，或者通过简单地复制新文件在其他系统上复制它。
# 为了激活日志相关配置，在postgresql.conf文件末尾插入一条 include_if_exists='logging.conf'


logging_collector = on                            # 是否将日志重定向至文件中，默认是off（该配置修改后，需要重启DB服务）
log_directory = 'log'                             # 日志所属目录，默认是${PGDATA}/log/目录。可以自定义设置相对目录和绝对目录
log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'   # 日志文件名称 
#log_file_mode = 0600                             # 日志文件权限
#log_rotation_age = 1d                            # 单个日志文件的生存期，默认1天，在日志文件大小没有达到log_rotation_size时，一天只生成一个日志文件
#log_rotation_size = 10MB                         # 单个日志文件的大小，如果时间没有超过log_rotation_age，一个日志文件最大只能到10M，否则将新生成一个日志文件。
#log_truncate_on_rotation = off    
```


### 客户端程序

运行PostgreSQL的交互式终端程序，它被称为 psql， 它允许你交互地输入、编辑和执行SQL命令。


**PostgreSQL用户名是和操作系统用户账号分开的。** 

如果你连接到一个数据库时，你可以选择以何种PostgreSQL用户名进行联接; 如果你不选择，那么默认就是你的当前操作系统账号。
如果这样，那么总有一个与操作系统用户同名的PostgreSQL用户账号用于启动服务器， 并且通常这个用户都有创建数据库的权限。

如果你不想以该用户身份登录， 那么你也可以在任何地方声明一个-U选项以选择一个用于连接的PostgreSQL用户名。

```
root@qhdata:~# su postgres
postgres@qhdata:/root$
postgres@qhdata:/root$ psql
psql (13.2 (Ubuntu 13.2-1.pgdg20.04+1))
Type "help" for help.
postgres=#
```


